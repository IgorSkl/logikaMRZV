###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Oct/2015  12:12:05
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  D:\IAR projects\HR1_0100_00_I720_new2\toSpeedOptim.c
#    Command line =  
#        "D:\IAR projects\HR1_0100_00_I720_new2\toSpeedOptim.c" -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --interwork --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\List\toSpeedOptim.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\Obj\toSpeedOptim.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\toSpeedOptim.c
      1          
      2          //#include <TCHAR.H >
      3          
      4          #include <stdio.h>
      5          #include <string.h>
      6          
      7          #include "psuperVisor\supermanager.h"
      8          
      9          #include "bazisdef.h"
     10          #include "component\componentdef.h"
     11          #include "psuperVisor\psvisor_helpdef.h"
     12          #include "logictimers\logictimersdef.h"
     13          
     14          #include "logictimers\logictimersfnc.h"
     15          
     16          #include "..\bazis.h"
     17          
     18          #include "toSpeedOptim.h"
     19          
     20          #define _HIDE_COMPONENT
     21          #include "PRM1Component.c"
     22          
     23          extern int GlobalPO1;//телеметрия
     24          extern int GlobalPO2;//телеметрия
     25          extern int GlobalPO3;//телеметрия
     26          extern int GlobalPO4;//телеметрия
     27          extern int GlobalLevelI_ABC[];//действ значения 3 фаз токов
     28          extern int GlobalLevelUL_ABC[];//действ значения 3 фаз напр
     29          extern int GlobalLevelUF_ABC[];//действ значения 3 фаз напр
     30          extern int GlobalLevel_UCM;
     31          extern int GlobalLevel_ICM;
     32          
     33          //конфигурация
     34          extern COMPONENT_OBJ        cnfCOMPONENT[];
     35          extern COMPONENT_OBJ        cnfCOMPONENT_WL[];
     36          extern int  timerEnableWL;//разрешение работы таймеров РЛ
     37          //текущие уставки супервизора
     38          extern int    spvUSTAVKI[];
     39          extern UNS_32 pActualCMD[];//текущие
     40          extern int   WideCmdRTBuffer[];
     41          extern int offsetENACmdPRM1;//смещение для ENA PRM1
     42          extern int offsetSPVCmdPRM1;//смещение для SPV PRM1
     43          extern int  ENAcmd[];
     44          extern int ReleTrigger;//тригг реле
     45          extern int CDITrigger;//тригг СДИ
     46          //неисправность цепей напр
     47          extern int  isFAILU_COMMON_MTZ;
     48          extern int  isFAILU_COMMON_DZ;
     49          //все напр меньше U005
     50          //extern int  isFAILU005_COMMON;
     51          //все токи меньше I005
     52          extern int  isFAILI005_COMMON;
     53          
     54          //напр UCM меньше UCM005
     55          //extern int  isFAILUCM005_COMMON;
     56          //ток ICM  меньше ICM005
     57          //extern int  isFAILICM005_COMMON;
     58          
     59          extern int  ddvIncrementor;//счетчик времени для Допуск ДВ
     60          extern UNS_32 ArrayRANGIR[];
     61          
     62          extern UNS_32 rawDVLow;//сырые ДВ
     63          extern UNS_32 rawDVMidd;//сырые ДВ
     64          extern UNS_32 rawDVHi;//сырые ДВ
     65          extern UNS_32 oldDV1,  oldDV2,  oldDV3,  oldDV4,  oldDV5,  oldDV6;
     66          extern UNS_32 oldDV7,  oldDV8,  oldDV9,  oldDV10, oldDV11, oldDV12;//сырые ДВ
     67          extern UNS_32 oldDV13, oldDV14, oldDV15, oldDV16;
     68          
     69          extern UNS_32 oldDV17,  oldDV18,  oldDV19,  oldDV20,  oldDV21,  oldDV22;
     70          extern UNS_32 oldDV23,  oldDV24,  oldDV25,  oldDV26,  oldDV27,  oldDV28;//сырые ДВ
     71          extern UNS_32 oldDV29,  oldDV30,  oldDV31,  oldDV32;
     72          
     73          extern UNS_32 oldDV33,  oldDV34,  oldDV35,  oldDV36;
     74          extern int acdcDV;//флаг пост перем для ДВ
     75          //допуски ДВ обработки
     76          extern int  ddv_inc[];
     77          extern int  ddv_fix[];
     78          
     79          
     80          extern UNS_32 pActualCMD[];//текущие
     81          extern BAZIS_TIMER_MEM  bazisTimerMem[];
     82          extern BAZIS_TIMER_MEM  bazisTimerMem_WL[];
     83          
     84          extern UNS_32 ArrayWIDELOG[];
     85          extern UNS_32 PlusCircleCmd[];//командный массив плюсовых команд LE
     86          extern UNS_32 InputLECmd[];//входной командный массив LE
     87          extern UNS_32 EXEOutputCmd[];//выходной командный массив компонентов
     88          
     89          /**********************************************
     90          СУПЕРВИЗОР
     91          Логика компонентов из конфиг
     92          **********************************************/
     93          void EXElogicCOMPONENT() @ "Fast_function"
     94          {
     95            short tmp = 0;
     96            while (cnfCOMPONENT[tmp].componentEnable) {
     97              cnfCOMPONENT[tmp].logic(tmp);
     98              tmp++;
     99            }//while
    100            bazisTimerMem[0].ENABLE = 1;//разрешить лог таймера
    101          //  globalTimerReset = 0;//глобальный сброс всех таймеров
    102          }//EXElogicCOMPONENT()
    103          
    104          /**********************************************
    105          СУПЕРВИЗОР
    106          Логика компонентов из конфиг РЛ
    107          **********************************************/
    108          void EXElogicCOMPONENT_WL() @ "Fast_function"
    109          {
    110            short tmp = 0;
    111            while (cnfCOMPONENT_WL[tmp].componentEnable) {
    112              cnfCOMPONENT_WL[tmp].logic(-tmp-1);
    113              tmp++;
    114            }//while
    115            bazisTimerMem_WL[0].ENABLE = timerEnableWL;//разрешение работы таймеров РЛ
    116          //  globalTimerReset = 0;//глобальный сброс всех таймеров
    117          }//EXElogicCOMPONENT()
    118          
    119          /**********************************************
    120          КОМПРЕССОР МАССИВА
    121          pQuadro - указатель на массив Quadro
    122          p128 - указатель на широкий ком массив 
    123          **********************************************/
    124          void CompressorToQuadro(int *p128, UNS_32 *pQuadro) @ "Fast_function"
    125          {
    126            for (int i=0; i<DQUADRO; i++)
    127            {
    128              UNS_32 tmp = 0;
    129              for (int b=0; b<32; b++)
    130              {
    131                if (p128[i*32+b])//!=0)
    132                {
    133                  tmp |= 1<<b;
    134                }
    135              }//for
    136              pQuadro[i] = tmp;
    137            }//for
    138          }//CompressorToQuadro(int *p128, UNS_32 *pQuadro)
    139          
    140          /**********************************************
    141          КОМПРЕССОР МАССИВА ActualCMD
    142          pActualCMD - указатель на массив текущего Quadro
    143          WideCmdRTBuffer - указатель на широкий ком массив ранжирования 
    144          **********************************************/
    145          void CompressorToActualCMD() @ "Fast_function"
    146          {
    147            for (int i=0; i<DQUADRO; i++)
    148            {
    149              UNS_32 tmp = 0;
    150              for (int b=0; b<32; b++)
    151              {
    152                if (WideCmdRTBuffer[i*32+b])//!=0)
    153                {
    154                  tmp |= 1<<b;
    155                }
    156              }//for
    157              pActualCMD[i] = tmp;
    158            }//for
    159          }//CompressorToActualCMD()
    160          
    161          /**********************************************
    162          ДЕТЕСТОР УРОВНЯ МЕНЬШЕ
    163          level - входной уровень
    164          uSrab - смещение на уставка сработки
    165          uVozv - смещение на уставка возврата
    166          offset_out   - смещение на старый флаг spv
    167          **********************************************/
    168          void  detectorLevelDOWN(int level, int offset_uSrab, int offset_uVozv, int offset_out) @ "Fast_function"
    169          {
    170          //конфигурация меньше
    171              if (spvUSTAVKI[offset_out])   //была сработка
    172              {
    173                if (level>spvUSTAVKI[offset_uVozv])   //возвр
    174                {
    175                  spvUSTAVKI[offset_out] = 0;
    176                  return ;
    177                }//if
    178              }//if
    179              else
    180              {
    181                if (level<=spvUSTAVKI[offset_uSrab])   //сраб
    182                {
    183                  spvUSTAVKI[offset_out] = 1;
    184                  return ;
    185                }//if
    186              }
    187          }//detectorLevelDOWN(int level, int offset_uSrab, int offset_uVozv, int offset_out)
    188          
    189          /**********************************************
    190          ДЕТЕСТОР УРОВНЯ БОЛЬШЕ
    191          level - входной уровень
    192          uSrab - смещение на уставка сработки
    193          uVozv - смещение на уставка возврата
    194          offset_out   - смещение на старый флаг spv
    195          **********************************************/
    196          void  detectorLevelUP(int level, int offset_uSrab, int offset_uVozv, int offset_out) @ "Fast_function"
    197          {
    198          //конфигурация больше
    199              if (spvUSTAVKI[offset_out])   //была сработка
    200              {
    201                if (level<spvUSTAVKI[offset_uVozv])   //возвр
    202                {
    203                  spvUSTAVKI[offset_out] = 0;
    204                  return ;
    205                }//if
    206              }//if
    207              else
    208              {
    209                if (level>=spvUSTAVKI[offset_uSrab])   //сраб
    210                {
    211                  spvUSTAVKI[offset_out] = 1;
    212                  return ;
    213                }//if
    214              }
    215          }//detectorLevelUP(int level, int offset_uSrab, int offset_uVozv, int offset_out)
    216          
    217          /**********************************************
    218          ДЕТЕСТОР УРОВНЯ БОЛЬШЕ
    219          level - входной уровень
    220          uSrab - смещение на уставка сработки
    221          uVozv - смещение на уставка возврата
    222          offset_out   - смещение на старый флаг spv
    223          **********************************************/
    224          void  detectorLevelUP3F(int *level, int offset_uSrab, int offset_uVozv, int offset_out) @ "Fast_function"
    225          {
    226          //конфигурация больше
    227           int tmpSrab = spvUSTAVKI[offset_uSrab];
    228           int tmpVozv = spvUSTAVKI[offset_uVozv];
    229           for(int i=0; i<3; i++)
    230            {
    231              if (spvUSTAVKI[offset_out+i])   //была сработка
    232              {
    233                if (level[i]<tmpVozv)   //возвр
    234                {
    235                  spvUSTAVKI[offset_out+i] = 0;
    236                  continue;
    237                }//if
    238              }//if
    239              else
    240              {
    241                if (level[i]>=tmpSrab)   //сраб
    242                {
    243                  spvUSTAVKI[offset_out+i] = 1;
    244                  continue;
    245                }//if
    246              }
    247            }//for
    248          }//detectorLevelUP3F(int level, int offset_uSrab, int offset_uVozv, int offset_out)
    249          
    250          /**********************************************
    251          ДЕТЕСТОР УРОВНЯ МЕНЬШЕ
    252          level - входной уровень
    253          uSrab - смещение на уставка сработки
    254          uVozv - смещение на уставка возврата
    255          offset_out   - смещение на старый флаг spv
    256          **********************************************/
    257          void  detectorLevelDOWN3F(int *level, int offset_uSrab, int offset_uVozv, int offset_out) @ "Fast_function"
    258          {
    259          //конфигурация меньше
    260           for(int i=0; i<3; i++)
    261            {
    262              if (spvUSTAVKI[offset_out+i])   //была сработка
    263              {
    264                if (level[i]>spvUSTAVKI[offset_uVozv])   //возвр
    265                {
    266                  spvUSTAVKI[offset_out+i] = 0;
    267                  continue;
    268                }//if
    269              }//if
    270              else
    271              {
    272                if (level[i]<=spvUSTAVKI[offset_uSrab])   //сраб
    273                {
    274                  spvUSTAVKI[offset_out+i] = 1;
    275                  continue;
    276                }//if
    277              }
    278            }//for
    279          }//detectorLevelDOWN3F(int level, int offset_uSrab, int offset_uVozv, int offset_out)
    280          
    281          //совпадение текущих и маски
    282          int CheckActualCMD(UNS_32 *cmdArr) @ "Fast_function"
    283          {
    284          //сравнить текущие и ком массив УВВ DQUADRO=10
    285            if((cmdArr[0]&pActualCMD[0]) |//) return 1;
    286               (cmdArr[1]&pActualCMD[1]) |//return 1;
    287               (cmdArr[2]&pActualCMD[2]) |//return 1;
    288               (cmdArr[3]&pActualCMD[3]) |//return 1;
    289               (cmdArr[4]&pActualCMD[4]) |//return 1;
    290               (cmdArr[5]&pActualCMD[5]) |//return 1;
    291               (cmdArr[6]&pActualCMD[6]) |//return 1;
    292               (cmdArr[7]&pActualCMD[7]) |//return 1;
    293               (cmdArr[8]&pActualCMD[8]) |//return 1;
    294               (cmdArr[9]&pActualCMD[9])) return 1;
    295            return 0;
    296          }//CheckActualCMD(UNS_32 *cmdArr)
    297          
    298          //совпадение инверсных текущих и маски
    299          int CheckActualCMDInv(UNS_32 *cmdArr) @ "Fast_function"
    300          {
    301          //сравнить текущие и ком массив УВВ DQUADRO=10
    302            if((cmdArr[0]&(~pActualCMD[0])) |//) return 1;
    303               (cmdArr[1]&(~pActualCMD[1])) |//return 1;
    304               (cmdArr[2]&(~pActualCMD[2])) |//return 1;
    305               (cmdArr[3]&(~pActualCMD[3])) |//return 1;
    306               (cmdArr[4]&(~pActualCMD[4])) |//return 1;
    307               (cmdArr[5]&(~pActualCMD[5])) |//return 1;
    308               (cmdArr[6]&(~pActualCMD[6])) |//return 1;
    309               (cmdArr[7]&(~pActualCMD[7])) |//return 1;
    310               (cmdArr[8]&(~pActualCMD[8])) |//return 1;
    311               (cmdArr[9]&(~pActualCMD[9]))) return 1;
    312            return 0;
    313          }//CheckActualCMDInv(UNS_32 *cmdArr)
    314          
    315          /**********************************************
    316          ФУНКЦИЯ-РАБОТНИК ДЛЯ БРИГАДИРА
    317          Превратить Quadro в широкий ком массив RT
    318          idx - индекс активного бита
    319          Выход - 0-не покидать бригадира
    320          **********************************************/
    321          int pfWorker5(short idx) @ "Fast_function"
    322          {
    323            WideCmdRTBuffer[idx] = 1;//широкий ком массив RT
    324            return 0;
    325          }//pfWorker5(short idx)
    326          
    327          void TranslateQuadroToWideRTCmd(UNS_32 *pQuadro) @ "Fast_function"
    328          {
    329          //Превратить Quadro RT в широкий ком массив RT
    330            //обнулить широкий ком буфер RT
    331            memset(WideCmdRTBuffer, 0, 4*SIZE_RANGIRCMD);
    332            MultiBitWorkerHostQuadro(pQuadro, &pfWorker5);
    333          }//TranslateQuadroToWideRTCmd(UNS_32 *pQuadro)
    334          
    335          /**********************************************
    336          БИТОВЫЙ БРИГАДИР
    337          pQuadro - указатель на массив INTU[DQUADRO]
    338          pfW - указатель на функцию-работника
    339          функция-работник работает только с глобальной памятью
    340          если функция-работник возвратит 1 то MultiBitWorker завершается
    341          **********************************************/
    342          int MultiBitWorkerHostQuadro(UNS_32 *pQuadro, int (*pfW)(short idx)) @ "Fast_function"
    343          {
    344            int cntBit=0;//счетчик бит
    345            for (int i=0; i<DQUADRO; i++)
    346            {
    347              if (pQuadro[i]==0)
    348              {
    349                cntBit+=32;
    350                continue;
    351              }
    352              else
    353              {
    354                for (int b=0; b<32; b++)
    355                {
    356                  if (pQuadro[i]&(1<<b))
    357                  {
    358                    //если работник вернет 1 то покидаем бригадир
    359                    if ((*pfW)(cntBit)) return 1;
    360                  }
    361                  cntBit++;
    362                }//for
    363              }
    364            }//for
    365            return 0;
    366          }//MultiBitWorkerHostQuadro(UNS_32 *pQuadro, int (*pfW)(short idx))
    367          
    368          /**********************************************
    369          БИТОВЫЙ БРИГАДИР
    370          pQuadro - указатель на массив INTU[2*DQUADRO]
    371          pfW - указатель на функцию-работника
    372          функция-работник работает только с глобальной памятью
    373          если функция-работник возвратит 1 то MultiBitWorker завершается
    374          **********************************************/
    375          int MultiBitWorkerHostQuadroWL(UNS_32 *pQuadro, int (*pfW)(short idx)) @ "Fast_function"
    376          {
    377            int cntBit=0;//счетчик бит
    378            for (int i=0; i<2*DQUADRO; i++)
    379            {
    380              if (pQuadro[i]==0)
    381              {
    382                cntBit+=32;
    383                continue;
    384              }
    385              else
    386              {
    387                for (int b=0; b<32; b++)
    388                {
    389                  if (pQuadro[i]&(1<<b))
    390                  {
    391                    //если работник вернет 1 то покидаем бригадир
    392                    if ((*pfW)(cntBit)) return 1;
    393                  }
    394                  cntBit++;
    395                }//for
    396              }
    397            }//for
    398            return 0;
    399          }//MultiBitWorkerHostQuadroWL(UNS_32 *pQuadro, int (*pfW)(short idx))
    400          
    401          void CommonMeasureLogic() @ "Fast_function"
    402          {
    403           //общая логика измерений
    404          
    405          //все токи меньше 12IH
    406            detectorLevelDOWN3F(GlobalLevelI_ABC, offsetSPVCmdPRM1+SPVSRAB_12IH,
    407                                                  offsetSPVCmdPRM1+SPVVOZV_12IH,
    408                                                  offsetSPVCmdPRM1+SPV_OUTA_12IH);
    409          
    410           //
    411           int LocalPO_12IH =   SPV_USTOUT(offsetSPVCmdPRM1+SPV_OUTA_12IH) &
    412                                SPV_USTOUT(offsetSPVCmdPRM1+SPV_OUTB_12IH) &
    413                                SPV_USTOUT(offsetSPVCmdPRM1+SPV_OUTC_12IH);
    414          
    415          //все напр меньше 02UH
    416            detectorLevelDOWN3F(GlobalLevelUL_ABC, offsetSPVCmdPRM1+SPVSRAB_02UH,
    417                                                   offsetSPVCmdPRM1+SPVVOZV_02UH,
    418                                                   offsetSPVCmdPRM1+SPV_OUTA_02UH);
    419          
    420           //
    421           int LocalPO_02UH =   SPV_USTOUT(offsetSPVCmdPRM1+SPV_OUTA_02UH) &
    422                                SPV_USTOUT(offsetSPVCmdPRM1+SPV_OUTB_02UH) &
    423                                SPV_USTOUT(offsetSPVCmdPRM1+SPV_OUTC_02UH);
    424          
    425          //  int ttt1 = 
    426          //  LocalPO_12IH;
    427              //int ttt2 = 
    428           //LocalPO_02UH;
    429          
    430          //неисправность цепей напр 
    431            isFAILU_COMMON_MTZ = (LocalPO_12IH&LocalPO_02UH) &
    432                              //разрешить неисправность цепей напр МТЗ
    433                             ENA_LOGICOUT(offsetENACmdPRM1 +ENA_PRM1_FAILU_MTZ);
    434            isFAILU_COMMON_DZ = (LocalPO_12IH&LocalPO_02UH);// &
    435                              //разрешить неисправность цепей напр DZ
    436          //                   ENA_LOGICOUT(offsetENACmdPRM1 +ENA_PRM1_FAILU_DZ);
    437          
    438          //все напр меньше 005UH
    439            detectorLevelDOWN3F(GlobalLevelUL_ABC, offsetSPVCmdPRM1+SPVSRAB_U005,
    440                                                 offsetSPVCmdPRM1+SPVVOZV_U005,
    441                                                 offsetSPVCmdPRM1+SPV_OUTA_U005);
    442          
    443          //напр lin меньше 0.25B
    444            detectorLevelDOWN3F(GlobalLevelUL_ABC, offsetSPVCmdPRM1+SPVSRAB_U025,
    445                                                 offsetSPVCmdPRM1+SPVVOZV_U025,
    446                                                 offsetSPVCmdPRM1+SPV_OUTAL_U025);
    447          //напр faz меньше 0.25B
    448            detectorLevelDOWN3F(GlobalLevelUF_ABC, offsetSPVCmdPRM1+SPVSRAB_U025,
    449                                                 offsetSPVCmdPRM1+SPVVOZV_U025,
    450                                                 offsetSPVCmdPRM1+SPV_OUTAF_U025);
    451          
    452          
    453          //напр UCM меньше UCM005
    454            detectorLevelDOWN(GlobalLevel_UCM, offsetSPVCmdPRM1+SPVSRAB_UCM005,
    455                                            offsetSPVCmdPRM1+SPVVOZV_UCM005,
    456                                            offsetSPVCmdPRM1+SPV_OUT_UCM005);
    457          
    458          //напр UCM меньше UCM005
    459          //  isFAILUCM005_COMMON = SPV_USTOUT(offsetSPVCmdPRM1+SPV_OUT_UCM005)^1;
    460          
    461          //ток ICM меньше ICM005
    462            detectorLevelDOWN(GlobalLevel_ICM, offsetSPVCmdPRM1+SPVSRAB_ICM005,
    463                                            offsetSPVCmdPRM1+SPVVOZV_ICM005,
    464                                            offsetSPVCmdPRM1+SPV_OUT_ICM005);
    465          
    466          //ток ICM меньше ICM005
    467          //  isFAILICM005_COMMON = SPV_USTOUT(offsetSPVCmdPRM1+SPV_OUT_ICM005)^1;
    468          
    469          }//CommonMeasureLogic();
    470          
    471          #define ACTIV_PASSIV_DV(incfix, ust)  if(ddv_inc[incfix]==ROST){\
    472             int locUst = SPV_USTOUT(offsetSPVCmdPRM1+ ust);\
    473             if(acdcDV) locUst = 3;\
    474             int tmp1 = ddvIncrementor - ddv_fix[incfix];\
    475             if(tmp1<0) tmp1 += (DDV_MAX+1);\
    476             if(tmp1>locUst)\
    477                                       ddv_inc[incfix] = ACTIV;\
    478            }\
    479            if(ddv_inc[incfix]==SPAD){\
    480             int tmp1 = ddvIncrementor - ddv_fix[incfix];\
    481             if(tmp1<0) tmp1 += (DDV_MAX+1);\
    482             if(tmp1>SPV_USTOUT(offsetSPVCmdPRM1+ ust))\
    483                                       ddv_inc[incfix] = PASSIV;\
    484            }
    485          
    486          #define ROST_SPAD_DV(incfix, act, old)  if((act^old)&act) {\
    487               ddv_fix[incfix] = ddvIncrementor;\
    488               if(ddv_inc[incfix] == SPAD)\
    489                                       ddv_inc[incfix] = ACTIV;\
    490               if(ddv_inc[incfix] == PASSIV)\
    491                                       ddv_inc[incfix] = ROST;\
    492            }\
    493            if((act^old)&old) {\
    494               ddv_fix[incfix] = ddvIncrementor;\
    495               if(ddv_inc[incfix] == ROST)\
    496                                       ddv_inc[incfix] = PASSIV;\
    497               if(ddv_inc[incfix] == ACTIV)\
    498                                       ddv_inc[incfix] = SPAD;\
    499            }\
    500            old = act;
    501          
    502          #define OUT_DV(incfix)  if(ddv_inc[incfix] == PASSIV ||\
    503               ddv_inc[incfix] == ROST\
    504               )
    505          enum
    506          {
    507           PASSIV=0,
    508           ROST,
    509           ACTIV,
    510           SPAD
    511          };
    512          
    513          int SelectorDVdriverLow() @ "Fast_function"
    514          {
    515          //селекция ДВ активный-неактивный мл 16 DV
    516            int actDV1=0;  int actDV2=0;  int actDV3=0;  int actDV4=0;  int actDV5=0; int actDV6=0; 
    517            int actDV7=0;  int actDV8=0;  int actDV9=0;  int actDV10=0; int actDV11=0; 
    518            int actDV12=0; int actDV13=0; int actDV14=0; int actDV15=0; int actDV16=0;
    519            if(rawDVLow&1) actDV1 = 1;
    520            if(rawDVLow&2) actDV2 = 1;
    521            if(rawDVLow&4) actDV3 = 1;
    522            if(rawDVLow&8) actDV4 = 1;
    523            if(rawDVLow&16) actDV5 = 1;
    524            if(rawDVLow&32) actDV6 = 1;
    525            if(rawDVLow&64) actDV7 = 1;
    526            if(rawDVLow&128) actDV8 = 1;
    527            if(rawDVLow&(128*2))   actDV9 = 1;
    528            if(rawDVLow&(128*4))   actDV10 = 1;
    529            if(rawDVLow&(128*8))   actDV11 = 1;
    530            if(rawDVLow&(128*16))  actDV12 = 1;
    531            if(rawDVLow&(128*32))  actDV13 = 1;
    532            if(rawDVLow&(128*64))  actDV14 = 1;
    533            if(rawDVLow&(128*128)) actDV15 = 1;
    534            if(rawDVLow&(128*256)) actDV16 = 1;
    535            
    536               ROST_SPAD_DV(DV1_SM-DV1_SM, actDV1, oldDV1)
    537            ACTIV_PASSIV_DV(DV1_SM-DV1_SM, SPV_DDV1_UST)
    538          
    539               ROST_SPAD_DV(DV2_SM-DV1_SM, actDV2, oldDV2)
    540            ACTIV_PASSIV_DV(DV2_SM-DV1_SM, SPV_DDV2_UST)
    541          
    542               ROST_SPAD_DV(DV3_SM-DV1_SM, actDV3, oldDV3)
    543            ACTIV_PASSIV_DV(DV3_SM-DV1_SM, SPV_DDV3_UST)
    544          
    545               ROST_SPAD_DV(DV4_SM-DV1_SM, actDV4, oldDV4)
    546            ACTIV_PASSIV_DV(DV4_SM-DV1_SM, SPV_DDV4_UST)
    547          
    548               ROST_SPAD_DV(DV5_SM-DV1_SM, actDV5, oldDV5)
    549            ACTIV_PASSIV_DV(DV5_SM-DV1_SM, SPV_DDV5_UST)
    550          
    551               ROST_SPAD_DV(DV6_SM-DV1_SM, actDV6, oldDV6)
    552            ACTIV_PASSIV_DV(DV6_SM-DV1_SM, SPV_DDV6_UST)
    553          
    554               ROST_SPAD_DV(DV7_SM-DV1_SM, actDV7, oldDV7)
    555            ACTIV_PASSIV_DV(DV7_SM-DV1_SM, SPV_DDV7_UST)
    556          
    557               ROST_SPAD_DV(DV8_SM-DV1_SM, actDV8, oldDV8)
    558            ACTIV_PASSIV_DV(DV8_SM-DV1_SM, SPV_DDV8_UST)
    559          
    560               ROST_SPAD_DV(DV9_SM-DV1_SM, actDV9, oldDV9)
    561            ACTIV_PASSIV_DV(DV9_SM-DV1_SM, SPV_DDV9_UST)
    562          
    563               ROST_SPAD_DV(DV10_SM-DV1_SM, actDV10, oldDV10)
    564            ACTIV_PASSIV_DV(DV10_SM-DV1_SM, SPV_DDV10_UST)
    565          
    566               ROST_SPAD_DV(DV11_SM-DV1_SM, actDV11, oldDV11)
    567            ACTIV_PASSIV_DV(DV11_SM-DV1_SM, SPV_DDV11_UST)
    568          
    569               ROST_SPAD_DV(DV12_SM-DV1_SM, actDV12, oldDV12)
    570            ACTIV_PASSIV_DV(DV12_SM-DV1_SM, SPV_DDV12_UST)
    571          
    572               ROST_SPAD_DV(DV13_SM-DV1_SM, actDV13, oldDV13)
    573            ACTIV_PASSIV_DV(DV13_SM-DV1_SM, SPV_DDV13_UST)
    574          
    575               ROST_SPAD_DV(DV14_SM-DV1_SM, actDV14, oldDV14)
    576            ACTIV_PASSIV_DV(DV14_SM-DV1_SM, SPV_DDV14_UST)
    577          
    578               ROST_SPAD_DV(DV15_SM-DV1_SM, actDV15, oldDV15)
    579            ACTIV_PASSIV_DV(DV15_SM-DV1_SM, SPV_DDV15_UST)
    580          
    581               ROST_SPAD_DV(DV16_SM-DV1_SM, actDV16, oldDV16)
    582            ACTIV_PASSIV_DV(DV16_SM-DV1_SM, SPV_DDV16_UST)
    583          
    584           int ret = 0;
    585            OUT_DV(DV1_SM-DV1_SM)ret &= ~1;
    586            else ret |= 1;
    587          
    588            OUT_DV(DV2_SM-DV1_SM)ret &= ~2;
    589            else ret |= 2;
    590          
    591            OUT_DV(DV3_SM-DV1_SM)ret &= ~4;
    592            else ret |= 4;
    593          
    594            OUT_DV(DV4_SM-DV1_SM)ret &= ~8;
    595            else ret |= 8;
    596          
    597            OUT_DV(DV5_SM-DV1_SM)ret &= ~16;
    598            else ret |= 16;
    599          
    600            OUT_DV(DV6_SM-DV1_SM)ret &= ~32;
    601            else ret |= 32;
    602          
    603            OUT_DV(DV7_SM-DV1_SM)ret &= ~64;
    604            else ret |= 64;
    605          
    606            OUT_DV(DV8_SM-DV1_SM)ret &= ~128;
    607            else ret |= 128;
    608          
    609            OUT_DV(DV9_SM-DV1_SM)ret &= ~(128*2);
    610            else ret |= (128*2);
    611          
    612            OUT_DV(DV10_SM-DV1_SM)ret &= ~(128*4);
    613            else ret |= (128*4);
    614          
    615            OUT_DV(DV11_SM-DV1_SM)ret &= ~(128*8);
    616            else ret |= (128*8);
    617          
    618            OUT_DV(DV12_SM-DV1_SM)ret &= ~(128*16);
    619            else ret |= (128*16);
    620          
    621            OUT_DV(DV13_SM-DV1_SM)ret &= ~(128*32);
    622            else ret |= (128*32);
    623          
    624            OUT_DV(DV14_SM-DV1_SM)ret &= ~(128*64);
    625            else ret |= (128*64);
    626          
    627            OUT_DV(DV15_SM-DV1_SM)ret &= ~(128*128);
    628            else ret |= (128*128);
    629          
    630            OUT_DV(DV16_SM-DV1_SM)ret &= ~(128*256);
    631            else ret |= (128*256);
    632          
    633            return ret;
    634          }//SelectorDVdriverLow()
    635          
    636          int SelectorDVdriverMidd() @ "Fast_function"
    637          {
    638          //селекция ДВ активный-неактивный cp 16 DV
    639            int actDV1=0;  int actDV2=0;  int actDV3=0;  int actDV4=0;  int actDV5=0; int actDV6=0; 
    640            int actDV7=0;  int actDV8=0;  int actDV9=0;  int actDV10=0; int actDV11=0;
    641            int actDV12=0; int actDV13=0; int actDV14=0; int actDV15=0; int actDV16=0;
    642            if(rawDVMidd&1) actDV1 = 1;
    643            if(rawDVMidd&2) actDV2 = 1;
    644            if(rawDVMidd&4) actDV3 = 1;
    645            if(rawDVMidd&8) actDV4 = 1;
    646            if(rawDVMidd&16) actDV5 = 1;
    647            if(rawDVMidd&32) actDV6 = 1;
    648            if(rawDVMidd&64) actDV7 = 1;
    649            if(rawDVMidd&128) actDV8 = 1;
    650            if(rawDVMidd&(128*2))   actDV9 = 1;
    651            if(rawDVMidd&(128*4))   actDV10 = 1;
    652            if(rawDVMidd&(128*8))   actDV11 = 1;
    653            if(rawDVMidd&(128*16))  actDV12 = 1;
    654            if(rawDVMidd&(128*32))  actDV13 = 1;
    655            if(rawDVMidd&(128*64))  actDV14 = 1;
    656            if(rawDVMidd&(128*128)) actDV15 = 1;
    657            if(rawDVMidd&(128*256)) actDV16 = 1;
    658          
    659               ROST_SPAD_DV(DV17_SM-DV1_SM, actDV1, oldDV17)
    660            ACTIV_PASSIV_DV(DV17_SM-DV1_SM, SPV_DDV17_UST)
    661          
    662               ROST_SPAD_DV(DV18_SM-DV1_SM, actDV2, oldDV18)
    663            ACTIV_PASSIV_DV(DV18_SM-DV1_SM, SPV_DDV18_UST)
    664          
    665               ROST_SPAD_DV(DV19_SM-DV1_SM, actDV3, oldDV19)
    666            ACTIV_PASSIV_DV(DV19_SM-DV1_SM, SPV_DDV19_UST)
    667          
    668               ROST_SPAD_DV(DV20_SM-DV1_SM, actDV4, oldDV20)
    669            ACTIV_PASSIV_DV(DV20_SM-DV1_SM, SPV_DDV20_UST)
    670          
    671               ROST_SPAD_DV(DV21_SM-DV1_SM, actDV5, oldDV21)
    672            ACTIV_PASSIV_DV(DV21_SM-DV1_SM, SPV_DDV21_UST)
    673          
    674               ROST_SPAD_DV(DV22_SM-DV1_SM, actDV6, oldDV22)
    675            ACTIV_PASSIV_DV(DV22_SM-DV1_SM, SPV_DDV22_UST)
    676          
    677               ROST_SPAD_DV(DV23_SM-DV1_SM, actDV7, oldDV23)
    678            ACTIV_PASSIV_DV(DV23_SM-DV1_SM, SPV_DDV23_UST)
    679          
    680               ROST_SPAD_DV(DV24_SM-DV1_SM, actDV8, oldDV24)
    681            ACTIV_PASSIV_DV(DV24_SM-DV1_SM, SPV_DDV24_UST)
    682          
    683               ROST_SPAD_DV(DV25_SM-DV1_SM, actDV9, oldDV25)
    684            ACTIV_PASSIV_DV(DV25_SM-DV1_SM, SPV_DDV25_UST)
    685          
    686               ROST_SPAD_DV(DV26_SM-DV1_SM, actDV10, oldDV26)
    687            ACTIV_PASSIV_DV(DV26_SM-DV1_SM, SPV_DDV26_UST)
    688          
    689               ROST_SPAD_DV(DV27_SM-DV1_SM, actDV11, oldDV27)
    690            ACTIV_PASSIV_DV(DV27_SM-DV1_SM, SPV_DDV27_UST)
    691          
    692               ROST_SPAD_DV(DV28_SM-DV1_SM, actDV12, oldDV28)
    693            ACTIV_PASSIV_DV(DV28_SM-DV1_SM, SPV_DDV28_UST)
    694          
    695               ROST_SPAD_DV(DV29_SM-DV1_SM, actDV13, oldDV29)
    696            ACTIV_PASSIV_DV(DV29_SM-DV1_SM, SPV_DDV29_UST)
    697          
    698               ROST_SPAD_DV(DV30_SM-DV1_SM, actDV14, oldDV30)
    699            ACTIV_PASSIV_DV(DV30_SM-DV1_SM, SPV_DDV30_UST)
    700          
    701               ROST_SPAD_DV(DV31_SM-DV1_SM, actDV15, oldDV31)
    702            ACTIV_PASSIV_DV(DV31_SM-DV1_SM, SPV_DDV31_UST)
    703          
    704               ROST_SPAD_DV(DV32_SM-DV1_SM, actDV16, oldDV32)
    705            ACTIV_PASSIV_DV(DV32_SM-DV1_SM, SPV_DDV32_UST)
    706          
    707           int ret = 0;
    708            OUT_DV(DV17_SM-DV1_SM)ret &= ~1;
    709            else ret |= 1;
    710          
    711            OUT_DV(DV18_SM-DV1_SM)ret &= ~2;
    712            else ret |= 2;
    713          
    714            OUT_DV(DV19_SM-DV1_SM)ret &= ~4;
    715            else ret |= 4;
    716          
    717            OUT_DV(DV20_SM-DV1_SM)ret &= ~8;
    718            else ret |= 8;
    719          
    720            OUT_DV(DV21_SM-DV1_SM)ret &= ~16;
    721            else ret |= 16;
    722          
    723            OUT_DV(DV22_SM-DV1_SM)ret &= ~32;
    724            else ret |= 32;
    725          
    726            OUT_DV(DV23_SM-DV1_SM)ret &= ~64;
    727            else ret |= 64;
    728          
    729            OUT_DV(DV24_SM-DV1_SM)ret &= ~128;
    730            else ret |= 128;
    731          
    732            OUT_DV(DV25_SM-DV1_SM)ret &= ~(128*2);
    733            else ret |= (128*2);
    734          
    735            OUT_DV(DV26_SM-DV1_SM)ret &= ~(128*4);
    736            else ret |= (128*4);
    737          
    738            OUT_DV(DV27_SM-DV1_SM)ret &= ~(128*8);
    739            else ret |= (128*8);
    740          
    741            OUT_DV(DV28_SM-DV1_SM)ret &= ~(128*16);
    742            else ret |= (128*16);
    743          
    744            OUT_DV(DV29_SM-DV1_SM)ret &= ~(128*32);
    745            else ret |= (128*32);
    746          
    747            OUT_DV(DV30_SM-DV1_SM)ret &= ~(128*64);
    748            else ret |= (128*64);
    749          
    750            OUT_DV(DV31_SM-DV1_SM)ret &= ~(128*128);
    751            else ret |= (128*128);
    752          
    753            OUT_DV(DV32_SM-DV1_SM)ret &= ~(128*256);
    754            else ret |= (128*256);
    755          
    756            return ret;
    757          }//SelectorDVdriverMidd()
    758          
    759          int SelectorDVdriverHi() @ "Fast_function"
    760          {
    761          //селекция ДВ активный-неактивный ct DV
    762            int actDV1=0;  int actDV2=0;  int actDV3=0;  int actDV4=0;  
    763          
    764            if(rawDVHi&1) actDV1 = 1;
    765            if(rawDVHi&2) actDV2 = 1;
    766            if(rawDVHi&4) actDV3 = 1;
    767            if(rawDVHi&8) actDV4 = 1;
    768          
    769               ROST_SPAD_DV(DV33_SM-DV1_SM, actDV1, oldDV33)
    770            ACTIV_PASSIV_DV(DV33_SM-DV1_SM, SPV_DDV33_UST)
    771          
    772               ROST_SPAD_DV(DV34_SM-DV1_SM, actDV2, oldDV34)
    773            ACTIV_PASSIV_DV(DV34_SM-DV1_SM, SPV_DDV34_UST)
    774          
    775               ROST_SPAD_DV(DV35_SM-DV1_SM, actDV3, oldDV35)
    776            ACTIV_PASSIV_DV(DV35_SM-DV1_SM, SPV_DDV35_UST)
    777          
    778               ROST_SPAD_DV(DV36_SM-DV1_SM, actDV4, oldDV36)
    779            ACTIV_PASSIV_DV(DV36_SM-DV1_SM, SPV_DDV36_UST)
    780          
    781           int ret = 0;
    782            OUT_DV(DV33_SM-DV1_SM)ret &= ~1;
    783            else ret |= 1;
    784          
    785            OUT_DV(DV34_SM-DV1_SM)ret &= ~2;
    786            else ret |= 2;
    787          
    788            OUT_DV(DV35_SM-DV1_SM)ret &= ~4;
    789            else ret |= 4;
    790          
    791            OUT_DV(DV36_SM-DV1_SM)ret &= ~8;
    792            else ret |= 8;
    793          
    794            return ret;
    795          }//SelectorDVdriverHi()
    796          
    797          int addCDItrig(int cdi_bdvv1) @ "Fast_function"
    798          {
    799          //добавить триггер
    800           int trg_maska = cdi_bdvv1;
    801          //уставка НормальныйТриггерный
    802            trg_maska &= SPV_USTOUT(offsetSPVCmdPRM1+ SPV_UPR_CDI);
    803          
    804            CDITrigger |= trg_maska;//тригг Rele
    805            cdi_bdvv1  |= CDITrigger;
    806            return cdi_bdvv1;
    807          }//addCDItrig(int cdi_bdvv1)
    808          
    809          int addReleTrig(int rele_bdvv1) @ "Fast_function"
    810          {
    811          //добавить триггер
    812           int trg_maska = rele_bdvv1;
    813          //уставка НормальныйТриггерный
    814            trg_maska &= SPV_USTOUT(offsetSPVCmdPRM1+ SPV_UPR_RELE);
    815          
    816           ReleTrigger |= trg_maska;//тригг Rele
    817            rele_bdvv1  |= ReleTrigger;
    818            return rele_bdvv1;
    819          }//addReletrig(int cdi_bdvv1)
    820          
    821          /**********************************************
    822          МЕНЕДЖЕР РАСШИРЕННОЙ ЛОГИКИ
    823          Логический элемент ИЛИ
    824          **********************************************/
    825          int elementOR(int lgm) @ "Fast_function"
    826          {
    827          //OR
    828            UNS_32 *cmdTmpPLUS  = &(ArrayWIDELOG[2*DQUADRO*3*lgm +2*DQUADRO+2*DQUADRO]);//командный массив tmpPLUS
    829            UNS_32 *cmdTmpMINUS = &(ArrayWIDELOG[2*DQUADRO*3*lgm +2*DQUADRO]);//командный массив tmpMINUS
    830            UNS_32 *cmdTmpPRM   = &(ArrayWIDELOG[2*DQUADRO*3*lgm]);//командный массив tmpPRM
    831              for (int i=0; i<(2*DQUADRO); i++)
    832              {
    833                if ((cmdTmpPRM[i] & InputLECmd[i])!=0 ||//прямые
    834                    (cmdTmpMINUS[i] & (InputLECmd[i] ^ cmdTmpMINUS[i]))!=0 //инверсные
    835                   )
    836                {
    837                  for (int k=0; k<(2*DQUADRO); k++) PlusCircleCmd[k] |= cmdTmpPLUS[k];//добавить плюсовые
    838                  return 0;
    839                }//if
    840              }//for(int i=0; i<8; i++)
    841              for (int k=0; k<(2*DQUADRO); k++) PlusCircleCmd[k] &= ~cmdTmpPLUS[k];//убрать плюсовые
    842              return 1;
    843          }//elementOR()
    844          
    845          /**********************************************
    846          МЕНЕДЖЕР РАСШИРЕННОЙ ЛОГИКИ
    847          Логический элемент И
    848          **********************************************/
    849          int elementAND(int lgm) @ "Fast_function"
    850          {
    851          //AND
    852            UNS_32 *cmdTmpPLUS  = &(ArrayWIDELOG[2*DQUADRO*3*lgm +2*DQUADRO+2*DQUADRO]);//командный массив tmpPLUS
    853            UNS_32 *cmdTmpMINUS = &(ArrayWIDELOG[2*DQUADRO*3*lgm +2*DQUADRO]);//командный массив tmpMINUS
    854            UNS_32 *cmdTmpPRM   = &(ArrayWIDELOG[2*DQUADRO*3*lgm]);//командный массив tmpPRM
    855              for (int i=0; i<(2*DQUADRO); i++)
    856              {
    857                if ((cmdTmpPRM[i] & (InputLECmd[i] ^ cmdTmpPRM[i]))!=0 || //прямые
    858                    (cmdTmpMINUS[i] & InputLECmd[i])!=0 //инверсные
    859                   )
    860                {
    861                  for (int k=0; k<(2*DQUADRO); k++) PlusCircleCmd[k] &= ~cmdTmpPLUS[k];//убрать плюсовые
    862                  return 0;
    863                }//if
    864              }//for(int i=0; i<8; i++)
    865              for (int k=0; k<(2*DQUADRO); k++) PlusCircleCmd[k] |= cmdTmpPLUS[k];//добавить плюсовые
    866                  return 1;
    867          }//elementAND()
    868          
    869          /**********************************************
    870          МЕНЕДЖЕР РАСШИРЕННОЙ ЛОГИКИ
    871          Логический элемент ИСКЛ ИЛИ
    872          **********************************************/
    873          void elementXOR(int lgm) @ "Fast_function"
    874          {
    875          //XOR
    876            UNS_32 *cmdTmpPLUS  = &(ArrayWIDELOG[2*DQUADRO*3*lgm +2*DQUADRO+2*DQUADRO]);//командный массив tmpPLUS
    877          
    878             if(elementOR(lgm)) return;//убрать плюсовые если все 0
    879             if(elementAND(lgm)){
    880              for (int k=0; k<(2*DQUADRO); k++) PlusCircleCmd[k] &= ~cmdTmpPLUS[k];//убрать плюсовые
    881              return;
    882              }//if
    883              for (int k=0; k<(2*DQUADRO); k++) PlusCircleCmd[k] |= cmdTmpPLUS[k];//добавить плюсовые
    884          }//elementXOR()
    885          
    886          void dvUnionMakerLow(UNS_32 selectorDV, UNS_32 *dvUnion) @ "Fast_function"
    887          {
    888          //получить массив dvUnion для мл 16 DV
    889          //сформировать массив  Quadro для DV
    890           if((selectorDV&1)>0){
    891             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV1_SM*DQUADRO+ i];
    892           }//if
    893          
    894           if((selectorDV&2)>0){
    895             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV2_SM*DQUADRO+ i];
    896           }//if
    897          
    898           if((selectorDV&4)>0){
    899             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV3_SM*DQUADRO+ i];
    900           }//if
    901          
    902           if((selectorDV&8)>0){
    903             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV4_SM*DQUADRO+ i];
    904           }//if
    905          
    906           if((selectorDV&16)>0){
    907             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV5_SM*DQUADRO+ i];
    908           }//if
    909          
    910           if((selectorDV&32)>0){
    911             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV6_SM*DQUADRO+ i];
    912           }//if
    913          
    914           if((selectorDV&64)>0){
    915             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV7_SM*DQUADRO+ i];
    916           }//if
    917          
    918           if((selectorDV&128)>0){
    919             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV8_SM*DQUADRO+ i];
    920           }//if
    921          
    922           if((selectorDV&(128*2))>0){
    923             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV9_SM*DQUADRO+ i];
    924           }//if
    925          
    926           if((selectorDV&(128*4))>0){
    927             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV10_SM*DQUADRO+ i];
    928           }//if
    929          
    930           if((selectorDV&(128*8))>0){
    931             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV11_SM*DQUADRO+ i];
    932           }//if
    933          
    934           if((selectorDV&(128*16))>0){
    935             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV12_SM*DQUADRO+ i];
    936           }//if
    937          
    938           if((selectorDV&(128*32))>0){
    939             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV13_SM*DQUADRO+ i];
    940           }//if
    941          
    942           if((selectorDV&(128*64))>0){
    943             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV14_SM*DQUADRO+ i];
    944           }//if
    945          
    946           if((selectorDV&(128*128))>0){
    947             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV15_SM*DQUADRO+ i];
    948           }//if
    949          
    950           if((selectorDV&(128*256))>0){
    951             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV16_SM*DQUADRO+ i];
    952           }//if
    953          
    954          }//dvUnionMakerLow(UNS_32 selectorDV, UNS_32 *dvUnion)
    955          
    956          void dvUnionMakerMidd(UNS_32 selectorDV, UNS_32 *dvUnion) @ "Fast_function"
    957          {
    958          //получить массив dvUnion для cp 16 DV
    959          //сформировать массив  Quadro для DV
    960           if((selectorDV&1)>0){
    961             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV17_SM*DQUADRO+ i];
    962           }//if
    963          
    964           if((selectorDV&2)>0){
    965             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV18_SM*DQUADRO+ i];
    966           }//if
    967          
    968           if((selectorDV&4)>0){
    969             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV19_SM*DQUADRO+ i];
    970           }//if
    971          
    972           if((selectorDV&8)>0){
    973             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV20_SM*DQUADRO+ i];
    974           }//if
    975          
    976           if((selectorDV&16)>0){
    977             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV21_SM*DQUADRO+ i];
    978           }//if
    979          
    980           if((selectorDV&32)>0){
    981             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV22_SM*DQUADRO+ i];
    982           }//if
    983          
    984           if((selectorDV&64)>0){
    985             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV23_SM*DQUADRO+ i];
    986           }//if
    987          
    988           if((selectorDV&128)>0){
    989             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV24_SM*DQUADRO+ i];
    990           }//if
    991          
    992           if((selectorDV&(128*2))>0){
    993             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV25_SM*DQUADRO+ i];
    994           }//if
    995          
    996           if((selectorDV&(128*4))>0){
    997             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV26_SM*DQUADRO+ i];
    998           }//if
    999          
   1000           if((selectorDV&(128*8))>0){
   1001             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV27_SM*DQUADRO+ i];
   1002           }//if
   1003          
   1004           if((selectorDV&(128*16))>0){
   1005             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV28_SM*DQUADRO+ i];
   1006           }//if
   1007          
   1008           if((selectorDV&(128*32))>0){
   1009             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV29_SM*DQUADRO+ i];
   1010           }//if
   1011          
   1012           if((selectorDV&(128*64))>0){
   1013             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV30_SM*DQUADRO+ i];
   1014           }//if
   1015          
   1016           if((selectorDV&(128*128))>0){
   1017             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV31_SM*DQUADRO+ i];
   1018           }//if
   1019          
   1020           if((selectorDV&(128*256))>0){
   1021             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV32_SM*DQUADRO+ i];
   1022           }//if
   1023          
   1024          }//dvUnionMakerMidd(UNS_32 selectorDV, UNS_32 *dvUnion)
   1025          
   1026          void dvUnionMakerHi(UNS_32 selectorDV, UNS_32 *dvUnion) @ "Fast_function"
   1027          {
   1028          //получить массив dvUnion для cp 16 DV
   1029          //сформировать массив  Quadro для DV
   1030           if((selectorDV&1)>0){
   1031             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV33_SM*DQUADRO+ i];
   1032           }//if
   1033          
   1034           if((selectorDV&2)>0){
   1035             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV34_SM*DQUADRO+ i];
   1036           }//if
   1037          
   1038           if((selectorDV&4)>0){
   1039             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV35_SM*DQUADRO+ i];
   1040           }//if
   1041          
   1042           if((selectorDV&8)>0){
   1043             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV36_SM*DQUADRO+ i];
   1044           }//if
   1045          }//dvUnionMakerHi(UNS_32 selectorDV, UNS_32 *dvUnion)
   1046          
   1047          UNS_32 WorkRangirRele() @ "Fast_function"
   1048          {
   1049          //исполнить ранжирование реле
   1050            int rele_bdvv1 = 0;//замкнуть реле
   1051          //исполнить ранжирование реле
   1052            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE1_SM*DQUADRO]))) rele_bdvv1 |= 1;
   1053            else rele_bdvv1 &= ~1;
   1054            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE2_SM*DQUADRO]))) rele_bdvv1 |= 2;
   1055            else rele_bdvv1 &= ~2;
   1056            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE3_SM*DQUADRO]))) rele_bdvv1 |= 4;
   1057            else rele_bdvv1 &= ~4;
   1058            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE4_SM*DQUADRO]))) rele_bdvv1 |= 8;
   1059            else rele_bdvv1 &= ~8;
   1060            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE5_SM*DQUADRO]))) rele_bdvv1 |= 16;
   1061            else rele_bdvv1 &= ~16;
   1062            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE6_SM*DQUADRO]))) rele_bdvv1 |= 32;
   1063            else rele_bdvv1 &= ~32;
   1064            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE7_SM*DQUADRO]))) rele_bdvv1 |= 64;
   1065            else rele_bdvv1 &= ~64;
   1066            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE8_SM*DQUADRO]))) rele_bdvv1 |= 128;
   1067            else rele_bdvv1 &= ~128;
   1068            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE9_SM*DQUADRO]))) rele_bdvv1 |= (128*2);
   1069            else rele_bdvv1 &= ~(128*2);
   1070            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE10_SM*DQUADRO]))) rele_bdvv1 |= (128*4);
   1071            else rele_bdvv1 &= ~(128*4);
   1072            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE11_SM*DQUADRO]))) rele_bdvv1 |= (128*8);
   1073            else rele_bdvv1 &= ~(128*8);
   1074            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE12_SM*DQUADRO]))) rele_bdvv1 |= (128*16);
   1075            else rele_bdvv1 &= ~(128*16);
   1076            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE13_SM*DQUADRO]))) rele_bdvv1 |= (128*32);
   1077            else rele_bdvv1 &= ~(128*32);
   1078            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE14_SM*DQUADRO]))) rele_bdvv1 |= (128*64);
   1079            else rele_bdvv1 &= ~(128*64);
   1080            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE15_SM*DQUADRO]))) rele_bdvv1 |= (128*128);
   1081            else rele_bdvv1 &= ~(128*128);
   1082            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[RELE16_SM*DQUADRO]))) rele_bdvv1 |= (128*256);
   1083            else rele_bdvv1 &= ~(128*256);
   1084          
   1085            return addReleTrig(rele_bdvv1);//добавить триггер
   1086          }//WorkRangirRele()
   1087          
   1088          UNS_32 WorkRangirCDI() @ "Fast_function"
   1089          {
   1090          //исполнить ранжирование СДИ
   1091            int cdi_bdvv1 = 0;//СДИ
   1092          //исполнить ранжирование СДИ
   1093            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[CDI1_SM*DQUADRO]))) cdi_bdvv1 |= 1;
   1094            else cdi_bdvv1 &= ~1;
   1095            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[CDI2_SM*DQUADRO]))) cdi_bdvv1 |= 2;
   1096            else cdi_bdvv1 &= ~2;
   1097            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[CDI3_SM*DQUADRO]))) cdi_bdvv1 |= 4;
   1098            else cdi_bdvv1 &= ~4;
   1099            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[CDI4_SM*DQUADRO]))) cdi_bdvv1 |= 8;
   1100            else cdi_bdvv1 &= ~8;
   1101            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[CDI5_SM*DQUADRO]))) cdi_bdvv1 |= 16;
   1102            else cdi_bdvv1 &= ~16;
   1103            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[CDI6_SM*DQUADRO]))) cdi_bdvv1 |= 32;
   1104            else cdi_bdvv1 &= ~32;
   1105            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[CDI7_SM*DQUADRO]))) cdi_bdvv1 |= 64;
   1106            else cdi_bdvv1 &= ~64;
   1107            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[CDI8_SM*DQUADRO]))) cdi_bdvv1 |= 128;
   1108            else cdi_bdvv1 &= ~128;
   1109            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[CDI9_SM*DQUADRO]))) cdi_bdvv1 |= (128*2);
   1110            else cdi_bdvv1 &= ~(128*2);
   1111            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[CDI10_SM*DQUADRO]))) cdi_bdvv1 |= (128*4);
   1112            else cdi_bdvv1 &= ~(128*4);
   1113            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[CDI11_SM*DQUADRO]))) cdi_bdvv1 |= (128*8);
   1114            else cdi_bdvv1 &= ~(128*8);
   1115            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[CDI12_SM*DQUADRO]))) cdi_bdvv1 |= (128*16);
   1116            else cdi_bdvv1 &= ~(128*16);
   1117            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[CDI13_SM*DQUADRO]))) cdi_bdvv1 |= (128*32);
   1118            else cdi_bdvv1 &= ~(128*32);
   1119            if(CheckActualCMD((UNS_32 *)&(ArrayRANGIR[CDI14_SM*DQUADRO]))) cdi_bdvv1 |= (128*64);
   1120            else cdi_bdvv1 &= ~(128*64);
   1121          
   1122            return addCDItrig(cdi_bdvv1);//добавить триггер
   1123          }//WorkRangirCDI()
   1124          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CheckActualCMD
       0   CheckActualCMDInv
      16   CommonMeasureLogic
        16   -> detectorLevelDOWN
        16   -> detectorLevelDOWN3F
       4   CompressorToActualCMD
       8   CompressorToQuadro
       8   EXElogicCOMPONENT
         8   -- Indirect call
       8   EXElogicCOMPONENT_WL
         8   -- Indirect call
      24   MultiBitWorkerHostQuadro
        24   -- Indirect call
      24   MultiBitWorkerHostQuadroWL
        24   -- Indirect call
      24   SelectorDVdriverHi
     120   SelectorDVdriverLow
     120   SelectorDVdriverMidd
      24   TranslateQuadroToWideRTCmd
        24   -> MultiBitWorkerHostQuadro
        24   -> __aeabi_memset
       8   WorkRangirCDI
         8   -> CheckActualCMD
         8   -> addCDItrig
       8   WorkRangirRele
         8   -> CheckActualCMD
         8   -> addReleTrig
       0   addCDItrig
       0   addReleTrig
       8   detectorLevelDOWN
      12   detectorLevelDOWN3F
       8   detectorLevelUP
      20   detectorLevelUP3F
       4   dvUnionMakerHi
       4   dvUnionMakerLow
       4   dvUnionMakerMidd
      12   elementAND
      12   elementOR
      16   elementXOR
        16   -> elementAND
        16   -> elementOR
       0   pfWorker5


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable16
       4  ??DataTable17
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable21
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_12
       4  ??DataTable24_13
       4  ??DataTable24_14
       4  ??DataTable24_15
       4  ??DataTable24_16
       4  ??DataTable24_17
       4  ??DataTable24_18
       4  ??DataTable24_19
       4  ??DataTable24_2
       4  ??DataTable24_20
       4  ??DataTable24_21
       4  ??DataTable24_22
       4  ??DataTable24_23
       4  ??DataTable24_24
       4  ??DataTable24_25
       4  ??DataTable24_26
       4  ??DataTable24_27
       4  ??DataTable24_28
       4  ??DataTable24_29
       4  ??DataTable24_3
       4  ??DataTable24_30
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
     224  CheckActualCMD
     224  CheckActualCMDInv
     532  CommonMeasureLogic
     100  CompressorToActualCMD
      92  CompressorToQuadro
     108  EXElogicCOMPONENT
     120  EXElogicCOMPONENT_WL
     144  MultiBitWorkerHostQuadro
     144  MultiBitWorkerHostQuadroWL
    1980  SelectorDVdriverHi
    8344  SelectorDVdriverLow
    8360  SelectorDVdriverMidd
      52  TranslateQuadroToWideRTCmd
     412  WorkRangirCDI
     468  WorkRangirRele
      68  addCDItrig
      68  addReleTrig
     108  detectorLevelDOWN
     152  detectorLevelDOWN3F
     108  detectorLevelUP
     152  detectorLevelUP3F
     264  dvUnionMakerHi
    1028  dvUnionMakerLow
    1032  dvUnionMakerMidd
     284  elementAND
     284  elementOR
     184  elementXOR
      40  pfWorker5

 
 25 412 bytes in section Fast_function
 
 25 412 bytes of CODE memory

Errors: none
Warnings: none
