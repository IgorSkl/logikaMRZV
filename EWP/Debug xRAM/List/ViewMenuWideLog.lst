###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        15/Oct/2015  16:25:09
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\virtualMenu\ViewMenuWideLog.c
#    Command line =  
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\virtualMenu\ViewMenuWideLog.c"
#        -lcN "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug xRAM\List\" -o
#        "D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\Obj\" --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=ARM926EJ-S -e --fpu=VFP9-S --dlib_config "D:\Program Files\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\Igor\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\component\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\" --interwork
#        --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\List\ViewMenuWideLog.lst
#    Object file  =  
#        D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\Obj\ViewMenuWideLog.o
#
###############################################################################

D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\virtualMenu\ViewMenuWideLog.c
      1          /*
      2          #include <vcl.h>
      3          #include <strstrea.h>
      4          #include <math.h>
      5          #include <mem.h>
      6          #include <fstream.h>
      7          #include <strstrea.h>
      8          #include <iomanip.h>
      9          #pragma hdrstop
     10          
     11          #include "vmenuDis.h"
     12          */
     13          
     14          #include <stdio.h>
     15          #include <string.h>
     16          
     17          #include "psuperVisor\supermanager.h"
     18          
     19          #include "bazisdef.h"
     20          #include "component\componentdef.h"
     21          #include "virtualMenu\systemmenudef.h"
     22          #include "virtualMenu\rangmanagerdef.h"
     23          #include "virtualMenu\wideLogManagerdef.h"
     24          
     25          #include "virtualMenu\textstreamfnc.h"
     26          #include "virtualMenu\systemmenufnc.h"
     27          #include "virtualMenu\rangmanagerfnc.h"
     28          #include "virtualMenu\wideLogManagerfnc.h"
     29          #include "psuperVisor\psupervisor.h"
     30          #include "psuperVisor\psvisor_helpfnc.h"
     31          
     32          #include "virtualMenu\viewMenuTip.h"
     33          #include "virtualMenu\viewMenuWideLog.h"
     34          #include "virtualMenu\viewMenuSub.h"
     35          #include "virtualMenu\viewMenuCnf.h"
     36          
     37          #include "..\bazis.h"
     38          
     39          #include "toSpeedOptim.h"
     40          
     41          
     42          //номер бита для редактирования
     43          #define RANG_BIT        LIGHTMNGUOFFSET
     44          //к-во открытых команд
     45          #define RANG_CNTOPEN_CMD LIGHTMNGUBAZA
     46          //маркер клона РЛ
     47          #define MARKCLON_WL 1000
     48          
     49          extern LineMenuItem sub_menu_editwl[];
     50          extern LineMenuItem sub_menu_cntr[];
     51          extern LineMenuItem sub_menu_cnfwl[];
     52          extern LineMenuItem sub_menu_tmp[];
     53          extern LineMenuItem sub_menu_rpzWL[];
     54          
     55          extern LineMenuItem sub_menu_viewWL[];
     56          extern LineMenuItem sub_menu_logw[];
     57          extern int workerUniversal1;//данные для работника
     58          extern int workerUniversal2;//данные для работника
     59          extern IONAMESTATUS_RANGIR  nameStatusRANGIR[];
     60          extern UNS_32 ArrayWIDELOG[];
     61          extern COMPONENT_OBJ  cnfCOMPONENT[];
     62          extern COMPONENT_OBJ  cnfCOMPONENT_WL[];
     63          extern char isRangRedactor;//было ли редактировано ранжир
     64          extern int  TypLE[];
     65          extern char titleWideLog[];
     66          
     67          void SetTitleLE(int le, char *title)
     68          {
     69          //заголовок ЛЭ
     70            switch(TypLE[le])
     71            {
     72            case typeLE_DIS:
     73              strcat(title, "-ОТКЛ");
     74              break;
     75            case typeLE_OR:
     76              strcat(title, "-элемент ИЛИ");
     77              break;
     78            case typeLE_AND:
     79              strcat(title, "-элемент И");
     80              break;
     81            case typeLE_XOR:
     82              strcat(title, "-элемент ИСКЛ ИЛИ");
     83              break;
     84            default:
     85              ;
     86            }//switch
     87          }//SetTitleLE(int le, char *title)
     88          
     89          void OpenViewLE()
     90          {
     91          //открыть  лог команды LE на просмотр
     92            MngWideLogPrepareArrayWIDELOGtoEdit();//Подготовить ArrayWIDELOG к редактированию
     93          
     94          //  CRR_TEXTSTREAM = &CONTROL_EWL;//текущий control
     95            SelectorTEXTCONTROL(&CONTROL_EWL);//установить текущую ссылку на текстовый поток
     96          //  CRR_FHOME = &PereinitViewLE;//указатель на ф-цию HOME
     97            SelectorFHOME(&PereinitViewLE);//указатель на ф-цию HOME
     98          
     99          //  CRR_FHOME(1);
    100            InitFHOME(1);//переиниц
    101          }//OpenViewLE()
    102          
    103          void PereinitViewLE(short flg)
    104          {
    105          //ф-ция переинит LE
    106            TxtStreamInit(CRR_TEXTSTREAM, &KadrMenuFormat_viewLE, NULL);//инит управл структ и формир кадра
    107            //if(flg==1)
    108            ViewDiskrMenu(typeMenuSub);//вывести окно отображения
    109          
    110          }//PereinitViewLE(short flg)
    111          
    112          short  KadrMenuFormat_viewLE(void *pstr)
    113          {
    114            WorkControl *workCntr = (WorkControl *)pstr;
    115          //формирователь кадра
    116            RESET_COUNTER;//сброс счетчиков
    117            short cntKadr = 0;//к-во кадров
    118            short isEmpty = 0;
    119          
    120            UNS_32 cmnDQuadro[2*DQUADRO];//общий dquadro
    121          
    122            setComonDQuadro(cmnDQuadro);//заполнить общий dquadro
    123          
    124            workerUniversal1 = 0;//данные для работника
    125            MultiBitWorkerHostQuadroWL(
    126              cmnDQuadro, &pfWorker1);
    127            cntKadr = workerUniversal1;//к-во кадров для общий dquadro
    128          
    129            if(cntKadr==0)
    130            {
    131              isEmpty = 1;
    132              cntKadr=1;
    133            }//if
    134          
    135          
    136            for(int i=0;; i++)
    137            {
    138          //критерий терминатора
    139              if(i==cntKadr) break;
    140          
    141              COMPARE_COUNTER
    142              {
    143                if(isEmpty)
    144                {
    145                  strcpy((char *)workCntr->twoString, "ПУСТО");
    146                  return 1;
    147                }//if
    148          
    149                //имя и знак команды WL
    150                //найти индекс i-й активной команды
    151                workerUniversal2 = i;//данные для работника
    152                workerUniversal1 = 0;
    153                MultiBitWorkerHostQuadroWL(
    154                  cmnDQuadro, &pfWorker2);
    155                //имя и знак команды WL
    156                setNameIOWL(workerUniversal2, (char *)workCntr->twoString);
    157          
    158                return 1;
    159              }//COMPARE_COUNTER
    160            }//for
    161          
    162          
    163            return 1;
    164          
    165          }//KadrMenuFormat_viewLE(WorkControl *workCntr)
    166          
    167          void ClickOpenEditWL(UNS_32 *cmdLE)
    168          {
    169            /*
    170          //Получить адр ArrayWIDELOG конкр LE для редактирования
    171            short  findClon = -1; //найти клон для позиционирования
    172            //искать в cnf
    173            UNS_32 tmp=0;
    174            for(int i=0; i<3* 2*DQUADRO; i++) tmp|=cmdLE[i];
    175            UNS_32 cmdUnion[DQUADRO];
    176            memset(cmdUnion, 0, 4*DQUADRO);
    177            //соединить PRM
    178            for(int i=0; i<DQUADRO; i++) cmdUnion[i] |= cmdLE[i];
    179            //соединить MINUS
    180            for(int i=0; i<DQUADRO; i++) cmdUnion[i] |= cmdLE[i +2*DQUADRO];
    181            //соединить PLUS
    182            for(int i=0; i<DQUADRO; i++) cmdUnion[i] |= cmdLE[i +2*DQUADRO+2*DQUADRO];
    183          
    184            //посчитать к-во бит
    185            workerUniversal1 = 0;//данные для работника
    186            MultiBitWorkerHostQuadro(cmdUnion, &pfWorker1);
    187            short cntBitCnf = workerUniversal1;//к-во активных бит cnf
    188          //найти к-во клонов в cnf
    189            short cntClonCnf = 0;
    190            while (cnfCOMPONENT[cntClonCnf].componentEnable)   //все компоненты в конфигурации cnf
    191            {
    192              cntClonCnf++;
    193            }//while
    194          
    195            workerUniversal2 = TxtStreamIdxKadr(CRR_TEXTSTREAM);
    196            if(workerUniversal2<cntBitCnf)
    197            {
    198              //найти индекс i-й активной команды cnf
    199              workerUniversal1 = 0;
    200              MultiBitWorkerHostQuadro(cmdUnion, &pfWorker2);
    201          
    202          //найти клон для позиционирования cnf
    203              short next = 0;
    204              while (cnfCOMPONENT[next].componentEnable)   //все компоненты в конфигурации cnf
    205              {
    206                if(getOffsetIOCmdCnf(next)>workerUniversal2) break;
    207                next++;
    208              }//while
    209              findClon = next-1;
    210            }//if
    211            else
    212            {
    213              //искать в РЛ
    214              memset(cmdUnion, 0, 4*DQUADRO);
    215              //соединить PRM
    216              for(int i=0; i<DQUADRO; i++) cmdUnion[i] |= cmdLE[i +DQUADRO];
    217              //соединить MINUS
    218              for(int i=0; i<DQUADRO; i++) cmdUnion[i] |= cmdLE[i +2*DQUADRO +DQUADRO];
    219              //соединить PLUS
    220              for(int i=0; i<DQUADRO; i++) cmdUnion[i] |= cmdLE[i +2*DQUADRO+2*DQUADRO +DQUADRO];
    221          
    222              //посчитать к-во бит
    223              workerUniversal1 = 0;//данные для работника
    224              MultiBitWorkerHostQuadro(cmdUnion, &pfWorker1);
    225              //short cntBitWL = workerUniversal1;//к-во активных бит WL
    226              if(workerUniversal1)//к-во активных бит WL
    227              {
    228                workerUniversal2 -= cntBitCnf;//убрать биты cnf
    229                //найти индекс i-й активной команды WL
    230                workerUniversal1 = 0;
    231                MultiBitWorkerHostQuadro(cmdUnion, &pfWorker2);
    232          
    233                //найти клон для позиционирования WL
    234                short next = 0;
    235                while (cnfCOMPONENT_WL[next].componentEnable)   //все компоненты в конфигурации cnf
    236                {
    237                  if(getOffsetIOCmdCnf_WL(next)>workerUniversal2) break;
    238                  next++;
    239                }//while
    240                findClon = next-1;
    241                findClon += cntClonCnf;
    242              }//if(cntBitWL)
    243            }//else
    244          
    245          //открыть редактирование ранжир
    246            LIGHTCLON = -1;//индекс откр компонента
    247          
    248          //ф-ция переинит
    249          //  CRR_TEXTSTREAM = &CONTROL_ERNG;
    250            SelectorTEXTCONTROL(&CONTROL_ERNG);//установить текущую ссылку на текстовый поток
    251          
    252          //текущий sub_menu и будет его parent
    253            sub_menu_editwl[SUBDATA].Line2 = CRR_SUBMENU;
    254          
    255          //  CRR_SUBMENU = sub_menu_editwl;//новый текущий submenu
    256             SelectorSUBMENU(sub_menu_editwl);//уcтановить текущее субменю
    257          
    258            TxtStreamInit(CRR_TEXTSTREAM, &KadrMenuFormat_openEditWL, NULL);//инит управл структ и формир кадра
    259            if(findClon>0)
    260              TxtStreamSetIdxKadr(CRR_TEXTSTREAM, findClon);//установка номера текущего кадра
    261          
    262            ViewDiskrMenu(typeMenuEditWL);//вывести окно отображения
    263            ListPStr();//размещение указателя строки
    264          
    265            FvmenuDis->TipPanel->Visible = true;
    266            ViewTipPanel(1);//панель подсказки TipPanel
    267            */
    268          }//ClickOpenEditWL(UNS_32 *cmdLE)
    269          
    270          short  KadrMenuFormat_openEditWL(void *pstr)
    271          {
    272            WorkControl *workCntr = (WorkControl *)pstr;
    273          //формирователь кадра
    274            RESET_COUNTER;//сброс счетчиков
    275            for(int i=0;; i++)
    276            {
    277          //критерий терминатора
    278              short next = 0;
    279              short nextWL = 0;
    280              while (cnfCOMPONENT[next].componentEnable)   //все компоненты в конфигурации
    281              {
    282                next++;
    283              }//while
    284          
    285              while (cnfCOMPONENT_WL[nextWL].componentEnable)   //все компоненты в конфигурации РЛ
    286              {
    287                nextWL++;
    288              }//while
    289          
    290              if(next==0)
    291              {
    292                strcpy((char *)workCntr->twoString, "Конфигурация");
    293                strcpy((char *)workCntr->twoString + sizeof(WorkVariantChar)/2, "пустая");
    294                if(i==1)break;
    295              }//if
    296              else
    297              {
    298                if(i==(next+ nextWL)) break;
    299              }//else
    300          
    301              COMPARE_COUNTER
    302              {
    303                if(i<next)//(next!=0)&&)
    304                {
    305                  strcpy((char *)workCntr->twoString, cnfCOMPONENT[i].nameComponent);
    306                  strcpy((char *)workCntr->twoString + sizeof(WorkVariantChar)/2, "    Раздел");
    307                }//if
    308                else
    309                {
    310                  //показать разделы РЛ
    311                  strcpy((char *)workCntr->twoString, cnfCOMPONENT_WL[i-next].nameComponent);
    312                  strcpy((char *)workCntr->twoString + sizeof(WorkVariantChar)/2, "  Раздел РЛ");
    313                }
    314                return 1;//сравнить счетчики кадров
    315              }//COMPARE_COUNTER
    316            }//for
    317          
    318            return 1;
    319          }//KadrMenuFormat_openEditWL(WorkControl *workCntr)
    320          
    321          void WLRedactor(short cmdPosition)
    322          {
    323            /*
    324          //редактировать ранжирование
    325            char txtName[50];
    326            FvmenuDis->EditWLPanel->Visible = true;
    327            FvmenuDis->ConfirmRangPanel->Visible = false;
    328            //имя знак и состояние команды LE
    329            short znak = setNameIOWL(cmdPosition, txtName);//имя и знак команды WL
    330            switch(znak)
    331            {
    332            case 0:
    333              //выход
    334              FvmenuDis->PRMRadio->Checked = false;
    335              FvmenuDis->MINUSRadio->Checked = false;
    336              FvmenuDis->PLUSRadio->Checked = false;
    337              FvmenuDis->OTKLRadio->Checked = true;
    338              break;
    339            case 1:
    340              //прямой вход
    341              FvmenuDis->PRMRadio->Checked = true;
    342              FvmenuDis->MINUSRadio->Checked = false;
    343              FvmenuDis->PLUSRadio->Checked = false;
    344              FvmenuDis->OTKLRadio->Checked = false;
    345              break;
    346            case 2:
    347              //инв вход
    348              FvmenuDis->PRMRadio->Checked = false;
    349              FvmenuDis->MINUSRadio->Checked = true;
    350              FvmenuDis->PLUSRadio->Checked = false;
    351              FvmenuDis->OTKLRadio->Checked = false;
    352              break;
    353            case 3:
    354              //выход
    355              FvmenuDis->PRMRadio->Checked = false;
    356              FvmenuDis->MINUSRadio->Checked = false;
    357              FvmenuDis->PLUSRadio->Checked = true;
    358              FvmenuDis->OTKLRadio->Checked = false;
    359              break;
    360            default:
    361              ;
    362            }//switch
    363          
    364            FvmenuDis->EditWLLabel->Caption = txtName;
    365            */
    366          }//WLRedactor()
    367          
    368          void ClickProcessEditWL()
    369          {
    370          //начать редактирование РЛ
    371            int isCLONWL = 0;//флаг клона РЛ
    372          //  LIGHTLINEMENU = TxtStreamIdxKadr(CRR_TEXTSTREAM);//текущий кадр
    373            SelectorCRRLIGHTLINE();//найти подсвеченную строку текущего текст потока
    374          
    375            if( LIGHTCLON >= MARKCLON_WL)
    376            {
    377              LIGHTCLON -= MARKCLON_WL;
    378              isCLONWL = 1;//флаг клона РЛ
    379            }//if
    380          
    381            short next = 0;
    382            while (cnfCOMPONENT[next].componentEnable)   //все компоненты в конфигурации
    383            {
    384              next++;
    385            }//while
    386          
    387            short cmdPosition =0;
    388            for(short i=0; i<1; i++)
    389            {
    390          
    391              if(isCLONWL)
    392              {
    393                //клон РЛ
    394                LIGHTCLON = LIGHTCLON + next;
    395              }//if
    396          
    397              if(LIGHTCLON<0)//индекс откр компонента
    398              {
    399                //первый выбор клона
    400                LIGHTCLON = LIGHTLINEMENU;//индекс откр компонента
    401                break;
    402              }//if
    403          
    404              if(
    405                LIGHTLINEMENU <  LIGHTCLON)
    406              {
    407                //выбор до откр клона
    408                LIGHTCLON = LIGHTLINEMENU;//индекс откр компонента
    409                break;
    410              }//if
    411          
    412              if(
    413                LIGHTLINEMENU >( LIGHTCLON+ RANG_CNTOPEN_CMD-1))
    414              {
    415                //выбор после откр клона
    416                LIGHTCLON = LIGHTLINEMENU - RANG_CNTOPEN_CMD+1;
    417                break;
    418              }//if
    419          
    420              if(isCLONWL)//флаг клона РЛ
    421              {
    422                cmdPosition = //позиция выбранной команды в табл ранж
    423                  getOffsetIOCmdCnf_WL(LIGHTCLON-next) +
    424                  LIGHTLINEMENU - LIGHTCLON +SIZE_RANGIRCMD;
    425                LIGHTCLON = LIGHTCLON + MARKCLON_WL - next;//маркер клона РЛ
    426              }//if(isCLONWL)//флаг клона РЛ
    427              else
    428              {
    429                cmdPosition = //позиция выбранной команды в табл ранж
    430                  getOffsetIOCmdCnf(LIGHTCLON) +
    431                  LIGHTLINEMENU - LIGHTCLON;
    432              }//else
    433              RANG_BIT =  cmdPosition ;//позиция выбранной команды в табл ранж
    434              WLRedactor(cmdPosition);//редактировать РЛ
    435              return;
    436            }//for
    437          
    438            int numClon = LIGHTCLON;
    439            if(LIGHTCLON>=next)
    440            {
    441              //клоны РЛ
    442              RANG_CNTOPEN_CMD = cnfCOMPONENT_WL[numClon-next].cntIOCmd;//к-во открытых строк IO команд
    443              //маркер клона РЛ
    444              LIGHTCLON = MARKCLON_WL +LIGHTCLON-next;
    445            }//if
    446            else
    447              RANG_CNTOPEN_CMD = cnfCOMPONENT[LIGHTCLON].cntIOCmd;//к-во открытых строк IO команд
    448          
    449            TxtStreamInit(CRR_TEXTSTREAM, &KadrMenuFormat_prc_editWL, NULL);//инит управл структ и формир кадра
    450            TxtStreamSetIdxKadr(CRR_TEXTSTREAM, numClon);//установка номера текущего кадра
    451          
    452            ViewDiskrMenu(typeMenuEditRang);//вывести окно отображения
    453            ListPStr();//размещение указателя строки
    454          
    455          }//ClickProcessEditWL()
    456          
    457          short  KadrMenuFormat_prc_editWL(void *pstr)
    458          {
    459            WorkControl *workCntr = (WorkControl *)pstr;
    460          //формирователь кадра
    461          //процесс редактирования широкой табл ранжир
    462            //char  locTxt[20];
    463            short next = 0;
    464            short nextWL = 0;
    465            short cntKadr = 0;//к-во кадров
    466          
    467            short numCloseComp = 0;//закр компоненты
    468            while (cnfCOMPONENT[next].componentEnable)   //все компоненты в конфигурации
    469            {
    470              next++;
    471            }//while
    472          
    473            while (cnfCOMPONENT_WL[nextWL].componentEnable)   //все компоненты в конфигурации РЛ
    474            {
    475              nextWL++;
    476            }//while
    477          
    478            cntKadr = nextWL+ next+ RANG_CNTOPEN_CMD-1;//к-во кадров
    479          
    480            RESET_COUNTER;//сброс счетчиков
    481            for(int i=0;; i++)
    482            {
    483          //критерий терминатора
    484              if(i==cntKadr) break;
    485          
    486              int numClon = 0;//LIGHTCLON;
    487              if(LIGHTCLON<MARKCLON_WL) numClon = LIGHTCLON;
    488              else numClon = LIGHTCLON -MARKCLON_WL +next;
    489          
    490              COMPARE_COUNTER
    491              {
    492                if(i<  numClon)
    493                  numCloseComp = i;
    494                if(i>( numClon   + RANG_CNTOPEN_CMD -1))
    495                  numCloseComp = i- RANG_CNTOPEN_CMD+1;
    496                if(i<  numClon || i>( numClon + RANG_CNTOPEN_CMD-1))
    497                {
    498                  if(numCloseComp>=next)
    499                  {
    500                    //Разделы РЛ
    501                    strcpy((char *)workCntr->twoString, cnfCOMPONENT_WL[numCloseComp-next].nameComponent);
    502                    strcpy((char *)workCntr->twoString + sizeof(WorkVariantChar)/2, "  Раздел РЛ");
    503                  }
    504                  else
    505                  {
    506                    strcpy((char *)workCntr->twoString, cnfCOMPONENT[numCloseComp].nameComponent);
    507                    strcpy((char *)workCntr->twoString + sizeof(WorkVariantChar)/2, "    Раздел");
    508                  }
    509                }//if(i<  LIGHTCLON || i>(LIGHTCLON + RANG_CNTOPEN_CMD-1))
    510                else{
    511                  short cmdPosition  = 0;//позиция выбранной команды в табл ранж
    512                  if(LIGHTCLON<MARKCLON_WL)
    513                  {
    514                    //команды клона из конфиг
    515                    cmdPosition  = i- LIGHTCLON + getOffsetIOCmdCnf(numClon);
    516                  }//if(LIGHTCLON<MARKCLON_WL)
    517                  else{
    518                    //команды клона из РЛ
    519                    cmdPosition  = i+ SIZE_RANGIRCMD -numClon + getOffsetIOCmdCnf_WL(numClon-next);
    520                  }//else
    521          
    522                  if(setNameIOWL(cmdPosition, (char *)workCntr->twoString))//имя и знак команды WL
    523                  {
    524                    strcpy((char *)workCntr->twoString + sizeof(WorkVariantChar)/2, "    Вкл");
    525                  }//if
    526                  else
    527                  {
    528                    strcpy((char *)workCntr->twoString + sizeof(WorkVariantChar)/2, "    Откл");
    529                  }
    530          
    531                }//else
    532          
    533                return 1;
    534              }//COMPARE_COUNTER
    535          
    536          
    537            }//for
    538          
    539            return 1;
    540          }//KadrMenuFormat_prc_editWL(WorkControl *workCntr)
    541          
    542          void setComonDQuadro(UNS_32* cmnDQuadro)
    543          {
    544          //заполнить общий dquadro
    545            UNS_32 *tmp1 = MngWLGetLEWLtoEdit_PRM(LIGHTRANGUVV);
    546            memset(cmnDQuadro, 0, DQUADRO*4*2);//обнулить
    547            //общий dquadro для прямых инверс и плюсовых
    548            for(int i=0; i<2*DQUADRO; i++) cmnDQuadro[i] |= (tmp1[i]|tmp1[i+DQUADRO*2]|tmp1[i+DQUADRO*2+DQUADRO*2]);
    549          }//setComonDQuadro(UNS_32* cmnDQuadro)
    550          
    551          short setNameIOWL(int cmdPosition, char *strIO)
    552          {
    553          //имя и знак команды WL
    554            //имя команды
    555            char tmpName[50];
    556            strcpy(tmpName,
    557                   nameStatusRANGIR[
    558                     cmdPosition
    559                   ].nameIORang
    560                  );
    561          
    562            strcpy(strIO, "");
    563            //знак команды LE
    564            short znak=SetConditionCmdPositionLE(cmdPosition);
    565            if(znak==2)strcpy(strIO, "- ");
    566            if(znak==3)strcpy(strIO, "+ ");
    567            strcat(strIO, tmpName);//дополнить знак именем
    568            return znak;
    569          }//setNameIOWL(int cmdPosition, char *strIO)
    570          
    571          short SetConditionCmdPositionLE(short cmdPosition)
    572          {
    573            //знак команды LE
    574            UNS_32*tmp1 =  MngWLGetLEWLtoEdit_PRM(LIGHTRANGUVV);//массив LE
    575            short znak=0;
    576            //найти знак команды
    577            //найти плюс
    578            if(NumBitCheckWL(cmdPosition, &(tmp1[DQUADRO*2+DQUADRO*2])))
    579            {
    580              //есть плюс
    581              znak = 3;//знак команды
    582            }//if
    583          
    584            //найти минус
    585            if(NumBitCheckWL(cmdPosition, &(tmp1[DQUADRO*2])))
    586            {
    587              //есть минус
    588              znak = 2;//знак команды
    589            }//if
    590          
    591            if(NumBitCheckWL(cmdPosition, tmp1))
    592            {
    593              //есть prm
    594              znak = 1;//знак команды
    595            }//if
    596          
    597            return znak;//знак команды
    598          }//SetConditionCmdPositionLE(cmdPosition)
    599          
    600          void  ClickEditWLOKButton()
    601          {
    602            /*
    603          //редактировать РЛ
    604          //установить команду на LE
    605          //  UNS_32 *prm =  MngWLGetLEWLtoEdit_PRM(LIGHTRANGUVV);//массив LE
    606          //MngWLGetPointerLEWLtoEdit_PRM(LIGHTRANGUVV);//массив LE
    607            if(FvmenuDis->PRMRadio->Checked)
    608              SetLEToClon(RANG_BIT, LIGHTRANGUVV, typeCmd_PRM);
    609            if(FvmenuDis->PLUSRadio->Checked)
    610              SetLEToClon(RANG_BIT, LIGHTRANGUVV, typeCmd_PLUS);
    611            if(FvmenuDis->MINUSRadio->Checked)
    612              SetLEToClon(RANG_BIT, LIGHTRANGUVV, typeCmd_MINUS);
    613            if(FvmenuDis->OTKLRadio->Checked)
    614              SetLEToClon(RANG_BIT, LIGHTRANGUVV, typeCmd_DIS);
    615          
    616            isRangRedactor = 2;//было ли редактировано РЛ
    617          
    618            ViewTipPanel(1);
    619            */
    620          }//ClickEditRangOKButton()
    621          
    622          void  FinishEditWL(int isOK)
    623          {
    624          //сохранить и завершить редактир РЛ
    625            isRangRedactor = 0;//было ли редактировано ранжир
    626            if(isOK)
    627              MngWLEndingEditArrayWIDELOG();//Сохр изменения в массиве ранжир
    628            MngWideLogPrepareArrayWIDELOGtoEdit();//Подготовить ArrayWIDELOG к редактированию
    629            TxtStreamInit(&CONTROL_EWL, &KadrMenuFormat_viewLE, NULL);//новое к-во команд на LE
    630          }//FinishEditRang()
    631          
    632          void PereinitCnfWL(short flg)
    633          {
    634          //переинит конфигурации РЛ
    635            TxtStreamInit(&CONTROL_CNFWL,
    636                          &KadrMenuFormat_sub, sub_menu_cnfwl);//инит control и формир кадра
    637          
    638            PNTCRR_TEXTSTREAM->PntStringViewer = 0;
    639            if(flg==0)//END
    640            {
    641              TxtStreamSetEnd(&CONTROL_CNFWL, SIZE_PAGE_VIEW);//перейти на END
    642            }//if
    643            ViewDiskrMenu(typeMenuSub);//вывести окно отображения
    644            LanderPStr();//размещение указателя строки
    645          }//PereinitCnfWL()
    646          
    647          void OpenMenuCnfWL()
    648          {
    649          //открыть меню cnf РЛ
    650            TxtStreamCorrect(CRR_TEXTSTREAM);//коррекция текущий control
    651          
    652          //  CRR_TEXTSTREAM = &CONTROL_CNFWL;//новый текущий control
    653            SelectorTEXTCONTROL(&CONTROL_CNFWL);//установить текущую ссылку на текстовый поток
    654            PereinitCnfWL(1);//ф-ция переинит конфигурации
    655          //  CRR_FHOME = &PereinitCnfWL;//указатель на ф-цию HOME
    656            SelectorFHOME(&PereinitCnfWL);//указатель на ф-цию HOME
    657          }//OpenMenuCnf()
    658          
    659          void  ConfigMakerWL()
    660          {
    661            /*
    662          //заполнить конфигурацию
    663          //  LIGHTLINEMENU = TxtStreamIdxKadr(CRR_TEXTSTREAM);//индекс тек кадра
    664            SelectorCRRLIGHTLINE();//найти подсвеченную строку текущего текст потока
    665            short numK = GetKodCompRpzWL(LIGHTLINEMENU);//получить из номера строки репозитария РЛ код компонента
    666          
    667            sub_menu_tmp[SUBDATA].Line2 = &sub_menu_cnfwl;// parent
    668          //  CRR_SUBMENU = sub_menu_tmp;//текущее субменю
    669            SelectorSUBMENU(sub_menu_tmp);//уcтановить текущее субменю
    670          
    671            AddCompIzRpz_WL(numK);//добавить компонент из репозитария в РЛ
    672          
    673            FvmenuDis->Str1Label->Caption = "Компонент";
    674            FvmenuDis->Str2Label->Caption = (char *)sub_menu_cnfwl[1+SUBDATA].Line1;
    675            FvmenuDis->Str3Label->Caption = "добавлен";
    676            FvmenuDis->Str4Label->Caption = "";
    677          
    678            ResetAllButton();//погасить все клавиши
    679          */
    680          }//ConfigMaker()
    681          
    682          short GetKodCompRpzWL(short numL)
    683          {
    684          //получить из номера строки репозитария код компонента
    685            char ltxt[50];
    686            strcpy(ltxt, (char *)sub_menu_rpzWL[numL+1+SUBDATA].Line1);
    687            //мл и ст части кода компонента
    688            char lowK = ((char *)(sub_menu_rpzWL[numL+1+SUBDATA].Line1))[-2];
    689            char hiK = ((char *)(sub_menu_rpzWL[numL+1+SUBDATA].Line1))[-1];
    690            return lowK + 256*hiK;
    691          }//GetKodCompRpzWL(short numL)
    692          
    693          void  AddCompIzRpz_WL(short numK)
    694          {
    695          //добавить компонент из репозитария в РЛ
    696            addCOMPONENT_WL(numK);//Добавить компонент с кодом numK в конфигурацию РЛ
    697          
    698            if( LIGHTISDENIE ||//запрещено
    699                LIGHTISPACKET);//это пакет
    700            else
    701            {
    702          //инициализировать клон компонента РЛ
    703          //если не пакет
    704              initCOMPONENT_WL(INITUST_TOPCOMP);
    705              MakeEmptyTopSub_menu(sub_menu_cnfwl,
    706                                   MAX_WLCOMPONENT*sizeof(LineMenuItem));//добавить пустую запись в top sub_menu
    707          //новый клон в список
    708              sub_menu_cnfwl[1+SUBDATA].Line2 = (void *)&OpenMenuComponent_WL; //меню компонента
    709              sub_menu_cnfwl[1+SUBDATA].TypesWin = typeMenuProg;
    710            }//else
    711          
    712            PrepareAllCnfComponent_WL();//подготовить все компоненты в конфигурации РЛ
    713          }//AddCompIzRpz_WL()
    714          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AddCompIzRpz_WL
         8   -> MakeEmptyTopSub_menu
         8   -> PrepareAllCnfComponent_WL
         8   -> addCOMPONENT_WL
         8   -> initCOMPONENT_WL
       0   ClickEditWLOKButton
       0   ClickOpenEditWL
      24   ClickProcessEditWL
        24   -> ListPStr
        24   -> SelectorCRRLIGHTLINE
        24   -> TxtStreamInit
        24   -> TxtStreamSetIdxKadr
        24   -> ViewDiskrMenu
        24   -> WLRedactor
        24   -> getOffsetIOCmdCnf
        24   -> getOffsetIOCmdCnf_WL
       0   ConfigMakerWL
       8   FinishEditWL
         8   -> MngWLEndingEditArrayWIDELOG
         8   -> MngWideLogPrepareArrayWIDELOGtoEdit
         8   -> TxtStreamInit
      64   GetKodCompRpzWL
        64   -> strcpy
      24   KadrMenuFormat_openEditWL
        24   -> strcpy
      40   KadrMenuFormat_prc_editWL
        40   -> getOffsetIOCmdCnf
        40   -> getOffsetIOCmdCnf_WL
        40   -> setNameIOWL
        40   -> strcpy
     104   KadrMenuFormat_viewLE
       104   -> MultiBitWorkerHostQuadroWL
       104   -> setComonDQuadro
       104   -> setNameIOWL
       104   -> strcpy
       8   OpenMenuCnfWL
         8   -> PereinitCnfWL
         8   -> SelectorFHOME
         8   -> SelectorTEXTCONTROL
         8   -> TxtStreamCorrect
       8   OpenViewLE
         8   -> InitFHOME
         8   -> MngWideLogPrepareArrayWIDELOGtoEdit
         8   -> SelectorFHOME
         8   -> SelectorTEXTCONTROL
       8   PereinitCnfWL
         8   -> LanderPStr
         8   -> TxtStreamInit
         8   -> TxtStreamSetEnd
         8   -> ViewDiskrMenu
       8   PereinitViewLE
         8   -> TxtStreamInit
         8   -> ViewDiskrMenu
      16   SetConditionCmdPositionLE
        16   -> MngWLGetLEWLtoEdit_PRM
        16   -> NumBitCheckWL
      16   SetTitleLE
        16   -> strcat
       0   WLRedactor
      24   setComonDQuadro
        24   -> MngWLGetLEWLtoEdit_PRM
        24   -> __aeabi_memset
      72   setNameIOWL
        72   -> SetConditionCmdPositionLE
        72   -> strcat
        72   -> strcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_17
       4  ??DataTable14_18
       4  ??DataTable14_19
       4  ??DataTable14_2
       4  ??DataTable14_20
       4  ??DataTable14_21
       4  ??DataTable14_22
       4  ??DataTable14_23
       4  ??DataTable14_24
       4  ??DataTable14_25
       4  ??DataTable14_26
       4  ??DataTable14_27
       4  ??DataTable14_28
       4  ??DataTable14_29
       4  ??DataTable14_3
       4  ??DataTable14_30
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       8  ?_0
      16  ?_1
      12  ?_10
       1  ?_11
       4  ?_12
       4  ?_13
      12  ?_2
      20  ?_3
       8  ?_4
      16  ?_5
       8  ?_6
      12  ?_7
      12  ?_8
       8  ?_9
     108  AddCompIzRpz_WL
       4  ClickEditWLOKButton
       4  ClickOpenEditWL
     664  ClickProcessEditWL
       4  ConfigMakerWL
      56  FinishEditWL
     144  GetKodCompRpzWL
     384  KadrMenuFormat_openEditWL
     700  KadrMenuFormat_prc_editWL
     288  KadrMenuFormat_viewLE
      44  OpenMenuCnfWL
      36  OpenViewLE
      88  PereinitCnfWL
      40  PereinitViewLE
     152  SetConditionCmdPositionLE
     108  SetTitleLE
       4  WLRedactor
     132  setComonDQuadro
     168  setNameIOWL

 
   141 bytes in section .rodata
 3 252 bytes in section .text
 
 3 252 bytes of CODE  memory
   141 bytes of CONST memory

Errors: none
Warnings: none
