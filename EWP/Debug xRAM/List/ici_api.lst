###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        15/Oct/2015  14:33:14
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\ici\ici_api.c
#    Command line =  
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\ici\ici_api.c" -lcN "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug xRAM\List\"
#        -o "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug xRAM\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "D:\Program Files\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\Igor\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\component\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\" --interwork
#        --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\List\ici_api.lst
#    Object file  =  
#        D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\Obj\ici_api.o
#
###############################################################################

D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\ici\ici_api.c
      1          /*------------------------------------------------------------------------------
      2          * Copyright (c) 2013 - Factory “KyivPrylad”
      3          * 
      4          * Permission to use, copy, modify, and distribute this software for any
      5          * purpose with or without fee is hereby granted, provided that the above
      6          * copyright notice and this permission notice appear in all copies.
      7          * 
      8          * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
      9          * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
     10          * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
     11          * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
     12          * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
     13          * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
     14          * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
     15          * 
     16          *------------------------------------------------------------------------------
     17          *
     18          * Processor       : Lpc_3240
     19          * File Name       : ici_api.c
     20          * Description     : Functions and Data for API,
     21                              interprocessor communication
     22          
     23          *  Version        : 1.00
     24          *
     25          *       +----- (NEW | MODify | ADD | DELete)
     26          *       |
     27          *  No   |   When       Who                What
     28          *-----+---+----------+------------------+--------------------------------------
     29          * 000  NEW  13/08/13   Markovsky A       Creation
     30          *----------------------------------------------------------------------------*/
     31          #include "ici_api.h"
     32          #include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_timer_driver.h"
     33          #include    "lpu.h"
     34          #include    "./inc/header.h"
     35          extern long outU3(unsigned char*dat, int bytes);
     36          extern long outU7(unsigned char*dat, int bytes);
     37          
     38          extern int txfill, txsize, txget;
     39          extern int rxsize, rxget,  rxfill;
     40          extern int hs2_txsize, hs2_rxsize;
     41          
     42          
     43          unsigned char chEntry_Ssp0 = 0;
     44          unsigned char chNeedLookStatusSsp0 = 0;
     45          
     46          unsigned char chEntry_Hs7 = 0;
     47          unsigned char chHdwErorHSU7 = 0;
     48          unsigned char chEntry_Hs1 = 0;
     49          unsigned char chHdwErorHSU1 = 0;
     50          unsigned char chEntry_Hs2 = 0;
     51          unsigned char chHdwErorHSU2 = 0;
     52          unsigned char chEOI_Hs2 = 0;
     53          unsigned char chMemCY7  = 0;
     54          
     55          unsigned long lTmrActivityRvCY7 = BR_TMR_ACTIVITY_RV_CY7_VAL;
     56          unsigned long lTmrActivityTrCY7 = BR_TMR_ACTIVITY_TR_CY7_VAL;
     57          unsigned long lTmrActivitySpi = 0x10000;
     58          
     59          
     60          extern int hs7_txsize,hs7_txfill,hs7_txget;
     61          extern int hs7_rxsize,hs7_rxget, hs7_rxfill;
     62          
     63          extern long lTmrDisableHSU2, lTmrHSU2Val;
     64          extern  long lDeltaTmrHSU2;
     65          
     66          extern long timer0dev;
     67          
     68          
     69          
     70          //...long outU7(UNS_8 *dat, int bytes);
     71          char testbuff [512];
     72          char *DemoStr =  "Hello world";
     73          __TOTAL_MEASUREMENT total_measurement;
     74          unsigned int volatile command_to_receive_current_data = 0;
     75          int current_data_transmit[NUMBER_CANALS*NUMBER_POINT*NUMBER_PERIOD_TRANSMIT]; 
     76          int current_data[(NUMBER_CANALS + 1)*NUMBER_POINT*NUMBER_PERIOD];
     77          
     78          
     79          void Scan_Ici_Event_Req(void);
     80          void Scan_Ici_Entry_Data(void);
     81          
     82          unsigned long samples_data_rdy;
     83          
     84          unsigned char meas_data_rdy;
     85          
     86          long Samples_Ready_Handler(void* pv);
     87          
     88          
     89          long Meas_Ready_Handler   (void* pv);
     90          extern long lMaxTimeTransmit ;
     91          static long IciCopy_samples_data_rdy;
     92          long Samples_Ready_Handler(void* pv)  @ "Fast_function"
     93          {
     94          register long i=0;unsigned long uVl;
     95          register long j;
     96          	if (samples_data_rdy & 0x20000)
     97          	{
     98          		samples_data_rdy = 0;
     99          		//i = outU3((unsigned char*)DemoStr, 11);
    100          		//i = outU7((unsigned char*)DemoStr, 2);
    101          		//---ActivateProxyTotMeas();
    102          		//TestSetup_SrcSamples_ForTransmit();//
    103          		j = PassPrtTblPrMngRvMsgOrigin();
    104          		//..TestSetup_LpduHSU7_ForTransmit();
    105          		//..ProcessTransmitLpduHSU7();
    106          		//~.AppReqTransmitApcs++;
    107          	}	
    108          	//PrepDecompouseSrcSamplesUnit();- Move to Another function
    109          	if( IciCopy_samples_data_rdy!=samples_data_rdy )
    110          	{
    111          		lTmrDisableHSU2 ++;
    112          		IciCopy_samples_data_rdy = samples_data_rdy;
    113          		if (hldrHSU2LpduTRUnit.uchLpuHSU2State)
    114          		{
    115          			//Timer Halt - Need Reinit Timer System
    116          			if(lTmrDisableHSU2 >= 4)//if(lTmrDisableHSU2>lDelta)
    117          			{
    118          				hldrHSU2LpduTRUnit.uchLpuHSU2State = 0;lMaxTimeTransmit = 0;//goto TstLab;
    119          				RstTmr0();
    120          				lTmrDisableHSU2 = 0;		
    121          			}
    122          			
    123          		}
    124          		else lTmrDisableHSU2--;
    125          		//TestSetup_SrcSamples_ForTransmit();//Activate Transmit Samples
    126          		//.uVl = ((TIMER_CNTR_REGS_T *)TIMER_CNTR0)-> tc;
    127          		//.if (uVl>=lMaxTimeTransmit)
    128          		//.{
    129          		//.i = uVl- (unsigned long)lMaxTimeTransmit;
    130          		//.	if (i<0x10000)
    131          		//.	i++;
    132          		//.}
    133          		//.else
    134          		//.{
    135          		//.	i = (-1) - (unsigned long)lMaxTimeTransmit; <- THIS IS FOR TEST ONLY TOO BUT IS WORKED
    136          		//.	i += uVl;
    137          		//.	i = ~i;
    138          		//.}
    139          		//.lMaxTimeTransmit = (long) uVl;
    140          		//.	
    141          		
    142          	}
    143          	//.uVl = ((TIMER_CNTR_REGS_T *)TIMER_CNTR0)-> tc;
    144          	//.
    145          	//.	if (uVl>=lMaxTimeTransmit)
    146          	//.	{
    147          	//.	i = uVl- (unsigned long)lMaxTimeTransmit;
    148          	//.		if (i<0x10000)
    149          	//.		i++;
    150          	//.	}
    151          	//.	else
    152          	//.	{
    153          	//.		i = (-1) - (unsigned long)lMaxTimeTransmit; <- THIS IS FOR TEST ONLY 
    154          	//.		i += uVl;
    155          	//.		i = ~i;
    156          	//.	}
    157          	//.	lMaxTimeTransmit = (long) uVl;
    158          	//.	//Timer_delay_cmn(TIMER_CNTR0,10)	;
    159          	
    160          	//TimeOut for HSU2
    161          	/*
    162          	j = lTmrHSU2Val;//for Exlude die in interrupt
    163          	uVl = ((TIMER_CNTR_REGS_T *)TIMER_CNTR0)-> tc;
    164          	if (uVl>= j)//lTmrHSU2Val
    165          	i = uVl- (unsigned long)j;//lTmrHSU2Val;
    166          	else
    167          	{
    168          		if(((long)uVl)>0)//Move from Zero
    169          		{
    170          			if (j<0)//lTmrHSU2Val
    171          			{
    172          				i = (-1)*j;//lTmrHSU2Val;
    173          				i +=uVl;
    174          			}
    175          			else goto Err;
    176          		}
    177          		else
    178          		{
    179          Err:			i = 0;//error Variables
    180          
    181          		}
    182          		//i = (-1) - (unsigned long)lTmrHSU2Val;
    183          		//i += uVl;
    184          		//i = ~i;
    185          		
    186          	}
    187          	
    188          	if (hldrHSU2LpduTRUnit.uchLpuHSU2State)//&&(hs2_txsize==0)
    189          	{
    190          		
    191          		if(hs2_txsize)
    192          		lTmrHSU2Val = uVl;//Reset counter
    193          		else
    194          		{
    195          			if (i>lDeltaTmrHSU2*3)
    196          			i++;//Detect distance
    197          			if( (i>lDeltaTmrHSU2)&&lMaxTimeTransmit)
    198          			{
    199          				if (hs2_txsize==0)//You can insert in this place additonal vars for ctrl end Transmit 
    200          				{
    201          				hldrHSU2LpduTRUnit.uchLpuHSU2State = 0;lMaxTimeTransmit = 0;
    202          				}
    203          			}
    204          		}
    205          	
    206          	}
    207          	else
    208          	{
    209          		;//Always hold distance
    210          		
    211          		//if (i>=1000)//Time out more 1Ms
    212          		{
    213          			lTmrHSU2Val = uVl;
    214          		}
    215          	}
    216          	*/
    217          	if (hldrHSU2LpduTRUnit.uchLpuHSU2State)//&&(hs2_txsize==0)
    218          	{
    219          TstLab:		
    220          		if(hs2_txsize)
    221          		;//Reset counter
    222          		else
    223          		{
    224          			//Control State HSU2
    225          			if( chEOI_Hs2)
    226          			{
    227          				if(IsEOI_HS2())
    228          				chEOI_Hs2 = 0;
    229          			}
    230          			pv = (void*)TIMER_CNTR0;j = ((TIMER_CNTR_REGS_T *)pv)->ir;j&= TIMER_CNTR_MTCH_BIT(0);//(( ((TIMER_CNTR_REGS_T *)pv)->ir & TIMER_CNTR_MTCH_BIT(0)) != 0 )
    231          			if(j==0)
    232          			{
    233          				 uVl = ((TIMER_CNTR_REGS_T *)pv)->tc;
    234          				 if (uVl >= 0x1f4)
    235          				 while(1);
    236          			
    237          			}
    238          			if(  j &&lMaxTimeTransmit)
    239          			{
    240          				if (hs2_txsize==0)//You can insert in this place additonal vars for ctrl end Transmit 
    241          				{
    242          					hldrHSU2LpduTRUnit.uchLpuHSU2State = 0;lMaxTimeTransmit = 0;((TIMER_CNTR_REGS_T *)pv)->tcr = TIMER_CNTR_TCR_RESET;
    243          					//Clear timer
    244          					//-* Stop timer *-/
    245          					((TIMER_CNTR_REGS_T *)pv)->tcr = 0;
    246          					((TIMER_CNTR_REGS_T *)pv)->tc  = 0;
    247          					//-* Clear and enable match function *-/
    248          					((TIMER_CNTR_REGS_T *)pv)->ir = TIMER_CNTR_MTCH_BIT(0);((TIMER_CNTR_REGS_T *)pv)->tcr = TIMER_CNTR_TCR_RESET;
    249          					//TIMER_CNTR_TCR_RESET;
    250          				}
    251          			}
    252          		}
    253          	
    254          	}
    255          return 0;
    256          }
    257          
    258          
    259          long Meas_Ready_Handler   (void* pv)
    260          {
    261          
    262          return 0;
    263          }
    264          
    265          void Scan_Ici_Entry_Data(void)  @ "Fast_function"
    266          {
    267          register long i;
    268          //Detect Input Data on HSUART7
    269          	if (chEntry_Hs7)
    270          	{
    271          		//i = inU7(testbuff,11);
    272          		chEntry_Hs7 = 0;
    273          		ProcessReceiveLpduHSU7();
    274          		
    275          	}
    276          //Detect Input Data on HSUART2
    277          	if (chEntry_Hs2)
    278          	{
    279          		//i = inU7(testbuff,11);
    280          		chEntry_Hs2 = 0;
    281          		
    282          		ProcessReceiveLpduHSU2();
    283          		
    284          	}
    285          	if(chHSU2SendHdwEror)
    286          	{
    287          		RecoverHSU2();
    288          	}
    289          //Detect Input Data on HSUART1
    290          
    291          //Detect Input Data on UART3
    292          
    293          //Detect Input Data on SPI
    294          	if(chEntry_Ssp0 >=2)
    295          	{
    296          		//if(ch)
    297          		//ProcessReceiveLpduSsp0();
    298          		//....StubForSpiChanel1();
    299          		ProcessReceiveLpduSpi();if(chEntry_Ssp0!=2) for(;;);
    300          		chEntry_Ssp0 -=2;
    301          		hldrSpiLpduTRUnit.uchLpuSpiState = 0;//Clear Blocking Write to Spi Queue
    302          		
    303          	}
    304          
    305          //Detect Input Data on Mem
    306          	//Look change Mem
    307          	//~~~DetectorActivityV1();
    308          	/*
    309          	if(lTmrActivityRvCY7)
    310          	lTmrActivityRvCY7--;
    311          	else
    312          	{
    313          		i = DetectorActivity();
    314          		if(i )	//collission Detected
    315          		{
    316          			if(i==(-1))//Read OK
    317          			lTmrActivityRvCY7 =  BR_TMR_ACTIVITY_RV_CY7_VAL;
    318          			else
    319          			lTmrActivityRvCY7 =  BR_TMR_ACTIVITY_RV_CY7_VAL + 37;
    320          		}
    321          		else 
    322          		lTmrActivityRvCY7 =  BR_TMR_ACTIVITY_RV_CY7_VAL;//Not posibility to change interval
    323          	}*/
    324          	
    325          	if(lTmrActivitySpi)
    326          	lTmrActivitySpi--;
    327          	else
    328          	{
    329          		lTmrActivitySpi = 0x10000;
    330          		if (AppReqTransmitApcs > 3 || AppReqTransmitApcs == 0)//TERM)
    331          		{
    332          			AppReqTransmitApcs = 1;//START;//Fatal Error Situation
    333          			AppReqTransmitGoosA = 1;
    334          		}	
    335          		//else AppReqTransmitApcs = 1;//START;//AppReqTransmitApcs++;//Activate Transmittion
    336          	}
    337          	if(chMemCY7)
    338          	{
    339          		//ProcessReceiveLpduCY7();chMemCY7 = 0;
    340          		ProcessReceiveLpduCY7V1();chMemCY7 = 0;
    341          	}
    342          
    343          	ProcessReceiveEvt();
    344          	UpdateAppData();
    345          
    346          }
    347          void Scan_Ici_Event_Req(void)  @ "Fast_function"
    348          {
    349          	if(samples_data_rdy)
    350              {
    351                //Handle  instant samplas values Ready 
    352                Samples_Ready_Handler((void*)0);
    353              }
    354              if(meas_data_rdy)
    355              {
    356                //Handle Measuring system data Ready
    357                Meas_Ready_Handler((void*)0);
    358              }
    359          	ScanAppReq();
    360          	//Transmit Data
    361          	ProcessTransmitEvt();
    362          //.	if(lTmrActivityTrCY7)//Test only
    363          //.	lTmrActivityTrCY7--; //Test only
    364          //.	else                 //Test only
    365          //.	{ 
    366          //.		CY7_send_cb();       //Test only
    367          //.		lTmrActivityTrCY7 = 12;
    368          //.	}
    369          	ExecProxy();
    370          //Activate Hdw connect SPI	
    371          	if((lSsp0HdwState&4) == 0)
    372          	{
    373          		Ssp_Syncro4();//Ssp_Syncro3();//Ssp_Syncro1();
    374          		//StubForSpiChanel();
    375          	}
    376          
    377          //Fix Result Hdw Test SPI
    378          	if((lSsp0HdwState&0x4) == 4)
    379          	{
    380          		StubForSpiChanel();	
    381          	}	
    382          }
    383          
    384          
    385          void ScanAppReq(void)
    386          {
    387          
    388          
    389          }
    390          
    391          
    392          
    393          
    394          
    395          
    396          
    397          
    398          
    399          
    400          
    401          extern int spi1_rxsize;
    402          void StubForSpiChanel(void)
    403          {
    404          register long i;
    405          
    406          char ArTstData[600];
    407          for( i = 0; i<560; i++)
    408          ArTstData[i] = i+1;
    409          //return; if i comment numbers change to ???
    410          if (lSsp0HdwState & 4) 
    411          {
    412          return;
    413          }
    414          else
    415          {
    416          	//while(1)
    417          	{
    418          		OutSPIDma(ArTstData,512);
    419          		return;
    420          	}
    421          }
    422          //while(1)
    423          i=  outSPI1(ArTstData, 512);//300
    424          
    425          ArTstData[550] = 20;
    426          i = 0;
    427          while (spi1_rxsize <= 511)
    428          i++;i*=10;
    429          while(i--);
    430          i = inSPI1(ArTstData, 512);
    431          ArTstData[550] = 30;
    432          }
    433          void StubForSpiChanel1(void)
    434          {
    435          register long i;
    436          /*
    437          static char arCh[200] = {
    438          0x41,0x42,0x42,0x43,0x44,0x45,0x42,0x42,0x43,0x43,//0x45,0x45,0x45,0x45,
    439          0x41,0x42,0x42,0x43,0x44,0x45,0x42,0x42,0x43,0x43, //0x45,0x45,0x45,0x45,
    440          0x41,0x42,0x42,0x43,0x44,0x45,0x42,0x42,0x43,0x43,//0x45,0x45,0x45,0x45,
    441          0x41,0x42,0x42,0x43,0x44,0x45,0x42,0x42,0x43,0x43, //0x45,0x45,0x45,0x45,
    442          0x41,0x42,0x42,0x43,0x44,0x45,0x42,0x42,0x43,0x43,//0x45,0x45,0x45,0x45,
    443          0x41,0x42,0x42,0x43,0x44,0x45,0x42,0x42,0x43,0x43, //0x45,0x45,0x45,0x45,
    444          0x41,0x42,0x42,0x43,0x44,0x45,0x42,0x42,0x43,0x43,//0x45,0x45,0x45,0x45,
    445          0x41,0x42,0x42,0x43,0x44,0x45,0x42,0x42,0x43,0x43, //0x45,0x45,0x45,0x45,
    446          0x41,0x42,0x42,0x43,0x44,0x45,0x42,0x42,0x43,0x43,//0x45,0x45,0x45,0x45,
    447          0x41,0x42,0x42,0x43,0x44,0x45,0x42,0x42,0x43,0x43, //0x45,0x45,0x45,0x45,
    448          
    449          0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,//0x45,0x45,0x45,0x45,
    450          0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45, //0x45,0x45,0x45,0x45,
    451          0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,//0x45,0x45,0x45,0x45,
    452          0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45, //0x45,0x45,0x45,0x45,
    453          0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,//0x45,0x45,0x45,0x45,
    454          0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45, //0x45,0x45,0x45,0x45,
    455          0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,//0x45,0x45,0x45,0x45,
    456          0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45, //0x45,0x45,0x45,0x45,
    457          0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,//0x45,0x45,0x45,0x45,
    458          0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45 //0x45,0x45,0x45,0x45,
    459          
    460          };*/
    461          
    462          char ArTstData[600];
    463          i = inSPI1(ArTstData, 512);
    464          ArTstData[550] = 30;
    465          
    466          
    467          for( i = 0; i<560; i++)
    468          ArTstData[i] = i+1;
    469          
    470          i=  outSPI1(ArTstData, 512);//300
    471          
    472          ArTstData[550] = 20;
    473          i = 0;
    474          while (spi1_rxsize <= 511)
    475          i++;i*=10;
    476          while(i--);
    477          
    478          }
    479          
    480          
    481          
    482          
    483          
    484          /* EOF */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Meas_Ready_Handler
      24   Samples_Ready_Handler
        24   -> IsEOI_HS2
        24   -> PassPrtTblPrMngRvMsgOrigin
        24   -> RstTmr0
       0   ScanAppReq
       8   Scan_Ici_Entry_Data
         8   -> ProcessReceiveEvt
         8   -> ProcessReceiveLpduCY7V1
         8   -> ProcessReceiveLpduHSU2
         8   -> ProcessReceiveLpduHSU7
         8   -> ProcessReceiveLpduSpi
         8   -> RecoverHSU2
         8   -> UpdateAppData
       8   Scan_Ici_Event_Req
         8   -> ExecProxy
         8   -> Meas_Ready_Handler
         8   -> ProcessTransmitEvt
         8   -> Samples_Ready_Handler
         8   -> ScanAppReq
         8   -> Ssp_Syncro4
         8   -> StubForSpiChanel
     608   StubForSpiChanel
       608   -> OutSPIDma
     608   StubForSpiChanel1
       608   -> inSPI1
       608   -> outSPI1


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_14
       4  ??DataTable2_15
       4  ??DataTable2_16
       4  ??DataTable2_17
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
      12  ?_0
       4  DemoStr
       4  IciCopy_samples_data_rdy
      12  Meas_Ready_Handler
     440  Samples_Ready_Handler
       4  ScanAppReq
     312  Scan_Ici_Entry_Data
     108  Scan_Ici_Event_Req
      84  StubForSpiChanel
     160  StubForSpiChanel1
       1  chEOI_Hs2
       1  chEntry_Hs1
       1  chEntry_Hs2
       1  chEntry_Hs7
       1  chEntry_Ssp0
       1  chHdwErorHSU1
       1  chHdwErorHSU2
       1  chHdwErorHSU7
       1  chMemCY7
       1  chNeedLookStatusSsp0
       4  command_to_receive_current_data
   96000  current_data
   17600  current_data_transmit
       4  lTmrActivityRvCY7
       4  lTmrActivitySpi
       4  lTmrActivityTrCY7
       1  meas_data_rdy
       4  samples_data_rdy
     512  testbuff
     816  total_measurement

 
 114 951 bytes in section .bss
      16 bytes in section .data
      12 bytes in section .rodata
     268 bytes in section .text
     932 bytes in section Fast_function
 
   1 200 bytes of CODE  memory
      12 bytes of CONST memory
 114 967 bytes of DATA  memory

Errors: none
Warnings: 9
