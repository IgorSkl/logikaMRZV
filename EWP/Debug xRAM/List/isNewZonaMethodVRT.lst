###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Oct/2015  12:11:57
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\zonaVRT\isNewZonaMethodVRT.c
#    Command line =  
#        "D:\IAR projects\HR1_0100_00_I720_new2\zonaVRT\isNewZonaMethodVRT.c"
#        -lcN "D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\List\" -o
#        "D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --interwork --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\List\isNewZonaMethodVRT.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\Obj\isNewZonaMethodVRT.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\zonaVRT\isNewZonaMethodVRT.c
      1          /*
      2          #include <stdio.h>
      3          #include <TCHAR.H >
      4          #include <conio.h>
      5          #include <sys\stat.h>
      6          
      7          #include <fstream.h>
      8          #include <typeinfo.h>
      9          
     10          #include <comctrls.hpp>
     11          
     12          #include <vcl.h>
     13          #include <strstrea.h>
     14          #include <math.h>
     15          #pragma hdrstop
     16          
     17          */
     18          
     19          #include <stdio.h>
     20          #include <string.h>
     21          #include <math.h>
     22          
     23          //#include "zona1rt.h"
     24          #include "zonaVRTdef.h"
     25          #include "zonaVRTfnc.h"
     26          
     27          //extern TFzona1RT *Fzona1RT;
     28          
     29          //координаты вершин зоны сработки
     30           float X1=60.0;
     31           float Y1=33.0;
     32          
     33           float X2=40.0;
     34           float Y2=55.0;
     35          
     36           float X3=0.0;
     37           float Y3=0.0;
     38          
     39           float X4=40.0;
     40           float Y4=11.0;
     41          
     42           INT_64 koordXZ_64=353534;//125001;//160697;//250000;
     43           INT_64 koordYZ_64=421325;//216507;//191512;//0;
     44          
     45           double  X12V, Y12V, X21V, Y21V, X23V, Y23V, X32V, Y32V;
     46           double  X34V, Y34V, X41V, Y41V, X43V, Y43V, X31V, Y31V;
     47           double  X13V, Y13V;
     48          
     49           double  X14V,    Y14V;
     50          
     51           INT_64 X1_64, Y1_64, X2_64, Y2_64, X3_64, Y3_64, X4_64, Y4_64;
     52          //координаты вершин зоны возврата
     53           INT_64 X14V_64, Y14V_64, /*X12V_64, Y12V_64,*/ X21V_64, Y21V_64, /*X23V_64, Y23V_64,*/ X32V_64, Y32V_64;
     54           INT_64 /*X34V_64, Y34V_64,*/ X41V_64, Y41V_64; /*X43V_64, Y43V_64, X31V_64, Y31V_64, X13V_64, Y13V_64;*/
     55          
     56           int isZonaBD[32];//попадание в зону ДЗ
     57           int isTriangleZonaBD[10];//зона ДЗ треугольник-четырехугольник
     58          
     59           VectorXY_64   nVector34_64vrtBD[10];//для хранения зон для 5 ступеней
     60           VectorXY_64   nVector32_64vrtBD[10];
     61           VectorXY_64   nVector12_64vrtBD[10];
     62           VectorXY_64   nVector14_64vrtBD[10];
     63          
     64           VectorXY_64   nVector41_64vrtBD[10];
     65           VectorXY_64   nVector43_64vrtBD[10];
     66           VectorXY_64   nVector23_64vrtBD[10];
     67           VectorXY_64   nVector21_64vrtBD[10];
     68          
     69          //5 ступеней по 2 зоны на 4 точки с 2 коорд XY на сраб и столько же на возврат
     70           INT_64  zonaVertexBD[4 *2 *5 *2*2];//массив вершин 
     71          
     72          //нормализованный вектор сработки 34
     73           VectorXY_VRT  nVector34vrt;
     74           VectorXY_64   nVector34_64vrt;
     75          //нормализованный вектор сработки 32
     76           VectorXY_VRT  nVector32vrt;
     77           VectorXY_64   nVector32_64vrt;
     78          //нормализованный вектор сработки 12
     79           VectorXY_VRT  nVector12vrt;
     80           VectorXY_64   nVector12_64vrt;
     81          //нормализованный вектор сработки 14
     82           VectorXY_VRT  nVector14vrt;
     83           VectorXY_64   nVector14_64vrt;
     84          
     85          //нормализованный вектор сработки 41
     86           VectorXY_VRT  nVector41vrt;
     87           VectorXY_64   nVector41_64vrt;
     88          //нормализованный вектор сработки 43
     89           VectorXY_VRT  nVector43vrt;
     90           VectorXY_64   nVector43_64vrt;
     91          //нормализованный вектор сработки 23
     92           VectorXY_VRT  nVector23vrt;
     93           VectorXY_64   nVector23_64vrt;
     94          //нормализованный вектор сработки 21
     95           VectorXY_VRT  nVector21vrt;
     96           VectorXY_64   nVector21_64vrt;
     97          
     98           double VozvG = 2.0;//гистерезис возврата
     99          
    100          //INT_64 
    101          //int zonaSPV[200];
    102          //текущие уставки супервизора
    103          extern int    spvUSTAVKI[];
    104          //INT_64 *zonaSPV_64;// = (INT_64 *)(&zonaSPV[33]);
    105          
    106          short isNewZonaMethodVRT(/*int off_spv,*/ int numclon) 
    107          {
    108            X1_64 = (INT_64)ceil(X1*TO_INTEGER64);
    109            Y1_64 = (INT_64)ceil(Y1*TO_INTEGER64);
    110          
    111            X2_64 = (INT_64)ceil(X2*TO_INTEGER64);
    112            Y2_64 = (INT_64)ceil(Y2*TO_INTEGER64);
    113          
    114            X3_64 = (INT_64)ceil(X3*TO_INTEGER64);
    115            Y3_64 = (INT_64)ceil(Y3*TO_INTEGER64);
    116          
    117            X4_64 = (INT_64)ceil(X4*TO_INTEGER64);
    118            Y4_64 = (INT_64)ceil(Y4*TO_INTEGER64);
    119          
    120          //координаты вершин зоны возврата
    121            X12V = X1;
    122            Y12V = Y1;
    123            X14V = X1;
    124            Y14V = Y1;
    125            X21V = X2;
    126            Y21V = Y2;
    127            X23V = X2;
    128            Y23V = Y2;
    129            X32V = X3;
    130            Y32V = Y3;
    131            X41V = X4;
    132            Y41V = Y4;
    133            X34V = X3;
    134            Y34V = Y3;
    135          
    136            X43V = X4;
    137            Y43V = Y4;
    138          
    139          //вычислить параметры зоны
    140          //  short errorZona = 0;//false;//ошибка расположения вершин зоны
    141            if (controlPoint3VRT()) //контроль 3-й точки
    142            {
    143          //    ControlLabel->Caption = "ОШИБКА 3 точки!";
    144          //    sendText("visualView W1");
    145          //    errorZona = ERROR_3_POINT;//true;//ошибка расположения вершин зоны
    146              return ERROR_3_POINT;//true;//уйти с ошибкой
    147            }//if
    148            
    149            if (controlPoint2VRT()) //контроль 2-й точки
    150            {
    151          //    ControlLabel->Caption = "ОШИБКА 2 точки!";
    152          //    sendText("visualView W1");
    153            //  errorZona = ERROR_2_POINT;//true;//ошибка расположения вершин зоны
    154              return ERROR_2_POINT;//true;//уйти с ошибкой
    155            }//if
    156            
    157            if (controlPoint4VRT()) //контроль 4-й точки
    158            {
    159          //    ControlLabel->Caption = "ОШИБКА 4 точки!";
    160          //    sendText("visualView W1");
    161              //errorZona = ERROR_4_POINT;//true;//ошибка расположения вершин зоны
    162              return ERROR_4_POINT;//true;//уйти с ошибкой
    163            }//if
    164          
    165          //************** НОРМАЛИЗОВАННЫЕ ВЕКТОРА СРАБОТКИ *************
    166          //Правая верхняя точка - точка 1
    167          //остальные нумеруются по кругу против часой стрелки
    168          //четырехугольник должен быть выпуклым
    169          //сумма противоположных внутренних углов не может быть больше 300 грд
    170          //длина любой диагонали не меньше 5 Ом и не больше 200 Ом
    171          //любой внутренний угол - не больше 170 грд
    172          
    173            //struct 
    174              VectorXY_VRT   nVectorDg;//диагональ
    175          
    176          //вычилить диагональ
    177            double tmpLen = makeNormalVectorVRT(X3, Y3,//опорная точка
    178                                                X1, Y1,//нижний вектор
    179                                                &nVectorDg);//нормализованный вектор
    180            if (tmpLen > MAX_DIAGONAL || tmpLen < MIN_DIAGONAL)
    181            {
    182          //    ControlLabel->Caption = "ОШИБКА Диагональ 3-1 не в норме!";
    183          //    sendText("visualView W1");
    184            //  errorZona = ERROR_31_DIAGONAL;//true;//ошибка расположения вершин зоны
    185              return ERROR_31_DIAGONAL;//уйти с ошибкой
    186            }//if
    187            double tmpD = tmpLen;
    188          
    189          
    190            tmpLen = makeNormalVectorVRT(X4, Y4,//опорная точка
    191                                         X2, Y2,//нижний вектор
    192                                         &nVectorDg);//нормализованный вектор
    193            if (tmpLen > MAX_DIAGONAL || tmpLen < MIN_DIAGONAL)
    194            {
    195          //    ControlLabel->Caption = "ОШИБКА Диагональ 4-2 не в норме!";
    196          //    sendText("visualView W1");
    197          //    errorZona = ERROR_42_DIAGONAL;//true;//ошибка расположения вершин зоны
    198              return ERROR_42_DIAGONAL;//true;//уйти с ошибкой
    199            }//if
    200            if (tmpLen<tmpD) tmpD = tmpLen;//найти макс диагональ
    201          
    202          //нормализованный вектор 34
    203            tmpLen = makeNormalVectorVRT(X3, Y3,//опорная точка
    204                                         X4, Y4,//нижний вектор
    205                                         &nVector34vrt);//нормализованный вектор 34
    206          //целочисленный вариант
    207            nVector34_64vrt.xVect_64 = (INT_64)ceil(nVector34vrt.xVect*TO_INTEGER64);
    208            nVector34_64vrt.yVect_64 = (INT_64)ceil(nVector34vrt.yVect*TO_INTEGER64);
    209            //X3_64 = (INT_64)ceil(X3*TO_INTEGER64);
    210            //Y3_64 = (INT_64)ceil(Y3*TO_INTEGER64);
    211          
    212            if (tmpLen<MIN_STORONA)
    213            {
    214              //ControlLabel->Caption = "ОШИБКА Короткая сторона 34!";
    215              //sendText("visualView W1");
    216              return ERROR_34_STORONA;//true;//уйти с ошибкой
    217            }//if
    218          
    219          //нормализованный вектор 32
    220            tmpLen = makeNormalVectorVRT(X3, Y3,//опорная точка
    221                                         X2, Y2,//верхний вектор
    222                                         &nVector32vrt);//нормализованный вектор 32
    223          //целочисленный вариант
    224            nVector32_64vrt.xVect_64 = (INT_64)ceil(nVector32vrt.xVect*TO_INTEGER64);
    225            nVector32_64vrt.yVect_64 = (INT_64)ceil(nVector32vrt.yVect*TO_INTEGER64);
    226          //  X2_64 = (INT_64)ceil(X2*TO_INTEGER64);
    227          //  Y2_64 = (INT_64)ceil(Y2*TO_INTEGER64);
    228          
    229            if (tmpLen<MIN_STORONA)
    230            {
    231            //  ControlLabel->Caption = "ОШИБКА Короткая сторона 32!";
    232          //    sendText("visualView W1");
    233              return ERROR_32_STORONA;//true;//уйти с ошибкой
    234            }//if
    235          
    236            int   raz = 0;
    237            double tempShift;
    238          
    239          //  X3S1Edit->Text = ugolString(makeUgolVector(&nVector34));//угол сработки
    240          //  X3S2Edit->Text = ugolString(makeUgolVector(&nVector32));//угол сработки
    241          
    242            //char  LocTxt[200];
    243          
    244            double tmpUgol1 = makeUgolVectorVRT(&nVector32vrt);
    245            tempShift = splitUgolSVRT(tmpUgol1, &raz);//наклон сторон
    246          
    247            makeVozvPointVRT(32, tempShift, raz);//нарисовать сторону возврата 32
    248          
    249            double tmpUgol2 = makeUgolVectorVRT(&nVector34vrt);
    250            tempShift = splitUgolSVRT(tmpUgol2, &raz);//наклон сторон
    251          
    252            makeVozvPointVRT(34, tempShift, raz);//нарисовать сторону возврата 34
    253          
    254            double diff = tmpUgol1 - tmpUgol2;
    255            char  tmp1=0;
    256            if (diff>=MAX_UGOL) tmp1=1;//ошибка расположения вершин зоны
    257            if (diff<0 && (diff=(diff+360.0))>MAX_UGOL) tmp1=1;//ошибка расположения вершин зоны
    258          //  sprintf(LocTxt,  "t3= %5.3f", diff);
    259            //TestLabel3->Caption = LocTxt;
    260          
    261            if (tmp1)//контроль 3-й точки
    262            {
    263          //    ControlLabel->Caption = "ОШИБКА Угол в точке 3!";
    264          //    sendText("visualView W1");
    265              return ERROR_3_UGOL;//true;//уйти с ошибкой
    266            }//if
    267            double diffTop = diff;
    268          
    269          //нормализованный вектор 12
    270            tmpLen = makeNormalVectorVRT(X1, Y1,//опорная точка
    271                                         X2, Y2,//нижний вектор
    272                                         &nVector12vrt);//нормализованный вектор 12
    273          //целочисленный вариант
    274            nVector12_64vrt.xVect_64 = (INT_64)ceil(nVector12vrt.xVect*TO_INTEGER64);
    275            nVector12_64vrt.yVect_64 = (INT_64)ceil(nVector12vrt.yVect*TO_INTEGER64);
    276          
    277            if (tmpLen<MIN_STORONA)
    278            {
    279          //    ControlLabel->Caption = "ОШИБКА Короткая сторона 12!";
    280          //    sendText("visualView W1");
    281              return ERROR_12_STORONA;//уйти с ошибкой
    282            }//if
    283          
    284          //нормализованный вектор 14
    285            tmpLen = makeNormalVectorVRT(X1, Y1,//опорная точка
    286                                         X4, Y4,//верхний вектор
    287                                         &nVector14vrt);//нормализованный вектор 14
    288          //целочисленный вариант
    289            nVector14_64vrt.xVect_64 = (INT_64)ceil(nVector14vrt.xVect*TO_INTEGER64);
    290            nVector14_64vrt.yVect_64 = (INT_64)ceil(nVector14vrt.yVect*TO_INTEGER64);
    291          
    292            if (tmpLen<MIN_STORONA)
    293            {
    294            //  ControlLabel->Caption = "ОШИБКА Короткая сторона 14!";
    295              //sendText("visualView W1");
    296              return ERROR_14_STORONA;//true;//уйти с ошибкой
    297            }//if
    298          
    299          //  X1S1Edit->Text = ugolString(makeUgolVector(&nVector14));//угол сработки
    300          //  X1S2Edit->Text = ugolString(makeUgolVector(&nVector12));//угол сработки
    301          
    302            tmpUgol1 = makeUgolVectorVRT(&nVector14vrt);
    303            tempShift = splitUgolSVRT(tmpUgol1, &raz);//наклон сторон
    304            makeVozvPointVRT(14, tempShift, raz);//нарисовать сторону возврата
    305          
    306            tmpUgol2 = makeUgolVectorVRT(&nVector12vrt);
    307            tempShift = splitUgolSVRT(tmpUgol2, &raz);//наклон сторон
    308          
    309            makeVozvPointVRT(12, tempShift, raz);//нарисовать сторону возврата
    310            
    311            diff = tmpUgol1 - tmpUgol2;
    312            if (diff>=MAX_UGOL) tmp1=1;//ошибка расположения вершин зоны
    313            if (diff<0 && (diff=(diff+360.0))>MAX_UGOL) tmp1=1;//ошибка расположения вершин зоны
    314          //  sprintf(LocTxt,  "t1= %5.3f", diff);
    315          //  TestLabel1->Caption = LocTxt;
    316          
    317            if (tmp1)//контроль 1-й точки
    318            {
    319          //    ControlLabel->Caption = "ОШИБКА Угол в точке 1!";
    320          //    sendText("visualView W1");
    321              return ERROR_1_UGOL;//уйти с ошибкой
    322            }//if
    323            if (diffTop + diff > MAX_UGOL_SUMMA)
    324            {
    325          //    ControlLabel->Caption = "ОШИБКА Сумма углов 3-1 больше нормы!";
    326            //  sendText("visualView W1");
    327              //errorZona = true;//ошибка расположения вершин зоны
    328              return ERROR_31_SUMMAUGOL;//true;//уйти с ошибкой
    329            }//if
    330          
    331          //нормализованный вектор 41
    332            makeNormalVectorVRT(X4, Y4,//опорная точка
    333                                X1, Y1,//вектор
    334                                &nVector41vrt);//нормализованный вектор 41
    335          //целочисленный вариант
    336            nVector41_64vrt.xVect_64 = (INT_64)ceil(nVector41vrt.xVect*TO_INTEGER64);
    337            nVector41_64vrt.yVect_64 = (INT_64)ceil(nVector41vrt.yVect*TO_INTEGER64);
    338          
    339          //нормализованный вектор 43
    340            makeNormalVectorVRT(X4, Y4,//опорная точка
    341                                X3, Y3,//вектор
    342                                &nVector43vrt);//нормализованный вектор 43
    343          //целочисленный вариант
    344            nVector43_64vrt.xVect_64 = (INT_64)ceil(nVector43vrt.xVect*TO_INTEGER64);
    345            nVector43_64vrt.yVect_64 = (INT_64)ceil(nVector43vrt.yVect*TO_INTEGER64);
    346          
    347            //X4S1Edit->Text = ugolString(makeUgolVector(&nVector43));//угол сработки
    348          //  X4S2Edit->Text = ugolString(makeUgolVector(&nVector41));//угол сработки
    349          
    350            diff = makeUgolVectorVRT(&nVector43vrt) - makeUgolVectorVRT(&nVector41vrt);
    351            if (diff>=MAX_UGOL) tmp1=1;//ошибка расположения вершин зоны
    352            if (diff<0 && (diff=(diff+360.0))>MAX_UGOL) tmp1=1;//ошибка расположения вершин зоны
    353          //  sprintf(LocTxt,  "t4= %5.3f", diff);
    354          //  TestLabel4->Caption = LocTxt;
    355            if (tmp1)//контроль 4-й точки
    356            {
    357          //    ControlLabel->Caption = "ОШИБКА Угол в точке 4!";
    358          //    sendText("visualView W1");
    359              return ERROR_4_UGOL;//true;//уйти с ошибкой
    360            }//if
    361            diffTop = diff;
    362          
    363          //нормализованный вектор 23
    364            makeNormalVectorVRT(X2, Y2,//опорная точка
    365                                X3, Y3,//вектор
    366                                &nVector23vrt);//нормализованный вектор 23
    367          //целочисленный вариант
    368            nVector23_64vrt.xVect_64 = (INT_64)ceil(nVector23vrt.xVect*TO_INTEGER64);
    369            nVector23_64vrt.yVect_64 = (INT_64)ceil(nVector23vrt.yVect*TO_INTEGER64);
    370          
    371          //нормализованный вектор 21
    372            makeNormalVectorVRT(X2, Y2,//опорная точка
    373                                X1, Y1,//вектор
    374                                &nVector21vrt);//нормализованный вектор 21
    375          //целочисленный вариант
    376            nVector21_64vrt.xVect_64 = (INT_64)ceil(nVector21vrt.xVect*TO_INTEGER64);
    377            nVector21_64vrt.yVect_64 = (INT_64)ceil(nVector21vrt.yVect*TO_INTEGER64);
    378          
    379          //  X2S1Edit->Text = ugolString(makeUgolVector(&nVector21));//угол сработки
    380          //  X2S2Edit->Text = ugolString(makeUgolVector(&nVector23));//угол сработки
    381          
    382            diff = makeUgolVectorVRT(&nVector21vrt) - makeUgolVectorVRT(&nVector23vrt);
    383            if (diff>=MAX_UGOL) tmp1=1;//errorZona = true;//ошибка расположения вершин зоны
    384            if (diff<0 && (diff=(diff+360.0))>MAX_UGOL) tmp1=1;//errorZona = true;//ошибка расположения вершин зоны
    385          //  sprintf(LocTxt,  "t2= %5.3f", diff);
    386          //  TestLabel2->Caption = LocTxt;
    387          
    388            if (tmp1)//контроль 2-й точки
    389            {
    390          //    ControlLabel->Caption = "ОШИБКА Угол в точке 2!";
    391          //    sendText("visualView W1");
    392              return ERROR_2_UGOL;//true;//уйти с ошибкой
    393            }//if
    394            if (diffTop + diff > MAX_UGOL_SUMMA)
    395            {
    396          //    ControlLabel->Caption = "ОШИБКА Сумма углов 4-2 больше нормы!";
    397          //    sendText("visualView W1");
    398          //    errorZona = true;//ошибка расположения вершин зоны
    399              return ERROR_42_SUMMAUGOL;//true;//уйти с ошибкой
    400            }//if
    401          
    402          //исследовать все стороны возврата
    403            LineXY_VRT lineV32_23, lineV34_43, lineV12_21, lineV14_41;
    404            makeLineVVRT(X32V, Y32V, X23V, Y23V, &lineV32_23);//исследовать сторону возврата
    405            makeLineVVRT(X34V, Y34V, X43V, Y43V, &lineV34_43);//исследовать сторону возврата
    406            makeLineVVRT(X14V, Y14V, X41V, Y41V, &lineV14_41);//исследовать сторону возврата
    407            makeLineVVRT(X12V, Y12V, X21V, Y21V, &lineV12_21);//исследовать сторону возврата
    408          
    409            VectorXY_VRT vXY1, vXY2;
    410          
    411            vXY1.xVect = X32V;
    412            vXY1.yVect = Y32V;
    413            vXY2.xVect = X34V;
    414            vXY2.yVect = Y34V;
    415          
    416            VectorXY_VRT tempXY =
    417            makeVozvCrossPointVRT(&vXY1, &vXY2, &lineV32_23, &lineV34_43);//вычислить возврат
    418            X32V = tempXY.xVect;
    419            Y32V = tempXY.yVect;
    420            X34V = X32V;//tempXY.xVect;
    421            Y34V = Y32V;//tempXY.yVect;
    422          //целочисленный вариант
    423            X32V_64 = (INT_64)ceil(X32V*TO_INTEGER64);
    424            Y32V_64 = (INT_64)ceil(Y32V*TO_INTEGER64);
    425          //  X34V_64 = X32V_64;
    426          //  Y34V_64 = Y32V_64;
    427          
    428            vXY1.xVect = X12V;
    429            vXY1.yVect = Y12V;
    430            vXY2.xVect = X14V;
    431            vXY2.yVect = Y14V;
    432            tempXY =
    433            makeVozvCrossPointVRT(&vXY1, &vXY2, &lineV12_21, &lineV14_41);//вычислить возврат
    434            X12V = tempXY.xVect;
    435            Y12V = tempXY.yVect;
    436            X14V = X12V;//tempXY.xVect;
    437            Y14V = Y12V;//tempXY.yVect;
    438          //целочисленный вариант
    439            X14V_64 = (INT_64)ceil(X14V*TO_INTEGER64);
    440            Y14V_64 = (INT_64)ceil(Y14V*TO_INTEGER64);
    441          //  X14V_64 = X12V_64;
    442          //  Y14V_64 = Y12V_64;
    443          
    444            vXY1.xVect = X32V;
    445            vXY1.yVect = Y32V;
    446            vXY2.xVect = X12V;
    447            vXY2.yVect = Y12V;
    448            tempXY =
    449            makeVozvCrossPointVRT(&vXY1, &vXY2, &lineV32_23, &lineV12_21);//вычислить возврат
    450            X21V = tempXY.xVect;
    451            Y21V = tempXY.yVect;
    452            X23V = X21V;//tempXY.xVect;
    453            Y23V = Y21V;//tempXY.yVect;
    454          //целочисленный вариант
    455            X21V_64 = (INT_64)ceil(X21V*TO_INTEGER64);
    456            Y21V_64 = (INT_64)ceil(Y21V*TO_INTEGER64);
    457          //  X23V_64 = X21V_64;
    458          //  Y23V_64 = Y21V_64;
    459          
    460            vXY1.xVect = X34V;
    461            vXY1.yVect = Y34V;
    462            vXY2.xVect = X14V;
    463            vXY2.yVect = Y14V;
    464            tempXY =
    465            makeVozvCrossPointVRT(&vXY1, &vXY2, &lineV34_43, &lineV14_41);//вычислить возврат
    466            X41V = tempXY.xVect;
    467            Y41V = tempXY.yVect;
    468            X43V = X41V;//tempXY.xVect;
    469            Y43V = Y41V;//tempXY.yVect;
    470          //целочисленный вариант
    471            X41V_64 = (INT_64)ceil(X41V*TO_INTEGER64);
    472            Y41V_64 = (INT_64)ceil(Y41V*TO_INTEGER64);
    473          //  X43V_64 = X41V_64;
    474          //  Y43V_64 = Y41V_64;
    475          
    476          //работа с SPV массивом
    477          // INT_64  zonaVertex[4 *2 *5];//массив вершин 5 ступеней по 2 зоны на 4 точки
    478           int ii=0;
    479           zonaVertexBD[numclon*16 + ii++] = X1_64;//0//4 *2 *5];//массив вершин
    480          // ii++;
    481           zonaVertexBD[numclon*16 + ii++] = Y1_64;//0//4 *2 *5];//массив вершин
    482          // ii++;
    483          
    484           zonaVertexBD[numclon*16 + ii++] = X2_64;//0//4 *2 *5];//массив вершин
    485          // ii++;
    486           zonaVertexBD[numclon*16 + ii++] = Y2_64;//0//4 *2 *5];//массив вершин
    487          // ii++;
    488          
    489           zonaVertexBD[numclon*16 + ii++] = X3_64;//0//4 *2 *5];//массив вершин
    490          // ii++;
    491           zonaVertexBD[numclon*16 + ii++] = Y3_64;//0//4 *2 *5];//массив вершин
    492          // ii++;
    493          
    494           zonaVertexBD[numclon*16 + ii++] = X4_64;//0//4 *2 *5];//массив вершин
    495          // ii++;
    496           zonaVertexBD[numclon*16 + ii++] = Y4_64;//0//4 *2 *5];//массив вершин
    497          // ii++;
    498          
    499           zonaVertexBD[numclon*16 + ii++] = X14V_64;//0//4 *2 *5];//массив вершин
    500          // ii++;
    501           zonaVertexBD[numclon*16 + ii++] = Y14V_64;//0//4 *2 *5];//массив вершин
    502          // ii++;
    503          
    504           zonaVertexBD[numclon*16 + ii++] = X21V_64;//0//4 *2 *5];//массив вершин
    505          // ii++;
    506           zonaVertexBD[numclon*16 + ii++] = Y21V_64;//0//4 *2 *5];//массив вершин
    507          // ii++;
    508          
    509           zonaVertexBD[numclon*16 + ii++] = X32V_64;//0//4 *2 *5];//массив вершин
    510          // ii++;
    511           zonaVertexBD[numclon*16 + ii++] = Y32V_64;//0//4 *2 *5];//массив вершин
    512          // ii++;
    513          
    514           zonaVertexBD[numclon*16 + ii++] = X41V_64;//0//4 *2 *5];//массив вершин
    515          // ii++;
    516           zonaVertexBD[numclon*16 + ii++] = Y41V_64;//0//4 *2 *5];//массив вершин
    517          // ii++;
    518          
    519          /*
    520           INT_64 * zonaSPV_64 = (INT_64 *)(&spvUSTAVKI[off_spv]);
    521           int i=0;
    522           zonaSPV_64[i++] = X1_64;//0
    523           zonaSPV_64[i++] = Y1_64;//1
    524          
    525           zonaSPV_64[i++] = X2_64;//2
    526           zonaSPV_64[i++] = Y2_64;//3
    527          
    528           zonaSPV_64[i++] = X3_64;//4
    529           zonaSPV_64[i++] = Y3_64;//5
    530          
    531           zonaSPV_64[i++] = X4_64;//6
    532           zonaSPV_64[i++] = Y4_64;//7
    533          
    534           zonaSPV_64[i++] = X14V_64;//8
    535           zonaSPV_64[i++] = Y14V_64;//9
    536          
    537           zonaSPV_64[i++] = X21V_64;//10
    538           zonaSPV_64[i++] = Y21V_64;//11
    539          
    540           zonaSPV_64[i++] = X32V_64;//12
    541           zonaSPV_64[i++] = Y32V_64;//13
    542          
    543           zonaSPV_64[i++] = X41V_64;//14
    544           zonaSPV_64[i++] = Y41V_64;//15
    545          */
    546          
    547          //сохранить нормализ вектора
    548          //для хранения зон для 5 ступеней
    549           memcpy(&(nVector34_64vrtBD[numclon]), &nVector34_64vrt, sizeof(VectorXY_64));
    550           memcpy(&(nVector32_64vrtBD[numclon]), &nVector32_64vrt, sizeof(VectorXY_64));
    551           memcpy(&(nVector12_64vrtBD[numclon]), &nVector12_64vrt, sizeof(VectorXY_64));
    552           memcpy(&(nVector14_64vrtBD[numclon]), &nVector14_64vrt, sizeof(VectorXY_64));
    553          
    554           memcpy(&(nVector41_64vrtBD[numclon]), &nVector41_64vrt, sizeof(VectorXY_64));
    555           memcpy(&(nVector43_64vrtBD[numclon]), &nVector43_64vrt, sizeof(VectorXY_64));
    556           memcpy(&(nVector23_64vrtBD[numclon]), &nVector23_64vrt, sizeof(VectorXY_64));
    557           memcpy(&(nVector21_64vrtBD[numclon]), &nVector21_64vrt, sizeof(VectorXY_64));
    558            return 0;//нет ошибок
    559          }//isNewZonaMethodVRT()
    560          
    561          char controlPoint1VRT()
    562          {
    563          //контроль 1-й точки
    564          //  if ((X1_64-X2_64)==0)if(Y1_64<Y2_64) return 1;//true;//ОШИБКА
    565            if ((X1_64-X2_64)==0)if(Y1_64<Y2_64) return 1;//true;//ОШИБКА
    566            if ((X1_64<X2_64)) return 1;//true;//ОШИБКА
    567            if ((X1_64<X3_64)) return 1;//true;//ОШИБКА
    568            return 0;
    569          }//controlPoint2VRT()
    570          
    571          char controlPoint2VRT()
    572          {
    573          //контроль 2-й точки
    574          //  if ((X1_64-X2_64)<0) return 1;//true;//ОШИБКА
    575            //if ((X2_64<X3_64)) return 1;//true;//ОШИБКА
    576            return 0;
    577          }//controlPoint2VRT()
    578          
    579          char controlPoint3VRT()
    580          {
    581          //контроль 3-й точки
    582          //  if ((X1_64-X3_64)<0) return 1;//true;//ОШИБКА
    583          //  if ((X4_64-X3_64)<0) return 1;//true;//ОШИБКА
    584            return 0;
    585          }//controlPoint3VRT()
    586          
    587          char controlPoint4VRT()
    588          {
    589          //контроль 4-й точки
    590            if ((X1_64-X4_64)<0) return 1;//true;//ОШИБКА
    591            return 0;
    592          }//controlPoint4VRT()
    593          
    594          double makeNormalVectorVRT(double xOpor, double yOpor,
    595                                     double xVect, double yVect, VectorXY_VRT *nVector)
    596          {
    597          //вычислить нормализованный вектор
    598          //xOpor, yOpor - начало нормализованного вектора
    599          //xVect, yVect - конец  нормализованного вектора
    600          //nVector - коорд нормализованного вектора
    601            double xn = xVect - xOpor;
    602            double yn = yVect - yOpor;
    603          //длина
    604            double len = makeLenVectorVRT(xn, yn);
    605            
    606            if (len<0.001) len=0.001;//предохранитель
    607          //нормализовать
    608            nVector ->  xVect = xn/len;
    609            nVector ->  yVect = yn/len;
    610            
    611            return len;
    612          }//makeNormalVectorVRT(double xOpor, double yOpor,
    613          
    614          double makeUgolVectorVRT(VectorXY_VRT *nVector)
    615          {
    616            //углы
    617            double T = acos(-1.0)/180.0;
    618            double ugolS = asin(nVector ->  yVect)/T;
    619            
    620            if (nVector->xVect>=0 && nVector->yVect>=0)  return ugolS;
    621            if (nVector->xVect<=0)                       return 180.0 - ugolS;
    622            if (ugolS<0) ugolS += 360.0;
    623            
    624            return ugolS;
    625          }//makeUgolVectorVRT(VectorXY_VRT *nVector)
    626          
    627          double splitUgolSVRT(double ugolS, int *raz)
    628          {
    629          //наклон сторон
    630            *raz = 0;
    631            while (ugolS>90.0)
    632            {
    633              ugolS -= 90.0;
    634              (*raz)++;
    635            }
    636            return ugolS;
    637          }//splitUgolSVRT(double ugolS, int &raz)
    638          
    639          void makeVozvPointVRT(int lineID, double tmpShift, int cntRaz)
    640          {
    641          //вычислить сторону возврата
    642            LineXY_VRT line;
    643            double xymin = 2.0;//0.5;
    644            double proc5 = 0.05;
    645            makeLineVVRT(X3, Y3, X2, Y2, &line);//исследовать сторону 
    646            double y32 = 0.0;
    647            double x32 = 0.0;
    648            if(line.isVert || line.isGoriz){
    649             if(line.isVert) y32=x32=fabs((float)X3*proc5);
    650             if(line.isGoriz)y32=x32=fabs((float)Y3*proc5);
    651            }//if
    652            else{
    653             y32 = fabs((float)line.B*proc5);
    654             x32 = fabs((float)-(line.B/line.K)*proc5);
    655             if (fabs((float)line.B)-0.001<0.0){y32=x32=xymin;}
    656               }
    657             if (x32-xymin<0.0){x32=xymin;}
    658             if (y32-xymin<0.0){y32=xymin;}
    659            makeLineVVRT(X3, Y3, X4, Y4, &line);//исследовать сторону 
    660            double y34 = 0.0;
    661            double x34 = 0.0;
    662            if(line.isVert || line.isGoriz){
    663          //   y34=x34=xmin;
    664             if(line.isVert) y34=x34=fabs((float)X3*proc5);
    665             if(line.isGoriz)y34=x34=fabs((float)Y3*proc5);
    666            }//if
    667            else{
    668             y34 = fabs((float)line.B*proc5);
    669             x34 = fabs((float)-(line.B/line.K)*proc5);
    670             if (fabs((float)line.B)-0.001<0.0){y34=x34=xymin;}
    671               }
    672             if (x34-xymin<0.0){x34=xymin;}
    673             if (y34-xymin<0.0){y34=xymin;}
    674            makeLineVVRT(X1, Y1, X4, Y4, &line);//исследовать сторону 
    675            double y14 = 0.0;
    676            double x14 = 0.0;
    677            if(line.isVert || line.isGoriz){
    678          //   y14=x14=xmin;
    679             if(line.isVert) y14=x14=fabs((float)X1*proc5);
    680             if(line.isGoriz)y14=x14=fabs((float)Y1*proc5);
    681            }//if
    682            else{
    683             y14 = fabs((float)line.B*proc5);
    684             x14 = fabs((float)-(line.B/line.K)*proc5);
    685             if (fabs((float)line.B)-0.001<0.0){y14=x14=xymin;}
    686               }
    687             if (x14-xymin<0.0){x14=xymin;}
    688             if (y14-xymin<0.0){y14=xymin;}
    689            makeLineVVRT(X1, Y1, X2, Y2, &line);//исследовать сторону 
    690            double y12 = 0.0;
    691            double x12 = 0.0;
    692            if(line.isVert || line.isGoriz){
    693          //   y12=x12=xmin;
    694             if(line.isVert) y12=x12=fabs((float)X1*proc5);
    695             if(line.isGoriz)y12=x12=fabs((float)Y1*proc5);
    696            }//if
    697            else{
    698             y12 = fabs((float)line.B*proc5);
    699             x12 = fabs((float)-(line.B/line.K)*proc5);
    700             if (fabs((float)line.B)-0.001<0.0){y12=x12=xymin;}
    701               }
    702             if (x12-xymin<0.0){x12=xymin;}
    703             if (y12-xymin<0.0){y12=xymin;}
    704          
    705            makeLineVVRT(X3, Y3, X1, Y1, &line);//исследовать сторону 
    706            double y31 = 0.0;
    707            double x31 = 0.0;
    708            if(line.isVert || line.isGoriz){
    709             if(line.isVert) y31=x31=fabs((float)X3*proc5);
    710             if(line.isGoriz)y31=x31=fabs((float)Y3*proc5);
    711            }//if
    712            else{
    713             y31 = fabs((float)line.B*proc5);
    714             x31 = fabs((float)-(line.B/line.K)*proc5);
    715             if (fabs((float)line.B)-0.001<0.0){y31=x31=xymin;}
    716               }
    717             if (x31-xymin<0.0){x31=xymin;}
    718             if (y31-xymin<0.0){y31=xymin;}
    719          
    720            switch (cntRaz)
    721            {
    722            case 0:
    723              if (tmpShift<45.0)
    724              {
    725                if (lineID==32)
    726                {
    727                  Y32V += y32;//len3/y32;
    728                  Y23V += y32;//len2/y23;
    729                }
    730                if (lineID==34)
    731                {
    732                  Y34V -= y34;//len3/y34;
    733                  Y43V -= y34;//len4/y43;
    734                  Y31V -= y31;//VozvG;
    735                  Y13V -= y31;//VozvG;
    736                }
    737                if (lineID==14)
    738                {
    739                  Y14V -= y14;//len1/y14;
    740                  Y41V -= y14;//len4/y41;
    741                }
    742                if (lineID==12)
    743                {
    744                  Y12V -= y12;//len1/y12;
    745                  Y21V -= y12;//len2/y21;
    746                }
    747              }//if
    748              else
    749              {
    750                if (lineID==32)
    751                {
    752                  X32V -= x32;//len3/x32;
    753                  X23V -= x32;//len2/x23;
    754                }
    755                if (lineID==34)
    756                {
    757                  X34V += x34;//len3/x34;
    758                  X43V += x34;//len4/x43;
    759                  X31V += x31;//VozvG;
    760                  X13V += x31;//VozvG;
    761                }
    762                if (lineID==14)
    763                {
    764                  X14V += x14;//len1/x14;
    765                  X41V += x14;//len4/x41;
    766                }
    767                if (lineID==12)
    768                {
    769                  X12V -= x12;//len1/x12;
    770                  X21V -= x12;//len2/x21;
    771                }
    772              }
    773              break;
    774          
    775            case 1:
    776              if (tmpShift<45.0)
    777              {
    778                if (lineID==32)
    779                {
    780                  X32V -= x32;//len3/x32;
    781                  X23V -= x32;//len2/x23;
    782                }
    783                if (lineID==34)
    784                {
    785                  X34V -= x34;//len3/x34;
    786                  X43V -= x34;//len4/x43;
    787                  X31V -= x31;//VozvG;
    788                  X13V -= x31;//VozvG;
    789                }
    790                if (lineID==14)
    791                {
    792                  X14V -= x14;//len1/x14;
    793                  X41V -= x14;//len4/x41;
    794                }
    795                if (lineID==12)
    796                {
    797                  X12V += x12;//len1/x12;
    798                  X21V += x12;//len2/x21;
    799                }
    800              }//if
    801              else
    802              {
    803                if (lineID==32)
    804                {
    805                  Y32V -= y32;//len3/y32;
    806                  Y23V -= y32;//len2/y23;
    807                }
    808                if (lineID==34)
    809                {
    810                  Y34V -= y34;//len3/y34;
    811                  Y43V -= y34;//len4/y43;
    812                  Y31V -= y31;//VozvG;
    813                  Y13V -= y31;//VozvG;
    814                }
    815                if (lineID==14)
    816                {
    817                  Y14V -= y14;//len1/y14;
    818                  Y41V -= y14;//len4/y41;
    819                }
    820                if (lineID==12)
    821                {
    822                  Y12V += y12;//len1/y12;
    823                  Y21V += y12;//len2/y21;
    824                }
    825              }
    826              break;
    827          
    828            case 2:
    829              if (tmpShift<45.0)
    830              {
    831                if (lineID==32)
    832                {
    833                  Y32V -= y32;//len3/y32;
    834                  Y23V -= y32;//len2/y23;
    835                }
    836                if (lineID==34)
    837                {
    838                  Y34V -= y34;//len3/y34;
    839                  Y43V -= y34;//len4/y43;
    840                  Y31V -= y31;//VozvG;
    841                  Y13V -= y31;//VozvG;
    842                }
    843                if (lineID==14)
    844                {
    845                  Y14V -= y14;//len1/y14;
    846                  Y41V -= y14;//len4/y41;
    847                }
    848                if (lineID==12)
    849                {
    850                  Y12V += y12;//len1/y12;
    851                  Y21V += y12;//len2/y21;
    852                }
    853              }//if
    854              else
    855              {
    856                if (lineID==32)
    857                {
    858                  X32V -= x32;//len3/x32;
    859                  X23V -= x32;//len2/x23;
    860                }
    861                if (lineID==34)
    862                {
    863                  X34V -= x34;//len3/x34;
    864                  X43V -= x34;//len4/x43;
    865                  X31V -= x31;//VozvG;
    866                  X13V -= x31;//VozvG;
    867                }
    868                if (lineID==14)
    869                {
    870                  X14V += x14;//len1/x14;
    871                  X41V += x14;//len4/x41;
    872                }
    873                if (lineID==12)
    874                {
    875                  X12V -= x12;//len1/x12;
    876                  X21V -= x12;//len2/x21;
    877                }
    878              }
    879              break;
    880          
    881            case 3:
    882              if (tmpShift<45.0)
    883              {
    884                if (lineID==32)
    885                {
    886                  X32V -= x32;//len3/x32;
    887                  X23V -= x32;//len2/x23;
    888                }
    889                if (lineID==34)
    890                {
    891                  X34V -= x34;//len3/x34;
    892                  X43V -= x34;//len4/x43;
    893                  X31V -= x31;//VozvG;
    894                  X13V -= x31;//VozvG;
    895                }
    896                if (lineID==14)
    897                {
    898                  X14V -= x14;//len1/x14;
    899                  X41V -= x14;//len4/x41;
    900                }
    901                if (lineID==12)
    902                {
    903                  X12V -= x12;//len1/x12;
    904                  X21V -= x12;//len2/x21;
    905                }
    906              }//if
    907              else
    908              {
    909                if (lineID==32)
    910                {
    911                  Y32V += y32;//len3/y32;
    912                  Y23V += y32;//len2/y23;
    913                }
    914                if (lineID==34)
    915                {
    916                  Y34V -= y34;//len3/y34;
    917                  Y43V -= y34;//len4/y43;
    918                  Y31V -= y31;//VozvG;
    919                  Y13V -= y31;//VozvG;
    920                }
    921                if (lineID==14)
    922                {
    923                  Y14V += y14;//len1/y14;
    924                  Y41V += y14;//len4/y41;
    925                }
    926                if (lineID==12)
    927                {
    928                  Y12V += y12;//len1/y12;
    929                  Y21V += y12;//len2/y21;
    930                }
    931              }
    932              break;
    933            default:
    934              ;
    935            }//switch
    936          
    937          }//makeVozvPointVRT(int lineID, double tmpShift, int cntRaz)
    938          
    939          void makeLineVVRT(double x0, double y0, double x1, double y1, LineXY_VRT *lineV)
    940          {
    941          //исследовать сторону возврата
    942            lineV->isVert = 0;//false;
    943            lineV->isGoriz = 0;//false;
    944            if (fabs((float)x0-(float)x1)<MIN_STORONA)
    945            {
    946              lineV->isVert = 1;//true;
    947              return;
    948            }
    949            if (fabs((float)y0-(float)y1)<MIN_STORONA)
    950            {
    951              lineV->isGoriz = 1;//true;
    952              return;
    953            }
    954          
    955            lineV->K = (y1-y0)/(x1-x0);
    956            lineV->B = y0 - lineV->K*x0;
    957          //  lineV->K = makeKoefKVRT(x0, y0, x1, y1);//вычислить К
    958            //lineV->B = makeKoefBVRT(x0, y0, x1, y1);//вычислить B
    959          }//makeLineVVRT(double x0, double y0, double x1, double y1, LineXY_VRT *lineV)
    960          
    961          VectorXY_VRT makeVozvCrossPointVRT(VectorXY_VRT *vector1, VectorXY_VRT *vector2, 
    962                                             LineXY_VRT *lineV1, LineXY_VRT *lineV2)
    963          {
    964          //вычислить возврат
    965            double XP, YP;
    966          //точка пересечения
    967            if (!(lineV1->isGoriz || lineV1->isVert || lineV2->isGoriz || lineV2->isVert))
    968            {
    969              XP = makeXPVRT(lineV1->K, lineV2->K, lineV1->B, lineV2->B);//вычислить точку пересечения
    970              YP = lineV1->K*XP + lineV1->B;
    971            }//if
    972            else
    973            {
    974              if (lineV1->isGoriz && !(lineV2->isGoriz||lineV2->isVert))
    975              {
    976                XP = (vector1->yVect - lineV2->B)/lineV2->K;
    977                YP = vector1->yVect;
    978              }//if
    979              if (lineV1->isVert && !(lineV2->isGoriz||lineV2->isVert))
    980              {
    981                XP = vector1->xVect;
    982                YP = lineV2->K*XP + lineV2->B;
    983              }//if
    984          
    985              if (lineV2->isGoriz && !(lineV1->isGoriz||lineV1->isVert))
    986              {
    987                XP = (vector2->yVect - lineV1->B)/lineV1->K;
    988                YP = vector2->yVect;
    989              }//if
    990              if (lineV2->isVert && !(lineV1->isGoriz||lineV1->isVert))
    991              {
    992                XP = vector2->xVect;
    993                YP = lineV1->K*XP + lineV1->B;
    994              }//if
    995              if (lineV2->isVert && lineV1->isGoriz)
    996              {
    997                XP = vector2->xVect;
    998                YP = vector1->yVect;
    999              }//if
   1000              if (lineV1->isVert && lineV2->isGoriz)
   1001              {
   1002                XP = vector1->xVect;
   1003                YP = vector2->yVect;
   1004              }//if
   1005            }//else
   1006          
   1007             VectorXY_VRT tempXY;
   1008             tempXY.xVect = XP;
   1009             tempXY.yVect = YP;
   1010            return tempXY;
   1011          }//makeVozvCrossPointVRT(VectorXY_VRT *vector1, VectorXY_VRT *vector2, 
   1012          
   1013          double makeXPVRT(double K1, double K2, double B1, double B2)
   1014          {
   1015          //вычислить точку пересечения
   1016            return (B2-B1)/(K1-K2);
   1017          }//makeXPVRT(double K1, double K2, double B1, double B2)
   1018          
   1019          double makeLenVectorVRT(double xn, double yn)
   1020          {
   1021          //вычислить длину приведенного Z
   1022            return sqrt(xn*xn + yn*yn);
   1023          }//makeLenVector(VectorXY *oporZ)
   1024          /*
   1025          double makeKoefKVRT(double X0, double Y0, double X1, double Y1)
   1026          {
   1027          //вычислить К
   1028            if (fabs((float)X1)-0.001<0.0)
   1029            {
   1030              X0 += 1.0;
   1031              X1 += 1.0;
   1032            }
   1033            return Y1/X1-(X1*Y0-X0*Y1)/(X1*X1-X0*X1);
   1034          
   1035          }//makeKoefKVRT(double X0, double Y0, double X1, double Y1)
   1036          
   1037          double makeKoefBVRT(double X0, double Y0, double X1, double Y1)
   1038          {
   1039          //вычислить B
   1040            return (X1*Y0-X0*Y1)/(X1-X0);
   1041          }//makeKoefBVRT(double X0, double Y0, double X1, double Y1)
   1042          */
   1043          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   controlPoint1VRT
       0   controlPoint2VRT
       0   controlPoint3VRT
       4   controlPoint4VRT
     312   isNewZonaMethodVRT
       312   -> __aeabi_d2lz
       312   -> __aeabi_memcpy
       312   -> ceil
       312   -> controlPoint2VRT
       312   -> controlPoint3VRT
       312   -> controlPoint4VRT
       312   -> makeLineVVRT
       312   -> makeNormalVectorVRT
       312   -> makeUgolVectorVRT
       312   -> makeVozvCrossPointVRT
       312   -> makeVozvPointVRT
       312   -> splitUgolSVRT
      24   makeLenVectorVRT
        24   -> sqrt
       0   makeLineVVRT
      56   makeNormalVectorVRT
        56   -> makeLenVectorVRT
      16   makeUgolVectorVRT
        16   -> acos
        16   -> asin
      40   makeVozvCrossPointVRT
        40   -> makeXPVRT
     128   makeVozvPointVRT
       128   -> makeLineVVRT
       0   makeXPVRT
       0   splitUgolSVRT


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable3
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_22
       4  ??DataTable5_23
       4  ??DataTable5_24
       4  ??DataTable5_25
       4  ??DataTable5_26
       4  ??DataTable5_27
       4  ??DataTable5_28
       4  ??DataTable5_29
       4  ??DataTable5_3
       4  ??DataTable5_30
       4  ??DataTable5_31
       4  ??DataTable5_32
       8  ??DataTable5_33
       8  ??DataTable5_34
       8  ??DataTable5_35
       4  ??DataTable5_36
       4  ??DataTable5_37
       8  ??DataTable5_38
       8  ??DataTable5_39
       4  ??DataTable5_4
       8  ??DataTable5_40
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_16
       4  ??DataTable7_17
       4  ??DataTable7_18
       4  ??DataTable7_19
       4  ??DataTable7_2
       4  ??DataTable7_20
       4  ??DataTable7_21
       4  ??DataTable7_22
       4  ??DataTable7_23
       8  ??DataTable7_24
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
       8  VozvG
       4  X1
       8  X12V
       8  X13V
       8  X14V
       8  X14V_64
       8  X1_64
       4  X2
       8  X21V
       8  X21V_64
       8  X23V
       8  X2_64
       4  X3
       8  X31V
       8  X32V
       8  X32V_64
       8  X34V
       8  X3_64
       4  X4
       8  X41V
       8  X41V_64
       8  X43V
       8  X4_64
       4  Y1
       8  Y12V
       8  Y13V
       8  Y14V
       8  Y14V_64
       8  Y1_64
       4  Y2
       8  Y21V
       8  Y21V_64
       8  Y23V
       8  Y2_64
       4  Y3
       8  Y31V
       8  Y32V
       8  Y32V_64
       8  Y34V
       8  Y3_64
       4  Y4
       8  Y41V
       8  Y41V_64
       8  Y43V
       8  Y4_64
     184  controlPoint1VRT
       8  controlPoint2VRT
       8  controlPoint3VRT
      64  controlPoint4VRT
    4848  isNewZonaMethodVRT
      40  isTriangleZonaBD
     128  isZonaBD
       8  koordXZ_64
       8  koordYZ_64
      36  makeLenVectorVRT
     148  makeLineVVRT
      96  makeNormalVectorVRT
     128  makeUgolVectorVRT
     468  makeVozvCrossPointVRT
    3776  makeVozvPointVRT
      16  makeXPVRT
      16  nVector12_64vrt
     160  nVector12_64vrtBD
      16  nVector12vrt
      16  nVector14_64vrt
     160  nVector14_64vrtBD
      16  nVector14vrt
      16  nVector21_64vrt
     160  nVector21_64vrtBD
      16  nVector21vrt
      16  nVector23_64vrt
     160  nVector23_64vrtBD
      16  nVector23vrt
      16  nVector32_64vrt
     160  nVector32_64vrtBD
      16  nVector32vrt
      16  nVector34_64vrt
     160  nVector34_64vrtBD
      16  nVector34vrt
      16  nVector41_64vrt
     160  nVector41_64vrtBD
      16  nVector41vrt
      16  nVector43_64vrt
     160  nVector43_64vrtBD
      16  nVector43vrt
      52  splitUgolSVRT
    1280  zonaVertexBD

 
  3 280 bytes in section .bss
     48 bytes in section .data
 10 168 bytes in section .text
 
 10 168 bytes of CODE memory
  3 328 bytes of DATA memory

Errors: none
Warnings: none
