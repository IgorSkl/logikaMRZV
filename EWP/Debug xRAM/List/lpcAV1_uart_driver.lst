###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Oct/2015  12:11:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        projects\HR1_0100_00_I720_new2\LIB\CDL_AV0\csps\lpc32xx\source\lpcAV1_uart_driver.c
#    Command line =  
#        "D:\IAR
#        projects\HR1_0100_00_I720_new2\LIB\CDL_AV0\csps\lpc32xx\source\lpcAV1_uart_driver.c"
#        -lcN "D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\List\" -o
#        "D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --interwork --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\List\lpcAV1_uart_driver.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\Obj\lpcAV1_uart_driver.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\LIB\CDL_AV0\csps\lpc32xx\source\lpcAV1_uart_driver.c
      1          /***********************************************************************
      2           * $Id: lpc32xx_uart_driver.c 35145 2010-03-19 18:10:17Z anderslu $
      3           *
      4           * Project: LPC32xx standard UART driver
      5           *
      6           * Description:
      7           *     This file contains driver support for the LPC32xx standard UART
      8           *
      9           ***********************************************************************
     10           * Software that is described herein is for illustrative purposes only
     11           * which provides customers with programming information regarding the
     12           * products. This software is supplied "AS IS" without any warranties.
     13           * NXP Semiconductors assumes no responsibility or liability for the
     14           * use of the software, conveys no license or title under any patent,
     15           * copyright, or mask work right to the product. NXP Semiconductors
     16           * reserves the right to make changes in the software without
     17           * notification. NXP Semiconductors also make no representation or
     18           * warranty that such application will be suitable for the specified
     19           * use without further testing or modification.
     20           *********************************************************************/
     21           
     22          #include "../include/lpc32xx_uart_driver.h"
     23          #include "../include/lpc32xx_intc_driver.h"
     24          #include "../include/lpc32xx_clkpwr_driver.h"
     25          
     26          /***********************************************************************
     27           * UART driver package data
     28          ***********************************************************************/
     29          
     30          /* Structure for computing high/low dividers for clock rate */
     31          typedef struct
     32          {
     33            UNS_32 divx;
     34            UNS_32 divy; /* For x/y */
     35          } UART_CLKDIV_T;
     36          
     37          /* UART device configuration structure type */
     38          typedef struct
     39          {
     40            UART_REGS_T *regptr;
     41            UART_CBS_T cbs;
     42            INT_32 uartnum; /* Used for array indicing, 0 = UART1 */
     43            UNS_32 baudrate;
     44            UART_CLKDIV_T divs;
     45            BOOL_32 uart_init;
     46          } UART_CFG_T;
     47          
     48          /* UART driver data */
     49          static UART_CFG_T uartdat [4];
     50          
     51          /* Array to find a clock ID from it's UART number */
     52          static const CLKPWR_CLK_T uart_num_to_clk_enum [4] =
     53          {
     54            CLKPWR_UART3_CLK,
     55            CLKPWR_UART4_CLK,
     56            CLKPWR_UART5_CLK,
     57            CLKPWR_UART6_CLK
     58          };
     59          
     60          /***********************************************************************
     61           * UART driver private functions
     62           **********************************************************************/
     63          
     64          /***********************************************************************
     65           *
     66           * Function: uart_gen_int_handler
     67           *
     68           * Purpose: General UART interrupt handler and router
     69           *
     70           * Processing:
     71           *     Handles transmit, receive, and status interrupts for the UART.
     72           *     Based on the interrupt status, routes the interrupt to the
     73           *     respective callback to be handled by the user application using
     74           *     this driver.
     75           *
     76           * Parameters: None
     77           *
     78           * Outputs: None
     79           *
     80           * Returns: Nothing
     81           *
     82           * Notes: If a callback doesn't exist, the interrupt will be disabled.
     83           *
     84           **********************************************************************/
     85          void Uart_gen_int_handler(UART_CFG_T *puartcfg)
     86          {
     87            volatile UNS_32 tmp;
     88          
     89            /* Determine the interrupt source */
     90            tmp = puartcfg->regptr->iir_fcr & UART_IIR_INTSRC_MASK;
     91            switch (tmp)
     92            {
     93              case UART_IIR_INTSRC_RXLINE:
     94              default:
     95                /* RX line status interrupt, needs servicing */
     96                if (puartcfg->cbs.rxerrcb != NULL)
     97                {
     98                  puartcfg->cbs.rxerrcb(puartcfg->uartnum + 3);
     99                }
    100                else
    101                {
    102                  /* No callback, disable interrupt */
    103                  puartcfg->regptr->dlm_ier &= ~(UART_IER_RXLINE_STS |
    104                    UART_IER_MODEM_STS);
    105                }
    106                break;
    107          
    108              case UART_IIR_INTSRC_THRE:
    109                /* Disable interrupt, write will re-enable it */
    110                if (puartcfg->cbs.txcb != NULL)
    111                {
    112                  puartcfg->cbs.txcb(puartcfg->uartnum + 3);
    113                }
    114                break;
    115          
    116              case UART_IIR_INTSRC_RDA:
    117              case UART_IIR_INTSRC_CTI:
    118                /* Receive interrupt, needs servicing */
    119                if (puartcfg->cbs.rxcb != NULL)
    120                {
    121                  puartcfg->cbs.rxcb(puartcfg->uartnum + 3);
    122                }
    123                else
    124                {
    125                  /* No callback, disable interrupt */
    126                  puartcfg->regptr->dlm_ier &= ~UART_IER_RDA;
    127                }
    128                break;
    129            }
    130          }
    131          
    132          /***********************************************************************
    133           *
    134           * Function: uart3_int_handler
    135           *
    136           * Purpose: UART3 interrupt handler and router
    137           *
    138           * Processing:
    139           *     Handles UART 3 interrupt by routing the to general handler with
    140           *     the UART 3 driver data.
    141           *
    142           * Parameters: None
    143           *
    144           * Outputs: None
    145           *
    146           * Returns: Nothing
    147           *
    148           * Notes: None
    149           *
    150           **********************************************************************/
    151          void Uart3_int_handler(void)
    152          {
    153            Uart_gen_int_handler(&uartdat[0]);
    154          }
    155          
    156          /***********************************************************************
    157           *
    158           * Function: uart4_int_handler
    159           *
    160           * Purpose: UART4 interrupt handler and router
    161           *
    162           * Processing:
    163           *     Handles UART 4 interrupt by routing the to general handler with
    164           *     the UART 4 driver data.
    165           *
    166           * Parameters: None
    167           *
    168           * Outputs: None
    169           *
    170           * Returns: Nothing
    171           *
    172           * Notes: None
    173           *
    174           **********************************************************************/
    175          void Uart4_int_handler(void)
    176          {
    177            Uart_gen_int_handler(&uartdat[1]);
    178          }
    179          
    180          /***********************************************************************
    181           *
    182           * Function: uart5_int_handler
    183           *
    184           * Purpose: UART5 interrupt handler and router
    185           *
    186           * Processing:
    187           *     Handles UART 5 interrupt by routing the to general handler with
    188           *     the UART 5 driver data.
    189           *
    190           * Parameters: None
    191           *
    192           * Outputs: None
    193           *
    194           * Returns: Nothing
    195           *
    196           * Notes: None
    197           *
    198           **********************************************************************/
    199          void Uart5_int_handler(void)
    200          {
    201            Uart_gen_int_handler(&uartdat[2]);
    202          }
    203          
    204          /***********************************************************************
    205           *
    206           * Function: uart6_int_handler
    207           *
    208           * Purpose: UART6 interrupt handler and router
    209           *
    210           * Processing:
    211           *     Handles UART 6 interrupt by routing the to general handler with
    212           *     the UART 6 driver data.
    213           *
    214           * Parameters: None
    215           *
    216           * Outputs: None
    217           *
    218           * Returns: Nothing
    219           *
    220           * Notes: None
    221           *
    222           **********************************************************************/
    223          void Uart6_int_handler(void)
    224          {
    225            Uart_gen_int_handler(&uartdat[3]);
    226          }
    227          
    228          /***********************************************************************
    229           *
    230           * Function: uart_abs
    231           *
    232           * Purpose: ABS difference function
    233           *
    234           * Processing:
    235           *     See function.
    236           *
    237           * Parameters:
    238           *     v1 : Value 1 for ABS
    239           *     v2 : Value 2 for ABS
    240           *
    241           * Outputs: None
    242           *
    243           * Returns: Absolute difference between the 2 values
    244           *
    245           * Notes: None
    246           *
    247           **********************************************************************/
    248          INT_32 Uart_abs(INT_32 v1, INT_32 v2)
    249          {
    250            if (v1 > v2)
    251            {
    252              return v1 - v2;
    253            }
    254          
    255            return v2 - v1;
    256          }
    257          
    258          /***********************************************************************
    259           *
    260           * Function: uart_ptr_to_uart_num
    261           *
    262           * Purpose: Convert a UART register pointer to a UART number
    263           *
    264           * Processing:
    265           *     Based on the passed UART address, return the UART number.
    266           *
    267           * Parameters:
    268           *     puart : Pointer to a UART register set
    269           *
    270           * Outputs: None
    271           *
    272           * Returns: The UART number (0 to 3) or -1 if register pointer is bad
    273           *
    274           * Notes: Returned numbers are adjusted to offset 0 (UART3 is 0)
    275           *
    276           **********************************************************************/
    277          INT_32 Uart_ptr_to_uart_num(UART_REGS_T *puart)
    278          {
    279            INT_32 uartnum = -1;
    280          
    281            if (puart == UART3)
    282            {
    283              uartnum = 0; /* UART 3 */
    284            }
    285            else if (puart == UART4)
    286            {
    287              uartnum = 1; /* UART 4 */
    288            }
    289            else if (puart == UART5)
    290            {
    291              uartnum = 2; /* UART 5 */
    292            }
    293            else if (puart == UART6)
    294            {
    295              uartnum = 3; /* UART 6 */
    296            }
    297          
    298            return uartnum;
    299          }
    300          
    301          /***********************************************************************
    302           *
    303           * Function: uart_flush_fifos
    304           *
    305           * Purpose: Flushes one or both of the UART FIFOs
    306           *
    307           * Processing:
    308           *     See function.
    309           *
    310           * Parameters:
    311           *     pregs     : Pointer to a UART register base
    312           *     flushword : Masked flush value
    313           *
    314           * Outputs: None
    315           *
    316           * Returns: Nothing
    317           *
    318           * Notes: None
    319           *
    320           **********************************************************************/
    321          void Uart_flush_fifos(UART_REGS_T *pregs,
    322                                UNS_32 flushword)
    323          {
    324            volatile UNS_32 tmp;
    325          
    326            pregs->iir_fcr = (flushword | (UART_FCR_TXFIFO_FLUSH |
    327                                            UART_FCR_RXFIFO_FLUSH));
    328          
    329            /* An extra read of the RX FIFO (even if empty) will also clear any
    330               pending RX interrupts */
    331            tmp = pregs->dll_fifo;
    332          }
    333          
    334          /***********************************************************************
    335           *
    336           * Function: uart_find_clk
    337           *
    338           * Purpose: Determines best dividers to get a target clock rate
    339           *
    340           * Processing:
    341           *     See function.
    342           *
    343           * Parameters:
    344           *     uartnum : UART number (0..3) for UARTS (3..6)
    345           *     freq    : Desired UART baud rate
    346           *     divs    : Structure to place dividers to get rate into
    347           *
    348           * Outputs: None
    349           *
    350           * Returns: Actual UART baud rate
    351           *
    352           * Notes: None
    353           *
    354           **********************************************************************/
    355          UNS_32 Uart_find_clk(UNS_32 freq,
    356                               UART_CLKDIV_T *divs)
    357          {
    358            UNS_32 clkrate, savedclkrate, diff, basepclk;
    359            INT_32 idxx, idyy;
    360            UART_CLKDIV_T div;
    361          
    362            /* Get the clock rate for the UART block */
    363            basepclk = clkpwr_get_base_clock_rate(CLKPWR_PERIPH_CLK) >> 4;
    364          
    365            /* Find the best divider */
    366            div.divx = div.divy = 0;
    367            savedclkrate = 0;
    368            diff = 0xFFFFFFFF;
    369            for (idxx = 1; idxx < 0xFF; idxx++)
    370            {
    371              for (idyy = idxx; idyy < 0xFF; idyy++)
    372              {
    373                clkrate = (basepclk * idxx) / idyy;
    374                if (Uart_abs(clkrate, freq) < diff)
    375                {
    376                  diff = Uart_abs(clkrate, freq);
    377                  savedclkrate = clkrate;
    378                  div.divx = idxx;
    379                  div.divy = idyy;
    380                }
    381              }
    382            }
    383          
    384            /* Saved computed dividers */
    385            divs->divx = div.divx;
    386            divs->divy = div.divy;
    387          
    388            return savedclkrate;
    389          }
    390          
    391          /***********************************************************************
    392           *
    393           * Function: uart_setup_trans_mode
    394           *
    395           * Purpose: Sets up a UART data transfer mode
    396           *
    397           * Processing:
    398           *     See function.
    399           *
    400           * Parameters:
    401           *     puartcfg   : Pointer to UART configuration data
    402           *     puartsetup : Pointer to a UART transfer mode setup structure
    403           *
    404           * Outputs: None
    405           *
    406           * Returns: _NO_ERROR if setup was ok, otherwise _ERROR
    407           *
    408           * Notes: None
    409           *
    410           **********************************************************************/
    411          STATUS Uart_setup_trans_mode(UART_CFG_T *puartcfg,
    412                                       UART_CONTROL_T *puartsetup)
    413          {
    414            UNS_32 tmp32, tmp = 0;
    415            STATUS err = _NO_ERROR;
    416          
    417            /* Setup stop bits */
    418            switch (puartsetup->stopbits)
    419            {
    420              case 2:
    421                tmp |= UART_LCR_STOP2BITS;
    422              case 1:
    423                break;
    424          
    425              default:
    426                err = _ERROR;
    427                break;
    428            }
    429          
    430            /* Setup parity */
    431            switch (puartsetup->parity)
    432            {
    433              case UART_PAR_EVEN:
    434                tmp |= (UART_LCR_PARITY_EVEN | UART_LCR_PARITY_ENABLE);
    435                break;
    436          
    437              case UART_PAR_ODD:
    438                tmp |= (UART_LCR_PARITY_ODD | UART_LCR_PARITY_ENABLE);
    439                break;
    440          
    441              case UART_PAR_NONE:
    442                break;
    443          
    444              default:
    445                err = _ERROR;
    446                break;
    447            }
    448          
    449            /* Setup data bits */
    450            switch (puartsetup->databits)
    451            {
    452              case 5:
    453                tmp |= UART_LCR_WLEN_5BITS;
    454                break;
    455          
    456              case 6:
    457                tmp |= UART_LCR_WLEN_6BITS;
    458                break;
    459          
    460              case 7:
    461                tmp |= UART_LCR_WLEN_7BITS;
    462                break;
    463          
    464              case 8:
    465                tmp |= UART_LCR_WLEN_8BITS;
    466                break;
    467          
    468              default:
    469                err = _ERROR;
    470                break;
    471            }
    472          
    473            if (err == _NO_ERROR)
    474            {
    475              /* Find closest baud rate for desired clock frequency */
    476              puartcfg->baudrate = Uart_find_clk(puartsetup->baud_rate,
    477                                                 &puartcfg->divs);
    478          
    479              /* Set clock x/y divider for the UART */
    480              switch (puartcfg->uartnum)
    481              {
    482                case 0:
    483                  CLKPWR->clkpwr_uart3_clk_ctrl =
    484                    CLKPWR_UART_X_DIV(puartcfg->divs.divx)
    485                    | CLKPWR_UART_Y_DIV(puartcfg->divs.divy);
    486                  break;
    487          
    488                case 1:
    489                  CLKPWR->clkpwr_uart4_clk_ctrl =
    490                    CLKPWR_UART_X_DIV(puartcfg->divs.divx)
    491                    | CLKPWR_UART_Y_DIV(puartcfg->divs.divy);
    492                  break;
    493          
    494                case 2:
    495                  CLKPWR->clkpwr_uart5_clk_ctrl =
    496                    CLKPWR_UART_X_DIV(puartcfg->divs.divx)
    497                    | CLKPWR_UART_Y_DIV(puartcfg->divs.divy);
    498                  break;
    499          
    500                case 3:
    501                default:
    502                  CLKPWR->clkpwr_uart6_clk_ctrl =
    503                    CLKPWR_UART_X_DIV(puartcfg->divs.divx)
    504                    | CLKPWR_UART_Y_DIV(puartcfg->divs.divy);
    505                  break;
    506              }
    507          
    508              /* Use automatic clocking */
    509              tmp32 = UARTCNTL->clkmode &
    510                      UART_CLKMODE_MASK(puartcfg->uartnum + 3);
    511              UARTCNTL->clkmode = tmp32 | UART_CLKMODE_LOAD(
    512                                    UART_CLKMODE_AUTO, (puartcfg->uartnum + 3));
    513          
    514              /* Set new UART settings */
    515              puartcfg->regptr->lcr = tmp;
    516            }
    517          
    518            return err;
    519          }
    520          
    521          /***********************************************************************
    522           * UART driver public functions
    523           **********************************************************************/
    524          
    525          /***********************************************************************
    526           *
    527           * Function: uart_open
    528           *
    529           * Purpose: Open the UART
    530           *
    531           * Processing:
    532           *     See function.
    533           *
    534           * Parameters:
    535           *     ipbase: Pointer to a UART peripheral block
    536           *     arg   : Pointer to UART setup structure or NULL
    537           *
    538           * Outputs: None
    539           *
    540           * Returns: The pointer to a UART config structure or NULL
    541           *
    542           * Notes: None
    543           *
    544           **********************************************************************/
    545          INT_32 Uart_open(void *ipbase,
    546                           INT_32 arg)
    547          {
    548            UART_CONTROL_T uarttran;
    549            volatile UNS_32 tmp;
    550            INT_32 uartnum, tptr = (INT_32) NULL;
    551            UART_CONTROL_T *pucfg = (UART_CONTROL_T *) arg;
    552          
    553            /* Try to find a matching UART number based on the passed pointer */
    554            uartnum = Uart_ptr_to_uart_num((UART_REGS_T *) ipbase);
    555            if (uartnum >= 0)
    556            {
    557              /* Has the UART been previously initialized? */
    558              if (uartdat[uartnum].uart_init == FALSE)
    559              {
    560                /* UART is free */
    561                uartdat[uartnum].uart_init = TRUE;
    562                uartdat[uartnum].uartnum = uartnum;
    563                uartdat[uartnum].regptr = (UART_REGS_T *) ipbase;
    564          
    565                /* Enable UART system clock */
    566                clkpwr_clk_en_dis(uart_num_to_clk_enum[uartnum], 1);
    567                tmp = UARTCNTL->clkmode & UART_CLKMODE_MASK(uartnum + 3);
    568                UARTCNTL->clkmode = (tmp |
    569                  UART_CLKMODE_LOAD(UART_CLKMODE_AUTO, (uartnum + 3)));
    570          
    571                /* No callbacks by default */
    572                uartdat[uartnum].cbs.rxcb = NULL;
    573                uartdat[uartnum].cbs.txcb = NULL;
    574                uartdat[uartnum].cbs.rxerrcb = NULL;
    575          
    576                /* Install general interrupt handler */
    577                switch (uartnum)
    578                {
    579                  case 0:
    580                    int_install_irq_handler(IRQ_UART_IIR3,
    581                                            Uart3_int_handler);
    582                    break;
    583                  case 1:
    584                    int_install_irq_handler(IRQ_UART_IIR4,
    585                                            Uart4_int_handler);
    586                    break;
    587          
    588                  case 2:
    589                    int_install_irq_handler(IRQ_UART_IIR5,
    590                                            Uart5_int_handler);
    591                    break;
    592          
    593                  case 3:
    594                    int_install_irq_handler(IRQ_UART_IIR6,
    595                                            Uart6_int_handler);
    596                    break;
    597                }
    598          
    599                /* UART baud rate generator isn't used, so just set it to divider
    600                    by 1 */
    601                uartdat[uartnum].regptr->lcr |= UART_LCR_DIVLATCH_EN;
    602                uartdat[uartnum].regptr->dll_fifo = 1;
    603                uartdat[uartnum].regptr->dlm_ier = 0;
    604                uartdat[uartnum].regptr->lcr &= ~UART_LCR_DIVLATCH_EN;
    605          
    606                /* Setup default UART state for 9600N81 with FIFO mode */
    607                if (pucfg == NULL)
    608                {
    609                  uarttran.baud_rate = 9600;
    610                  uarttran.parity = UART_PAR_NONE;
    611                  uarttran.stopbits = 1;
    612                  uarttran.databits = 8;
    613                  Uart_setup_trans_mode(&uartdat[uartnum], &uarttran);
    614                }
    615                else
    616                {
    617                  Uart_setup_trans_mode(&uartdat[uartnum], pucfg);
    618                }
    619          
    620                /* Clear FIFOs, set FIFO level, and pending interrupts */
    621                uartdat[uartnum].regptr->iir_fcr = (UART_FCR_RXFIFO_TL16 |
    622                  UART_FCR_TXFIFO_TL0 | UART_FCR_FIFO_CTRL |
    623                  UART_FCR_FIFO_EN | UART_FCR_TXFIFO_FLUSH |
    624                  UART_FCR_RXFIFO_FLUSH);
    625                tmp = uartdat[uartnum].regptr->dll_fifo;
    626                tmp = uartdat[uartnum].regptr->iir_fcr;
    627                tmp = uartdat[uartnum].regptr->lsr;
    628          
    629                /* Receive,  RX line status, and mode status interrupts enabled */
    630                uartdat[uartnum].regptr->dlm_ier = (UART_IER_MODEM_STS |
    631                                                   UART_IER_RXLINE_STS |
    632                                                   UART_IER_RDA | UART_IER_THRE);
    633          
    634                /* Return pointer to specific UART structure */
    635                tptr = (INT_32) &uartdat[uartnum];
    636              }
    637            }
    638          
    639            return tptr;
    640          }
    641          
    642          /***********************************************************************
    643           *
    644           * Function: uart_close
    645           *
    646           * Purpose: Close the UART
    647           *
    648           * Processing:
    649           *     If init is not TRUE, then return _ERROR to the caller as the
    650           *     device was not previously opened. Otherwise, disable the UART,
    651           *     set init to FALSE, and return _NO_ERROR to the caller.
    652           *
    653           * Parameters:
    654           *     devid: Pointer to UART config structure
    655           *
    656           * Outputs: None
    657           *
    658           * Returns: The status of the close operation
    659           *
    660           * Notes: None
    661           *
    662           **********************************************************************/
    663          STATUS Uart_close(INT_32 devid)
    664          {
    665            volatile UNS_32 tmp;
    666            UART_CFG_T *puart = (UART_CFG_T *) devid;
    667            STATUS status = _ERROR;
    668          
    669            /* Close and disable device if it was previously initialized */
    670            if (puart->uart_init == TRUE)
    671            {
    672              /* Disable interrupts */
    673              puart->regptr->dlm_ier = 0;
    674          
    675              /* Turn off clocking */
    676              tmp = UARTCNTL->clkmode &
    677                    UART_CLKMODE_MASK(puart->uartnum + 3);
    678              UARTCNTL->clkmode = tmp | UART_CLKMODE_LOAD(
    679                                    UART_CLKMODE_OFF, (puart->uartnum + 3));
    680          
    681              /* Free UART and Disable timer system clock */
    682              puart->uart_init = FALSE;
    683              tmp = UARTCNTL->clkmode & UART_CLKMODE_MASK(puart->uartnum + 3);
    684              UARTCNTL->clkmode = (tmp |
    685                  UART_CLKMODE_LOAD(UART_CLKMODE_OFF, (puart->uartnum + 3)));
    686              clkpwr_clk_en_dis(uart_num_to_clk_enum[puart->uartnum], 0);
    687          
    688              status = _NO_ERROR;
    689            }
    690          
    691            return status;
    692          }
    693          
    694          /***********************************************************************
    695           *
    696           * Function: uart_ioctl
    697           *
    698           * Purpose: UART configuration block
    699           *
    700           * Processing:
    701           *     This function is a large case block. Based on the passed function
    702           *     and option values, set or get the appropriate UART parameter.
    703           *
    704           * Parameters:
    705           *     devid: Pointer to UART config structure
    706           *     cmd:   ioctl command
    707           *     arg:   ioctl argument
    708           *
    709           * Outputs: None
    710           *
    711           * Returns: The status of the ioctl operation
    712           *
    713           * Notes: None
    714           *
    715           **********************************************************************/
    716          STATUS Uart_ioctl(INT_32 devid,
    717                            INT_32 cmd,
    718                            INT_32 arg)
    719          {
    720            UART_CBS_T *pcbs;
    721            UART_CFG_T *puart = (UART_CFG_T *) devid;
    722            STATUS status = _ERROR;
    723          
    724            /* Close and disable device if it was previously initialized */
    725            if (puart->uart_init == TRUE)
    726            {
    727              status = _NO_ERROR;
    728          
    729              switch (cmd)
    730              {
    731                case UART_CLEAR_FIFOS:
    732                  Uart_flush_fifos(puart->regptr, (UNS_32) arg);
    733                  break;
    734          
    735                case UART_SETUP_TRANSFER:
    736                  Uart_setup_trans_mode(puart, (UART_CONTROL_T *) arg);
    737                  break;
    738          
    739                case UART_LOOPBACK_EN:
    740                  if (arg != 0)
    741                  {
    742                    UARTCNTL->loop |=
    743                      UART_LPBACK_ENABLED(puart->uartnum + 1);
    744                  }
    745                  else
    746                  {
    747                    UARTCNTL->loop &=
    748                      ~UART_LPBACK_ENABLED(puart->uartnum + 1);
    749                  }
    750                  break;
    751          
    752                case UART_FORCE_BREAK:
    753                  if (arg != 0)
    754                  {
    755                    puart->regptr->lcr |= UART_LCR_BREAK_EN;
    756                  }
    757                  else
    758                  {
    759                    puart->regptr->lcr &= ~UART_LCR_BREAK_EN;
    760                  }
    761                  break;
    762          
    763                case UART_INSTALL_CBS:
    764                  pcbs = (UART_CBS_T *) arg;
    765                  puart->cbs.rxcb = pcbs->rxcb;
    766                  puart->cbs.txcb = pcbs->txcb;
    767                  puart->cbs.rxerrcb = pcbs->rxerrcb;
    768                  break;
    769          
    770                case UART_GET_STATUS:
    771                  /* Return a UART status */
    772                  switch (arg)
    773                  {
    774                    case UART_GET_IP_CLOCK:
    775                      status = clkpwr_get_base_clock_rate(
    776                                 CLKPWR_PERIPH_CLK);
    777                      break;
    778          
    779                    case UART_GET_DERIVED_CLOCK:
    780                      status = puart->baudrate;
    781                      break;
    782          
    783                    case UART_GET_LINE_STATUS:
    784                      status = (STATUS) puart->regptr->lsr;
    785                      break;
    786          
    787                    case UART_GET_MODEM_STATUS:
    788                      status = (STATUS) puart->regptr->modem_status;
    789                      break;
    790          
    791          		  default:
    792                      /* Unsupported parameter */
    793                      status = LPC_BAD_PARAMS;
    794                      break;
    795                  }
    796                  break;
    797          
    798                default:
    799                  /* Unsupported parameter */
    800                  status = LPC_BAD_PARAMS;
    801              }
    802            }
    803          
    804            return status;
    805          }
    806          
    807          /***********************************************************************
    808           *
    809           * Function: uart_read
    810           *
    811           * Purpose: UART read function (stub only)
    812           *
    813           * Processing:
    814           *     Read the passed number of bytes in the passed buffer, or the
    815           *     amount of data that is available, whichever is less.
    816           *
    817           * Parameters:
    818           *     devid:     Pointer to UART descriptor
    819           *     buffer:    Pointer to data buffer to copy to
    820           *     max_bytes: Number of bytes to read
    821           *
    822           * Outputs: None
    823           *
    824           * Returns: Number of bytes actually read
    825           *
    826           * Notes: None
    827           *
    828           **********************************************************************/
    829          INT_32 Uart_read(INT_32 devid,
    830                           void *buffer,
    831                           INT_32 max_bytes)
    832          {
    833            INT_32 bread = 0;
    834            UART_CFG_T *puart = (UART_CFG_T *) devid;
    835            UART_REGS_T *pregs = puart->regptr;
    836            UNS_8 *buff8 = (UNS_8 *) buffer;
    837          
    838            while ((max_bytes > 0) && ((pregs->lsr & UART_LSR_RDR) != 0))
    839            {
    840              *buff8 = (UNS_8) pregs->dll_fifo;
    841              buff8++;
    842              max_bytes--;
    843              bread++;
    844            }
    845          
    846            return bread;
    847          }
    848          
    849          /***********************************************************************
    850           *
    851           * Function: uart_write
    852           *
    853           * Purpose: Timer UART function
    854           *
    855           * Processing:
    856           *     Write the passed number of bytes in the passed buffer to the UART
    857           *     FIFO, or the amounf of data that the FIFO can handle.
    858           *
    859           * Parameters:
    860           *     devid:   Pointer to UART descriptor
    861           *     buffer:  Pointer to data buffer to copy from
    862           *     n_bytes: Number of bytes to write
    863           *
    864           * Outputs: None
    865           *
    866           * Returns: Number of bytes actually written (always 0)
    867           *
    868           * Notes: None
    869           *
    870           **********************************************************************/
    871          INT_32 Uart_write(INT_32 devid,
    872                            void *buffer,
    873                            INT_32 n_bytes)
    874          {
    875            INT_32 bwrite = 0;
    876            UART_CFG_T *puart = (UART_CFG_T *) devid;
    877            UART_REGS_T *pregs = puart->regptr;
    878            UNS_8 *buff8 = (UNS_8 *) buffer;
    879          
    880            /* Only add data if the current FIFO level can be determined */
    881            if ((pregs->lsr & UART_LSR_THRE) != 0)
    882            {
    883              while ((n_bytes > 0) && ((pregs->lsr & UART_LSR_THRE) != 0))
    884              {
    885                pregs->dll_fifo = (UNS_32) * buff8;
    886                buff8++;
    887                n_bytes--;
    888                bwrite++;
    889              }
    890          
    891              /* Since the trip point is at 8 bytes, it's ok to add up to
    892                 8 more bytes of data for transmit */
    893              if (n_bytes > 8)
    894              {
    895                n_bytes = 8;
    896              }
    897              while (n_bytes > 0)
    898              {
    899                pregs->dll_fifo = (UNS_32) * buff8;
    900                buff8++;
    901                n_bytes--;
    902                bwrite++;
    903              }
    904            }
    905          
    906            return bwrite;
    907          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Uart3_int_handler
         8   -> Uart_gen_int_handler
       8   Uart4_int_handler
         8   -> Uart_gen_int_handler
       8   Uart5_int_handler
         8   -> Uart_gen_int_handler
       8   Uart6_int_handler
         8   -> Uart_gen_int_handler
       0   Uart_abs
      24   Uart_close
        24   -> clkpwr_clk_en_dis
      48   Uart_find_clk
        48   -> Uart_abs
        48   -> clkpwr_get_base_clock_rate
        48 __aeabi_uidiv
       4   Uart_flush_fifos
      16   Uart_gen_int_handler
        16   -- Indirect call
      32   Uart_ioctl
        32   -> Uart_flush_fifos
        32   -> Uart_setup_trans_mode
        32   -> clkpwr_get_base_clock_rate
      48   Uart_open
        48   -> Uart_ptr_to_uart_num
        48   -> Uart_setup_trans_mode
        48   -> clkpwr_clk_en_dis
        48   -> int_install_irq_handler
       0   Uart_ptr_to_uart_num
      12   Uart_read
      24   Uart_setup_trans_mode
        24   -> Uart_find_clk
      12   Uart_write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      16  Uart3_int_handler
      16  Uart4_int_handler
      16  Uart5_int_handler
      16  Uart6_int_handler
      24  Uart_abs
     200  Uart_close
     196  Uart_find_clk
      28  Uart_flush_fifos
     200  Uart_gen_int_handler
     396  Uart_ioctl
     672  Uart_open
     120  Uart_ptr_to_uart_num
      72  Uart_read
     440  Uart_setup_trans_mode
     132  Uart_write
       4  uart_num_to_clk_enum
     144  uartdat

 
   144 bytes in section .bss
     4 bytes in section .rodata
 2 596 bytes in section .text
 
 2 596 bytes of CODE  memory
     4 bytes of CONST memory
   144 bytes of DATA  memory

Errors: none
Warnings: none
