###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        15/Oct/2015  14:33:42
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\zonaVRT\isZonaTrianMethodVRT.c
#    Command line =  
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\zonaVRT\isZonaTrianMethodVRT.c"
#        -lcN "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug xRAM\List\" -o
#        "D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\Obj\" --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=ARM926EJ-S -e --fpu=VFP9-S --dlib_config "D:\Program Files\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\Igor\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\component\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\" --interwork
#        --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\List\isZonaTrianMethodVRT.lst
#    Object file  =  
#        D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\Obj\isZonaTrianMethodVRT.o
#
###############################################################################

D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\zonaVRT\isZonaTrianMethodVRT.c
      1          /*
      2          #include <stdio.h>
      3          #include <TCHAR.H >
      4          #include <conio.h>
      5          #include <sys\stat.h>
      6          
      7          #include <fstream.h>
      8          #include <typeinfo.h>
      9          
     10          #include <comctrls.hpp>
     11          
     12          #include <vcl.h>
     13          #include <strstrea.h>
     14          #pragma hdrstop
     15          */
     16          
     17          #include <stdio.h>
     18          #include <string.h>
     19          #include <math.h>
     20          
     21          #include "zonaVRTdef.h"
     22          #include "zonaVRTfnc.h"
     23          
     24          //координаты вершин зоны сработки
     25          extern float X1;
     26          extern float Y1;
     27          
     28          extern float X2;
     29          extern float Y2;
     30          
     31          extern float X3;
     32          extern float Y3;
     33          
     34          //extern float X4;
     35          //extern float Y4;
     36          
     37          extern double  X12V, Y12V, X21V, Y21V, X23V, Y23V, X32V, Y32V;
     38          extern double  /*X34V, Y34V, X41V, Y41V, X43V, Y43V,*/ X31V, Y31V;
     39          extern double  X13V, Y13V;
     40          
     41          //extern double  X14V,    Y14V;
     42          
     43          extern INT_64 X1_64, Y1_64, X2_64, Y2_64, X3_64, Y3_64;//, X4_64, Y4_64;
     44          //координаты вершин зоны возврата
     45          extern INT_64 /*X14V_64, Y14V_64,*/ /*X12V_64, Y12V_64,*/ X21V_64, Y21V_64, /*X23V_64, Y23V_64,*/ X32V_64, Y32V_64;
     46          //extern INT_64 /*X34V_64, Y34V_64,*/// X41V_64, Y41V_64; /*X43V_64, Y43V_64, X31V_64, Y31V_64, X13V_64, Y13V_64;*/
     47          
     48          //нормализованный вектор сработки 34
     49          //extern VectorXY_VRT  nVector34vrt;
     50          //extern VectorXY_64   nVector34_64vrt;
     51          //нормализованный вектор сработки 32
     52          extern VectorXY_VRT  nVector32vrt;
     53          extern VectorXY_64   nVector32_64vrt;
     54          //нормализованный вектор сработки 12
     55          extern VectorXY_VRT  nVector12vrt;
     56          extern VectorXY_64   nVector12_64vrt;
     57          //нормализованный вектор сработки 14
     58          //extern VectorXY_VRT  nVector14vrt;
     59          //extern VectorXY_64   nVector14_64vrt;
     60          
     61          //нормализованный вектор сработки 41
     62          //extern VectorXY_VRT  nVector41vrt;
     63          //extern VectorXY_64   nVector41_64vrt;
     64          //нормализованный вектор сработки 43
     65          //extern VectorXY_VRT  nVector43vrt;
     66          //extern VectorXY_64   nVector43_64vrt;
     67          //нормализованный вектор сработки 23
     68          extern VectorXY_VRT  nVector23vrt;
     69          extern VectorXY_64   nVector23_64vrt;
     70          //нормализованный вектор сработки 21
     71          extern VectorXY_VRT  nVector21vrt;
     72          extern VectorXY_64   nVector21_64vrt;
     73          
     74          extern  VectorXY_64   nVector34_64vrtBD[];//для хранения зон для 5 ступеней
     75          extern  VectorXY_64   nVector32_64vrtBD[];
     76          extern  VectorXY_64   nVector12_64vrtBD[];
     77          extern  VectorXY_64   nVector14_64vrtBD[];
     78          
     79          extern  VectorXY_64   nVector41_64vrtBD[];
     80          extern  VectorXY_64   nVector43_64vrtBD[];
     81          extern  VectorXY_64   nVector23_64vrtBD[];
     82          extern  VectorXY_64   nVector21_64vrtBD[];
     83          //для треугольника
     84           VectorXY_64   nVector31_64vrtBD[10];
     85           VectorXY_64   nVector13_64vrtBD[10];
     86          
     87          //5 ступеней по 2 зоны на 4 точки с 2 коорд XY на сраб и столько же на возврат
     88          extern  INT_64  zonaVertexBD[4 *2 *5 *2*2];//массив вершин
     89          
     90          extern double VozvG;//гистерезис возврата
     91          
     92          //вектор Z
     93          extern INT_64 koordXZ_64;
     94          extern INT_64 koordYZ_64;
     95          
     96          //extern int    spvUSTAVKI[];
     97          
     98          //нормализованный вектор сработки 31
     99           VectorXY_VRT   nVector31vrt;
    100           VectorXY_64    nVector31_64vrt;
    101          //нормализованный вектор сработки 13
    102           VectorXY_VRT  nVector13vrt;
    103           VectorXY_64   nVector13_64vrt;
    104          
    105           INT_64  X13V_64, Y13V_64;
    106          
    107          short isZonaTrianMethodVRT(int numclon)
    108          {
    109            X1_64 = (INT_64)ceil(X1*TO_INTEGER64);
    110            Y1_64 = (INT_64)ceil(Y1*TO_INTEGER64);
    111          
    112            X2_64 = (INT_64)ceil(X2*TO_INTEGER64);
    113            Y2_64 = (INT_64)ceil(Y2*TO_INTEGER64);
    114          
    115            X3_64 = (INT_64)ceil(X3*TO_INTEGER64);
    116            Y3_64 = (INT_64)ceil(Y3*TO_INTEGER64);
    117          
    118            X12V = X1;
    119            Y12V = Y1;
    120          //  X14V = X1;
    121          //  Y14V = Y1;
    122            X21V = X2;
    123            Y21V = Y2;
    124            X23V = X2;
    125            Y23V = Y2;
    126            X32V = X3;
    127            Y32V = Y3;
    128          //  X41V = X4;
    129          //  Y41V = Y4;
    130          //  X34V = X3;
    131          //  Y34V = Y3;
    132          
    133            X31V = X3;
    134            Y31V = Y3;
    135          
    136            X13V = X1;
    137            Y13V = Y1;
    138          
    139            if (controlPoint1VRT()) //контроль 1-й точки
    140            {
    141              return ERROR_1_POINT;//true;//уйти с ошибкой
    142            }
    143          //  errorZona = false;//ошибка расположения вершин зоны
    144            if (controlPoint3TrianVRT()) //контроль 3-й точки
    145            {
    146          //    ControlLabel->Caption = "ОШИБКА 3 точки!";
    147          //    sendText("visualView W1");
    148          //    errorZona = true;//ошибка расположения вершин зоны
    149            //  return true;//уйти с ошибкой
    150              return ERROR_3_POINT;//true;//уйти с ошибкой
    151            }//if
    152          
    153            if (controlPoint2VRT()) //контроль 2-й точки
    154            {
    155          //    ControlLabel->Caption = "ОШИБКА 2 точки!";
    156          //    sendText("visualView W1");
    157          //    errorZona = true;//ошибка расположения вершин зоны
    158          //    return true;//уйти с ошибкой
    159              return ERROR_2_POINT;//true;//уйти с ошибкой
    160            }//if
    161          
    162          //************** НОРМАЛИЗОВАННЫЕ ВЕКТОРА СРАБОТКИ *************
    163          //нормализованный вектор комплекта A
    164            double tmpLen = makeNormalVectorVRT(X3, Y3,//опорная точка
    165                                                X1, Y1,//нижний вектор
    166                                                &nVector31vrt);//нормализованный вектор 31
    167          //целочисленный вариант
    168            nVector31_64vrt.xVect_64 = (INT_64)ceil(nVector31vrt.xVect*TO_INTEGER64);
    169            nVector31_64vrt.yVect_64 = (INT_64)ceil(nVector31vrt.yVect*TO_INTEGER64);
    170          //  X1_64 = (INT_64)ceil(X1*TO_INTEGER64);
    171          //  Y1_64 = (INT_64)ceil(Y1*TO_INTEGER64);
    172          
    173            if (tmpLen<MIN_STORONA)
    174            {
    175          //    ControlLabel->Caption = "ОШИБКА Короткая сторона 31!";
    176          //    sendText("visualView W1");
    177          //    return true;//уйти с ошибкой
    178              return ERROR_31_STORONA;//true;//уйти с ошибкой
    179            }//if
    180          
    181          //нормализованный вектор комплекта A
    182            tmpLen = makeNormalVectorVRT(X3, Y3,//опорная точка
    183                                         X2, Y2,//верхний вектор
    184                                         &nVector32vrt);//нормализованный вектор 32
    185          //целочисленный вариант
    186            nVector32_64vrt.xVect_64 = (INT_64)ceil(nVector32vrt.xVect*TO_INTEGER64);
    187            nVector32_64vrt.yVect_64 = (INT_64)ceil(nVector32vrt.yVect*TO_INTEGER64);
    188          //  X3_64 = (INT_64)ceil(X3*TO_INTEGER64);
    189          //  Y3_64 = (INT_64)ceil(Y3*TO_INTEGER64);
    190          
    191            if (tmpLen<MIN_STORONA)
    192            {
    193          //    ControlLabel->Caption = "ОШИБКА Короткая сторона 32!";
    194            //  sendText("visualView W1");
    195              //return true;//уйти с ошибкой
    196              return ERROR_32_STORONA;//true;//уйти с ошибкой
    197            }//if
    198          
    199            int   raz = 0;
    200          //  float tempShift;
    201          
    202          //  X3S1Edit->Text = ugolString(makeUgolVector(&nVector31));//угол сработки
    203          //  X3S2Edit->Text = ugolString(makeUgolVector(&nVector32));//угол сработки
    204          //  X4S1Edit->Text = "Сраб";//угол сработки
    205          //  X4S2Edit->Text = "Сраб";//угол сработки
    206          
    207            double tmpUgol1  = makeUgolVectorVRT(&nVector32vrt);
    208            double tempShift = splitUgolSVRT(tmpUgol1, &raz);//наклон сторон
    209          
    210            makeVozvPointVRT(32, tempShift, raz);//нарисовать сторону возврата
    211          
    212            double tmpUgol2  = makeUgolVectorVRT(&nVector31vrt);
    213            tempShift = splitUgolSVRT(tmpUgol2, &raz);//наклон сторон
    214            makeVozvPointVRT(34, tempShift, raz);//нарисовать сторону возврата
    215          
    216          //  char  LocTxt[200];
    217          
    218            double diff = tmpUgol1 - tmpUgol2;
    219            char  tmp1=0;
    220            if (diff>=MAX_UGOL) tmp1=1;//errorZona = true;//ошибка расположения вершин зоны
    221            if (diff<0 && (diff=(diff+360.0))>MAX_UGOL) tmp1=1;//errorZona = true;//ошибка расположения вершин зоны
    222          //  sprintf(LocTxt,  "t3= %5.3f", diff);
    223          //  TestLabel3->Caption = LocTxt;
    224          
    225            if (tmp1) //контроль 3-й точки
    226            {
    227          //    ControlLabel->Caption = "ОШИБКА Угол в точке 3!";
    228          //    sendText("visualView W1");
    229          //    return true;//уйти с ошибкой
    230              return ERROR_3_UGOL;//true;//уйти с ошибкой
    231            }//if
    232          
    233          //нормализованный вектор комплекта A
    234            tmpLen = makeNormalVectorVRT(X1, Y1,//опорная точка
    235                                         X2, Y2,//нижний вектор
    236                                         &nVector12vrt);//нормализованный вектор 12
    237          //целочисленный вариант
    238            nVector12_64vrt.xVect_64 = (INT_64)ceil(nVector12vrt.xVect*TO_INTEGER64);
    239            nVector12_64vrt.yVect_64 = (INT_64)ceil(nVector12vrt.yVect*TO_INTEGER64);
    240          //  X2_64 = (INT_64)ceil(X2*TO_INTEGER64);
    241          //  Y2_64 = (INT_64)ceil(Y2*TO_INTEGER64);
    242          
    243          
    244            if (tmpLen<MIN_STORONA)
    245            {
    246          //    ControlLabel->Caption = "ОШИБКА Короткая сторона 12!";
    247          //    sendText("visualView W1");
    248          //    return true;//уйти с ошибкой
    249              return ERROR_12_STORONA;//уйти с ошибкой
    250            }//if
    251          
    252          //нормализованный вектор комплекта A
    253            makeNormalVectorVRT(X1, Y1,//опорная точка
    254                                X3, Y3,//верхний вектор
    255                                &nVector13vrt);//нормализованный вектор 13
    256          //целочисленный вариант
    257            nVector13_64vrt.xVect_64 = (INT_64)ceil(nVector13vrt.xVect*TO_INTEGER64);
    258            nVector13_64vrt.yVect_64 = (INT_64)ceil(nVector13vrt.yVect*TO_INTEGER64);
    259          
    260          //  X1S1Edit->Text = ugolString(makeUgolVector(&nVector13));//угол сработки
    261          //  X1S2Edit->Text = ugolString(makeUgolVector(&nVector12));//угол сработки
    262          
    263            tmpUgol1 = makeUgolVectorVRT(&nVector13vrt);
    264            tmpUgol2 = makeUgolVectorVRT(&nVector12vrt);
    265            tempShift = splitUgolSVRT(tmpUgol2, &raz);//наклон сторон
    266            makeVozvPointVRT(12, tempShift, raz);//нарисовать сторону возврата
    267          
    268            diff = tmpUgol1 - tmpUgol2;
    269            if (diff>=MAX_UGOL) tmp1=1;//errorZona = true;//ошибка расположения вершин зоны
    270            if (diff<0 && (diff=(diff+360.0))>MAX_UGOL) tmp1=1;//errorZona = true;//ошибка расположения вершин зоны
    271          //  sprintf(LocTxt,  "t1= %5.3f", diff);
    272          //  TestLabel1->Caption = LocTxt;
    273          
    274            if (tmp1) //контроль 1-й точки
    275            {
    276          //    ControlLabel->Caption = "ОШИБКА Угол в точке 1!";
    277          //    sendText("visualView W1");
    278          //    return true;//уйти с ошибкой
    279              return ERROR_1_UGOL;//уйти с ошибкой
    280            }//if
    281          
    282          //  TestLabel4->Caption = "t4= OFF";
    283          
    284          //нормализованный вектор 23
    285            makeNormalVectorVRT(X2, Y2,//опорная точка
    286                                X3, Y3,//вектор
    287                                &nVector23vrt);//нормализованный вектор 23
    288          //целочисленный вариант
    289            nVector23_64vrt.xVect_64 = (INT_64)ceil(nVector23vrt.xVect*TO_INTEGER64);
    290            nVector23_64vrt.yVect_64 = (INT_64)ceil(nVector23vrt.yVect*TO_INTEGER64);
    291          
    292          //нормализованный вектор 21
    293            makeNormalVectorVRT(X2, Y2,//опорная точка
    294                                X1, Y1,//вектор
    295                                &nVector21vrt);//нормализованный вектор 21
    296          //целочисленный вариант
    297            nVector21_64vrt.xVect_64 = (INT_64)ceil(nVector21vrt.xVect*TO_INTEGER64);
    298            nVector21_64vrt.yVect_64 = (INT_64)ceil(nVector21vrt.yVect*TO_INTEGER64);
    299          
    300          //  X2S1Edit->Text = ugolString(makeUgolVector(&nVector21));//угол сработки
    301          //  X2S2Edit->Text = ugolString(makeUgolVector(&nVector23));//угол сработки
    302          
    303            diff = makeUgolVectorVRT(&nVector21vrt) - makeUgolVectorVRT(&nVector23vrt);
    304            if (diff>=MAX_UGOL) tmp1=1;//errorZona = true;//ошибка расположения вершин зоны
    305            if (diff<0 && (diff=(diff+360.0))>MAX_UGOL) tmp1=1;//errorZona = true;//ошибка расположения вершин зоны
    306          //  sprintf(LocTxt,  "t2= %5.3f", diff);
    307          //  TestLabel2->Caption = LocTxt;
    308          
    309            if (tmp1) //контроль 2-й точки
    310            {
    311          //    ControlLabel->Caption = "ОШИБКА Угол в точке 2!";
    312          //    sendText("visualView W1");
    313          //    return true;//уйти с ошибкой
    314              return ERROR_2_UGOL;//уйти с ошибкой
    315            }//if
    316          
    317          //исследовать все стороны возврата
    318            LineXY_VRT lineV32_23, lineV12_21, lineV31_13;
    319            makeLineVVRT(X32V, Y32V, X23V, Y23V, &lineV32_23);//исследовать сторону возврата
    320            makeLineVVRT(X31V, Y31V, X13V, Y13V, &lineV31_13);//исследовать сторону возврата
    321            makeLineVVRT(X12V, Y12V, X21V, Y21V, &lineV12_21);//исследовать сторону возврата
    322          
    323            VectorXY_VRT vXY1, vXY2;
    324          
    325            vXY1.xVect = X32V;
    326            vXY1.yVect = Y32V;
    327            vXY2.xVect = X31V;
    328            vXY2.yVect = Y31V;
    329          
    330            VectorXY_VRT tempXY =
    331            makeVozvCrossPointVRT(&vXY1, &vXY2, &lineV32_23, &lineV31_13);//вычислить возврат
    332            X32V = tempXY.xVect;
    333            Y32V = tempXY.yVect;
    334            X31V = X32V;//tempXY.xVect;
    335            Y31V = Y32V;//tempXY.yVect;
    336          //целочисленный вариант
    337            X32V_64 = (INT_64)ceil(X32V*TO_INTEGER64);
    338            Y32V_64 = (INT_64)ceil(Y32V*TO_INTEGER64);
    339          //  X31V_64 = X32V_64;
    340          //  Y31V_64 = Y32V_64;
    341          
    342            vXY1.xVect = X32V;
    343            vXY1.yVect = Y32V;
    344            vXY2.xVect = X12V;
    345            vXY2.yVect = Y12V;
    346            tempXY =
    347            makeVozvCrossPointVRT(&vXY1, &vXY2, &lineV32_23, &lineV12_21);//вычислить возврат
    348            X21V = tempXY.xVect;
    349            Y21V = tempXY.yVect;
    350            X23V = X21V;//tempXY.xVect;
    351            Y23V = Y21V;//tempXY.yVect;
    352          //целочисленный вариант
    353            X21V_64 = (INT_64)ceil(X21V*TO_INTEGER64);
    354            Y21V_64 = (INT_64)ceil(Y21V*TO_INTEGER64);
    355          //  X23V_64 = X21V_64;
    356          //  Y23V_64 = Y21V_64;
    357          
    358            vXY1.xVect = X12V;
    359            vXY1.yVect = Y12V;
    360            vXY2.xVect = X13V;
    361            vXY2.yVect = Y13V;
    362            tempXY =
    363            makeVozvCrossPointVRT(&vXY1, &vXY2, &lineV12_21, &lineV31_13);
    364            X12V = tempXY.xVect;
    365            Y12V = tempXY.yVect;
    366            X13V = X12V;//tempXY.xVect;
    367            Y13V = Y12V;//tempXY.yVect;
    368          //целочисленный вариант
    369          //  X12V_64 = (INT_64)ceil(X12V*TO_INTEGER64);
    370          //  Y12V_64 = (INT_64)ceil(Y12V*TO_INTEGER64);
    371            X13V_64 = (INT_64)ceil(X12V*TO_INTEGER64);
    372            Y13V_64 = (INT_64)ceil(Y12V*TO_INTEGER64);
    373          //  X13V_64 = X12V_64;
    374          //  Y13V_64 = Y12V_64;
    375          
    376          //сохранить массив вершин
    377           int ii=0;
    378           zonaVertexBD[numclon*16 + ii++] = X1_64;//0//4 *2 *5];//массив вершин
    379           zonaVertexBD[numclon*16 + ii++] = Y1_64;//0//4 *2 *5];//массив вершин
    380          
    381           zonaVertexBD[numclon*16 + ii++] = X2_64;//0//4 *2 *5];//массив вершин
    382           zonaVertexBD[numclon*16 + ii++] = Y2_64;//0//4 *2 *5];//массив вершин
    383          
    384           zonaVertexBD[numclon*16 + ii++] = X3_64;//0//4 *2 *5];//массив вершин
    385           zonaVertexBD[numclon*16 + ii++] = Y3_64;//0//4 *2 *5];//массив вершин
    386           ii++;
    387           ii++;
    388          // zonaVertexBD[numclon*16 + ii++] = X4_64;//0//4 *2 *5];//массив вершин
    389          // zonaVertexBD[numclon*16 + ii++] = Y4_64;//0//4 *2 *5];//массив вершин
    390          
    391          // zonaVertexBD[numclon*16 + ii++] = X14V_64;//0//4 *2 *5];//массив вершин
    392          // zonaVertexBD[numclon*16 + ii++] = Y14V_64;//0//4 *2 *5];//массив вершин
    393          //для треугольника
    394           zonaVertexBD[numclon*16 + ii++] = X13V_64;//0//4 *2 *5];//массив вершин
    395           zonaVertexBD[numclon*16 + ii++] = Y13V_64;//0//4 *2 *5];//массив вершин
    396          //
    397           zonaVertexBD[numclon*16 + ii++] = X21V_64;//0//4 *2 *5];//массив вершин
    398           zonaVertexBD[numclon*16 + ii++] = Y21V_64;//0//4 *2 *5];//массив вершин
    399          
    400           zonaVertexBD[numclon*16 + ii++] = X32V_64;//0//4 *2 *5];//массив вершин
    401           zonaVertexBD[numclon*16 + ii++] = Y32V_64;//0//4 *2 *5];//массив вершин
    402          
    403          //сохранить нормализ вектора
    404          //для хранения зон для 5 ступеней
    405          // memcpy(&(nVector34_64vrtBD[numclon]), &nVector34_64vrt, sizeof(VectorXY_64));
    406           memcpy(&(nVector32_64vrtBD[numclon]), &nVector32_64vrt, sizeof(VectorXY_64));
    407           memcpy(&(nVector12_64vrtBD[numclon]), &nVector12_64vrt, sizeof(VectorXY_64));
    408          // memcpy(&(nVector14_64vrtBD[numclon]), &nVector14_64vrt, sizeof(VectorXY_64));
    409          
    410          // memcpy(&(nVector41_64vrtBD[numclon]), &nVector41_64vrt, sizeof(VectorXY_64));
    411          // memcpy(&(nVector43_64vrtBD[numclon]), &nVector43_64vrt, sizeof(VectorXY_64));
    412           memcpy(&(nVector23_64vrtBD[numclon]), &nVector23_64vrt, sizeof(VectorXY_64));
    413           memcpy(&(nVector21_64vrtBD[numclon]), &nVector21_64vrt, sizeof(VectorXY_64));
    414          //для треугольника
    415           memcpy(&(nVector31_64vrtBD[numclon]), &nVector31_64vrt, sizeof(VectorXY_64));
    416           memcpy(&(nVector13_64vrtBD[numclon]), &nVector13_64vrt, sizeof(VectorXY_64));
    417          
    418            return 0;//false;
    419          }//isNewZonaTrianMethod()
    420          
    421          char controlPoint3TrianVRT()
    422          {
    423          //контроль 3-й точки
    424            if ((X1-X3)<0.0) return 1;//true;//ОШИБКА
    425            return 0;//false;
    426          }//controlPoint3TrianVRT()
    427          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   controlPoint3TrianVRT
     248   isZonaTrianMethodVRT
       248   -> __aeabi_d2lz
       248   -> __aeabi_memcpy
       248   -> ceil
       248   -> controlPoint1VRT
       248   -> controlPoint2VRT
       248   -> controlPoint3TrianVRT
       248   -> makeLineVVRT
       248   -> makeNormalVectorVRT
       248   -> makeUgolVectorVRT
       248   -> makeVozvCrossPointVRT
       248   -> makeVozvPointVRT
       248   -> splitUgolSVRT


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_11
       4  ??DataTable1_12
       4  ??DataTable1_13
       4  ??DataTable1_14
       4  ??DataTable1_15
       4  ??DataTable1_16
       4  ??DataTable1_17
       4  ??DataTable1_18
       4  ??DataTable1_19
       4  ??DataTable1_2
       4  ??DataTable1_20
       4  ??DataTable1_21
       4  ??DataTable1_22
       4  ??DataTable1_23
       4  ??DataTable1_24
       4  ??DataTable1_25
       4  ??DataTable1_26
       4  ??DataTable1_27
       4  ??DataTable1_28
       4  ??DataTable1_29
       4  ??DataTable1_3
       4  ??DataTable1_30
       4  ??DataTable1_31
       4  ??DataTable1_32
       4  ??DataTable1_33
       4  ??DataTable1_34
       4  ??DataTable1_35
       4  ??DataTable1_36
       4  ??DataTable1_37
       4  ??DataTable1_38
       4  ??DataTable1_39
       4  ??DataTable1_4
       4  ??DataTable1_40
       4  ??DataTable1_41
       4  ??DataTable1_42
       4  ??DataTable1_43
       4  ??DataTable1_44
       4  ??DataTable1_45
       4  ??DataTable1_46
       4  ??DataTable1_47
       4  ??DataTable1_48
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
       8  X13V_64
       8  Y13V_64
      48  controlPoint3TrianVRT
    3320  isZonaTrianMethodVRT
      16  nVector13_64vrt
     160  nVector13_64vrtBD
      16  nVector13vrt
      16  nVector31_64vrt
     160  nVector31_64vrtBD
      16  nVector31vrt

 
   400 bytes in section .bss
 3 564 bytes in section .text
 
 3 564 bytes of CODE memory
   400 bytes of DATA memory

Errors: none
Warnings: none
