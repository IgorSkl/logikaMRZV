###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Oct/2015  12:12:01
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\psuperVisor\psupervisor.c
#    Command line =  
#        "D:\IAR projects\HR1_0100_00_I720_new2\psuperVisor\psupervisor.c" -lcN
#        "D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\List\" -o
#        "D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --interwork --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\List\psupervisor.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\Obj\psupervisor.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\psuperVisor\psupervisor.c
      1          /*
      2          #include <vcl.h>
      3          #include <strstrea.h>
      4          #include <math.h>
      5          #include <mem.h>
      6          #include <fstream.h>
      7          #include <strstrea.h>
      8          #include <iomanip.h>
      9          #pragma hdrstop
     10          
     11          #include "vmenuDis.h"
     12          */
     13          
     14          #include <stdio.h>
     15          #include <string.h>
     16          
     17          #include "psuperVisor\supermanager.h"
     18          
     19          #include "bazisdef.h"
     20          #include "virtualMenu\rangmanagerdef.h"
     21          #include "component\componentdef.h"
     22          #include "logictimers\logictimersdef.h"
     23          #include "virtualMenu\systemmenudef.h"
     24          #include "virtualMenu\repozitdef.h"
     25          
     26          #include "logictimers\logictimersfnc.h"
     27          #include "psuperVisor\psvisor_helpfnc.h"
     28          #include "virtualMenu\ustmanagerfnc.h"
     29          #include "virtualMenu\rangmanagerfnc.h"
     30          #include "virtualMenu\repozitfnc.h"
     31          
     32          #include "psupervisor\psupervisor.h"
     33          
     34          #include "toSpeedOptim.h"
     35          
     36          #include "..\bazis.h"
     37          
     38          extern ELEMENT_RPZ   rpzCOMPONENT[];//репозитарий
     39          extern ELEMENT_RPZ  rpzCOMPONENT_WL[];
     40          extern COMPONENT_OBJ rpzcomponent_obj;//обект компонента для репозитария
     41          extern UNS_32 ArrayRANGIR[];
     42          extern UNS_32 ArrayWIDELOG[];
     43          extern int  elTrgOldTimer[];
     44          extern int  elTrgOutTimer[];
     45          //лог массив запуска таймеров
     46          extern int  logMassTimer[];
     47          
     48          extern int  elTrgOldTimer_WL[];
     49          extern int  elTrgOutTimer_WL[];
     50          //лог массив запуска таймеров
     51          extern int  logMassTimer_WL[];
     52          extern int  timerEnableWL;//разрешение работы таймеров РЛ
     53          
     54          //конфигурация
     55          COMPONENT_OBJ        cnfCOMPONENT[MAX_CNFCOMPONENT];
     56          //конфигурация РЛ
     57          COMPONENT_OBJ        cnfCOMPONENT_WL[MAX_WLCOMPONENT];
     58          //теневой массив
     59          IONAMESTATUS_RANGIR  common_shadow[SIZE_RANGIRCMD+SIZE_RANGIRCMD+2];
     60          
     61          //текущие уставки супервизора
     62          int    spvUSTAVKI[MAX_SPVUSTAVKI];
     63          //текущие уставки супервизора РЛ
     64          int    spvUSTAVKI_WL[MAX_SPVUSTAVKI_WL];
     65          //temp логика
     66          int   tempLog[MAX_TEMPLOG];
     67          //temp логика РЛ
     68          int   tempLog_WL[MAX_TEMPLOG_WL];
     69          //ENA команды
     70          int   ENAcmd[MAX_ENACMD];
     71          //ENA команды РЛ
     72          int   ENAcmd_WL[MAX_ENACMD_WL];
     73          
     74          int  IndexTIMERS;//таймерный индекс
     75          int  IndexIO;//индекс IO
     76          int  IndexUstSPV;//индекс уставок в супервизоре
     77          int  IndexTLog;//индекс temp логики
     78          int  IndexENA;//индекс ENA команд
     79          UNS_32 maskaReleBO;
     80          UNS_32 maskaReleBV;
     81          
     82          //неисправность цепей напр 
     83          int  isFAILU_COMMON_MTZ;
     84          int  isFAILU_COMMON_DZ;
     85          int  isFAILU_DZ;
     86          //напр UCM меньше UCM005
     87          //int  isFAILUCM005_COMMON;
     88          //ток ICM  меньше ICM005
     89          //int  isFAILICM005_COMMON;
     90          //допуски ДВ обработки
     91          int  ddv_inc[DV_TOTAL];
     92          int  ddv_fix[DV_TOTAL];
     93          
     94          /**********************************************
     95          СУПЕРВИЗОР
     96          Инициализация уставок компонентов из конфиг
     97          total - INITUST_NULLCOMP-ни одного
     98                  INITUST_TOPCOMP-инит верхний комп
     99          **********************************************/
    100          void INITustrangCOMPONENT(short total)
    101          {
    102            short result = 0;
    103            short next   = 0;
    104            short tmp = 0;
    105            short tmpCntUst = 0;
    106            cnfCOMPONENT[0].offsetUstMng = 0;//смещение уставок внутри менеджера уст
    107            IndexUstSPV  = 0;//индекс уставок в супервизоре
    108          
    109            while (cnfCOMPONENT[next].componentEnable)   //все компоненты в конфигурации
    110            {
    111              cnfCOMPONENT[next].offsetUstSpv = IndexUstSPV;//смещение уставок супервизора
    112              switch(total)
    113              {
    114              case INITUST_TOPCOMP:   //инит верхний комп
    115              {
    116                if(next==0)
    117                {
    118                  tmpCntUst = cnfCOMPONENT[next].cntUstMng = cnfCOMPONENT[next].initUstMng(1);
    119                  if(tmpCntUst>0)MngUstTopAddUSTAVKI(tmpCntUst);//добавить уставки на вершину mngUst
    120                  MngRangTopAddNameStatusRANGIR(cnfCOMPONENT[next].cntIOCmd, cnfCOMPONENT[next].nameStatusIO);//добавить команды на вершину mngRang
    121                  tmp = cnfCOMPONENT[next].cntTLCmd;
    122                  if(tmp>0)TopAddTEMPLOGIC(tmp);//добавить TL log на вершину tempLog
    123                  tmp = cnfCOMPONENT[next].cntENACmd;
    124                  if(tmp>0)TopAddENACmd(tmp);//добавить ENA на вершину
    125                  for(short i=0; i<UVV_TOTAL; i++)
    126                  {
    127                    MngRangTopAddQuadroRANGIR(&(ArrayRANGIR[i*DQUADRO]), cnfCOMPONENT[next].cntIOCmd);
    128                  }//for
    129                }//if
    130                else
    131                  //уставки не инициализировать
    132                  tmpCntUst = cnfCOMPONENT[next].cntUstMng = cnfCOMPONENT[next].initUstMng(0);
    133              }//case
    134              break;
    135          
    136          //    case  INITUST_NULLCOMP:
    137                //уставки не инициализировать
    138            //    tmpCnt = cnfCOMPONENT[next].cntUstMng = cnfCOMPONENT[next].initUstMng(0);
    139              //  break;
    140          
    141              default:
    142                //уставки не инициализировать
    143                tmpCntUst = cnfCOMPONENT[next].cntUstMng = cnfCOMPONENT[next].initUstMng(0);
    144          
    145              }//switch
    146          
    147              result += tmpCntUst;//смещение внутри менеджера уст
    148              if(cnfCOMPONENT[next+1].componentEnable)
    149                cnfCOMPONENT[next+1].offsetUstMng = result;//смещение внутри менеджера уст
    150              next++;
    151            }//while
    152          }//INITustCOMPONENT(short total)
    153          
    154          /**********************************************
    155          СУПЕРВИЗОР
    156          Инициализация уставок компонентов из конфиг РЛ
    157          total - INITUST_NULLCOMP-ни одного
    158                  INITUST_TOPCOMP-инит верхний комп
    159          **********************************************/
    160          void INITustrangCOMPONENT_WL(short total)
    161          {
    162            short result = 0;
    163            short next   = 0;
    164            short tmpCnt = 0;
    165            cnfCOMPONENT_WL[0].offsetUstMng = 0;//смещение уставок внутри менеджера уст
    166            IndexUstSPV  = 0;//индекс уставок в супервизоре
    167          
    168            while (cnfCOMPONENT_WL[next].componentEnable)   //все компоненты в конфигурации
    169            {
    170              cnfCOMPONENT_WL[next].offsetUstSpv = IndexUstSPV;//смещение уставок супервизора
    171              switch(total)
    172              {
    173              case INITUST_TOPCOMP:   //инит верхний комп
    174              {
    175                if(next==0)
    176                {
    177                  tmpCnt = cnfCOMPONENT_WL[next].cntUstMng = cnfCOMPONENT_WL[next].initUstMng(1);
    178                  if(tmpCnt>0)MngUstTopAddUSTAVKI_WL(tmpCnt);//добавить уставки на вершину mngUst
    179                  //добавить имена команд на вершину 
    180                  MngRangTopAddNameStatusRANGIR_WL(cnfCOMPONENT_WL[next].cntIOCmd, cnfCOMPONENT_WL[next].nameStatusIO);
    181                  tmpCnt = cnfCOMPONENT_WL[next].cntTLCmd;
    182                  if(tmpCnt>0)TopAddTEMPLOGIC_WL(tmpCnt);//добавить TL log на вершину tempLog
    183                  tmpCnt = cnfCOMPONENT_WL[next].cntENACmd;
    184                  if(tmpCnt>0)TopAddENACmd_WL(tmpCnt);//добавить ENA на вершину
    185                  //пересчитать PRM MINUS PLUS
    186                  for(short i=0; i<3*LE_TOTAL; i++)
    187                  {
    188                    //вторая половина 2*DQUADRO от PRM MINUS PLUS
    189                    MngRangTopAddQuadroRANGIR(&(ArrayWIDELOG[i*2*DQUADRO +DQUADRO]), cnfCOMPONENT_WL[next].cntIOCmd);
    190                  }//for
    191                }//if
    192                else
    193                  //уставки не инициализировать
    194                  tmpCnt = cnfCOMPONENT_WL[next].cntUstMng = cnfCOMPONENT_WL[next].initUstMng(0);
    195              }//case
    196              break;
    197          
    198          //    case  INITUST_NULLCOMP:
    199                //уставки не инициализировать
    200            //    tmpCnt = cnfCOMPONENT[next].cntUstMng = cnfCOMPONENT[next].initUstMng(0);
    201              //  break;
    202          
    203              default:
    204                //уставки не инициализировать
    205                tmpCnt = cnfCOMPONENT_WL[next].cntUstMng = cnfCOMPONENT_WL[next].initUstMng(0);
    206          
    207              }//switch
    208          
    209              result += tmpCnt;//смещение внутри менеджера уст
    210              if(cnfCOMPONENT_WL[next+1].componentEnable)
    211                cnfCOMPONENT_WL[next+1].offsetUstMng = result;//смещение внутри менеджера уст
    212              next++;
    213            }//while
    214          }//INITustCOMPONENT_WL(short total)
    215          
    216          /**********************************************
    217          СУПЕРВИЗОР
    218          Инициализация IO команд компонентов из конфиг
    219          **********************************************/
    220          void INITIOCmdCOMPONENT()
    221          {
    222            IndexIO     = 0;//IO индекс
    223            short tmp = 0;
    224            while (cnfCOMPONENT[tmp].componentEnable)
    225            {
    226              cnfCOMPONENT[tmp].offsetIOCmd = IndexIO;//смещение IO
    227              cnfCOMPONENT[tmp].cntIOCmd = cnfCOMPONENT[tmp].initIOCmd();//к-во IO
    228              tmp++;
    229            }//while
    230          }//INITIOCmdCOMPONENT()
    231          
    232          /**********************************************
    233          СУПЕРВИЗОР
    234          Инициализация IO команд компонентов из конфиг РЛ
    235          **********************************************/
    236          void INITIOCmdCOMPONENT_WL()
    237          {
    238            IndexIO     = 0;//IO индекс
    239            short tmp = 0;
    240            while (cnfCOMPONENT_WL[tmp].componentEnable)
    241            {
    242              cnfCOMPONENT_WL[tmp].offsetIOCmd = IndexIO;//смещение IO
    243              cnfCOMPONENT_WL[tmp].cntIOCmd = cnfCOMPONENT_WL[tmp].initIOCmd();//к-во IO
    244              tmp++;
    245            }//while
    246          }//INITIOCmdCOMPONENT_WL()
    247          
    248          /**********************************************
    249          СУПЕРВИЗОР
    250          Инициализация TL команд компонентов из конфиг
    251          **********************************************/
    252          void INITTLCmdCOMPONENT()
    253          {
    254            IndexTLog     = 0;//TL индекс
    255            short tmp = 0;
    256            while (cnfCOMPONENT[tmp].componentEnable)
    257            {
    258              cnfCOMPONENT[tmp].offsetTLCmd = IndexTLog;
    259              cnfCOMPONENT[tmp].cntTLCmd = cnfCOMPONENT[tmp].initTLCmd();
    260              tmp++;
    261            }//while
    262          }//INITTLCmdCOMPONENT()
    263          
    264          /**********************************************
    265          СУПЕРВИЗОР
    266          Инициализация TL команд компонентов из конфиг РЛ
    267          **********************************************/
    268          void INITTLCmdCOMPONENT_WL()
    269          {
    270            IndexTLog     = 0;//TL индекс
    271            short tmp = 0;
    272            while (cnfCOMPONENT_WL[tmp].componentEnable)
    273            {
    274              cnfCOMPONENT_WL[tmp].offsetTLCmd = IndexTLog;
    275              cnfCOMPONENT_WL[tmp].cntTLCmd = cnfCOMPONENT_WL[tmp].initTLCmd();
    276              tmp++;
    277            }//while
    278          }//INITTLCmdCOMPONENT_WL()
    279          
    280          /**********************************************
    281          СУПЕРВИЗОР
    282          Инициализация ENA команд компонентов из конфиг
    283          **********************************************/
    284          void INITENACmdCOMPONENT()
    285          {
    286            IndexENA  = 0;//ENA индекс
    287            short tmp = 0;
    288            while (cnfCOMPONENT[tmp].componentEnable)
    289            {
    290              cnfCOMPONENT[tmp].offsetENACmd = IndexENA;
    291              cnfCOMPONENT[tmp].cntENACmd = cnfCOMPONENT[tmp].initENACmd();
    292              tmp++;
    293            }//while
    294          }//INITENACmdCOMPONENT()
    295          
    296          /**********************************************
    297          СУПЕРВИЗОР
    298          Инициализация ENA команд компонентов из конфиг РЛ
    299          **********************************************/
    300          void INITENACmdCOMPONENT_WL()
    301          {
    302            IndexENA  = 0;//ENA индекс
    303            short tmp = 0;
    304            while (cnfCOMPONENT_WL[tmp].componentEnable)
    305            {
    306              cnfCOMPONENT_WL[tmp].offsetENACmd = IndexENA;
    307              cnfCOMPONENT_WL[tmp].cntENACmd = cnfCOMPONENT_WL[tmp].initENACmd();
    308              tmp++;
    309            }//while
    310          }//INITENACmdCOMPONENT_WL()
    311          
    312          /**********************************************
    313          СУПЕРВИЗОР
    314          Подготовка уставок супервизора для комп из конфиг
    315          **********************************************/
    316          void PREPAREustCOMPONENT(short total)
    317          {
    318            short next = 0;
    319            setTimerENABLE(0 ,0);//bazisTimerMem[0].ENABLE = 0;//запретить лог таймера
    320            while (cnfCOMPONENT[next].componentEnable)   //все компоненты в конфигурации
    321            {
    322              switch(total)
    323              {
    324              case INITUST_ALLCOMP:   //Подготовка уставок все комп
    325                  {
    326                  cnfCOMPONENT[next].prepareUstSpv(next);
    327                  }
    328                  break;
    329          
    330          //    case  INITUST_NULLCOMP:
    331                //уставки не инициализировать
    332            //    break;
    333              default:
    334                ;
    335              }//switch
    336              next++;
    337            }//while
    338          
    339            //переопределить уставки конкр компонента
    340            if(total>=INITUST_TOPCOMP)
    341            {
    342              cnfCOMPONENT[total].prepareUstSpv(total);
    343              //Инициализация таймеров всех компонентов из конфиг
    344            }//if
    345          
    346          }//PREPAREustCOMPONENT()
    347          
    348          /**********************************************
    349          СУПЕРВИЗОР
    350          Подготовка уставок супервизора для комп из конфиг РЛ
    351          **********************************************/
    352          void PREPAREustCOMPONENT_WL(short total)
    353          {
    354            short next = 0;
    355            setTimerENABLE_WL(0 ,0);//bazisTimerMem[0].ENABLE = 0;//запретить лог таймера РЛ
    356            while (cnfCOMPONENT_WL[next].componentEnable)   //все компоненты в конфигурации
    357            {
    358              switch(total)
    359              {
    360              case INITUST_ALLCOMP:   //Подготовка уставок все комп
    361                  {
    362                  cnfCOMPONENT_WL[next].prepareUstSpv(-next-1);
    363                  }
    364                  break;
    365          
    366          //    case  INITUST_NULLCOMP:
    367                //уставки не инициализировать
    368            //    break;
    369              default:
    370                ;
    371              }//switch
    372              next++;
    373            }//while
    374          
    375            //переопределить уставки конкр компонента
    376            if(total>=INITUST_TOPCOMP)
    377            {
    378              cnfCOMPONENT_WL[total].prepareUstSpv(-total-1);
    379              //Инициализация таймеров всех компонентов из конфиг
    380            }//if
    381          
    382          }//PREPAREustCOMPONENT_WL()
    383          
    384          /**********************************************
    385          СУПЕРВИЗОР
    386          Добавить компонент в конфигурацию
    387          numK - код компонента
    388          **********************************************/
    389          void addCOMPONENT(short numK)
    390          {
    391          //массив клонов - конфигурация
    392            short rpzOffset = GetOffsetClonRpz(numK);//получить смещение репозитария по коду компонента
    393          
    394            LIGHTISDENIE = 0;//запрещено
    395            LIGHTISPACKET = 0;//это пакет
    396          //копировать в тень
    397            memcpy((void*)getShadowBuf(), cnfCOMPONENT, sizeof(COMPONENT_OBJ)*MAX_CNFCOMPONENT);
    398            //создать новый клон
    399            char isPacket = rpzCOMPONENT[rpzOffset].load2RPZ(0);//зарегистрировать в репозитарии
    400            if(isPacket)
    401            {
    402              LIGHTISDENIE = 0;//запрещено
    403              LIGHTISPACKET = 1;//это пакет
    404              return;// 1;//уйти если пакетная регистрация
    405            }//if
    406          
    407            //искать в конфигурации клон компонента
    408            short i=0;
    409            short numC=0;
    410          
    411            while(cnfCOMPONENT[i].componentEnable) //все клоны из конфиг
    412            {
    413              if(cnfCOMPONENT[i].kodC == rpzcomponent_obj.kodC) numC++;
    414              i++;
    415            }//while
    416          
    417            if(numC>0 && rpzcomponent_obj.cntClon == 1)
    418            {
    419              LIGHTISPACKET = 0;//это пакет
    420              LIGHTISDENIE = 1;//запрещено
    421              return;// 1;//разрешен только 1 клон
    422            }//if
    423            if(numC>0 && rpzcomponent_obj.cntClon == numC)
    424            {
    425              LIGHTISPACKET = 0;//это пакет
    426              LIGHTISDENIE = 1;//запрещено
    427              return;//разрешен только numClon клон
    428            }//if
    429          
    430            memcpy(&(cnfCOMPONENT[0]), &rpzcomponent_obj, sizeof(COMPONENT_OBJ));
    431          
    432          //копировать из тени
    433            memcpy(&(cnfCOMPONENT[1]), (void*)getShadowBuf(), sizeof(COMPONENT_OBJ)*(MAX_CNFCOMPONENT-1));
    434          
    435          }//addCOMPONENT
    436          
    437          /**********************************************
    438          СУПЕРВИЗОР
    439          Добавить компонент в конфигурацию РЛ
    440          numK - код компонента
    441          **********************************************/
    442          void addCOMPONENT_WL(short numK)
    443          {
    444          //массив клонов - конфигурация
    445            short rpzOffset = GetOffsetClonRpzWL(numK);//получить смещение репозитария РЛ по коду компонента
    446          
    447            LIGHTISDENIE = 0;//запрещено
    448            LIGHTISPACKET = 0;//это пакет
    449          //копировать в тень
    450            memcpy((void*)getShadowBuf(), cnfCOMPONENT_WL, sizeof(COMPONENT_OBJ)*MAX_WLCOMPONENT);
    451            //создать новый клон
    452            char isPacket = rpzCOMPONENT_WL[rpzOffset].load2RPZ(0);//зарегистрировать в репозитарии РЛ
    453            if(isPacket)
    454            {
    455              LIGHTISDENIE = 0;//запрещено
    456              LIGHTISPACKET = 1;//это пакет
    457              return;// 1;//уйти если пакетная регистрация
    458            }//if
    459          
    460            //искать в конфигурации клон компонента
    461            short i=0;
    462            short numC=0;
    463          
    464            while(cnfCOMPONENT_WL[i].componentEnable) //все клоны из конфиг
    465            {
    466              if(cnfCOMPONENT_WL[i].kodC == rpzcomponent_obj.kodC) numC++;
    467              i++;
    468            }//while
    469          
    470            if(numC>0 && rpzcomponent_obj.cntClon == 1)
    471            {
    472              LIGHTISPACKET = 0;//это пакет
    473              LIGHTISDENIE = 1;//запрещено
    474              return;// 1;//разрешен только 1 клон
    475            }//if
    476            if(numC>0 && rpzcomponent_obj.cntClon == numC)
    477            {
    478              LIGHTISPACKET = 0;//это пакет
    479              LIGHTISDENIE = 1;//запрещено
    480              return;//разрешен только numClon клон
    481            }//if
    482          
    483            memcpy(&(cnfCOMPONENT_WL[0]), &rpzcomponent_obj, sizeof(COMPONENT_OBJ));
    484          
    485          //копировать из тени
    486            memcpy(&(cnfCOMPONENT_WL[1]), (void*)getShadowBuf(), sizeof(COMPONENT_OBJ)*(MAX_WLCOMPONENT-1));
    487          
    488          }//addCOMPONENT_WL
    489          
    490          /**********************************************
    491          СУПЕРВИЗОР
    492          Инициализировать компонент в конфигурации
    493          total - INITUST_TOPCOMP-только верхний INITUST_ALLCOMP-все
    494                  INITUST_NULLCOMP-ни одного
    495          **********************************************/
    496          void initCOMPONENT(short total)
    497          {
    498            INITIOCmdCOMPONENT();//СУПЕРВИЗОР Иниц IO команд компонентов из конфиг
    499            INITTLCmdCOMPONENT();//СУПЕРВИЗОР Иниц TL команд компонентов из конфиг
    500            INITustrangCOMPONENT(total);//СУПЕРВИЗОР Инициализация mngUst mngRang компонентов из конфиг
    501            INITENACmdCOMPONENT();//СУПЕРВИЗОР  Инициализация ENA команд компонентов из конфиг
    502          }//initCOMPONENT(short total)
    503          
    504          /**********************************************
    505          СУПЕРВИЗОР
    506          Инициализировать компонент в конфигурации РЛ
    507          total - INITUST_TOPCOMP-только верхний INITUST_ALLCOMP-все
    508                  INITUST_NULLCOMP-ни одного
    509          **********************************************/
    510          void initCOMPONENT_WL(short total)
    511          {
    512            INITIOCmdCOMPONENT_WL();//СУПЕРВИЗОР Иниц IO команд компонентов из конфиг РЛ
    513            INITTLCmdCOMPONENT_WL();//СУПЕРВИЗОР Иниц TL команд компонентов из конфиг РЛ
    514            INITustrangCOMPONENT_WL(total);//СУПЕРВИЗОР Инициализация mngUst mngRang компонентов из конфиг РЛ
    515            INITENACmdCOMPONENT_WL();//СУПЕРВИЗОР  Инициализация ENA команд компонентов из конфиг РЛ
    516          }//initCOMPONENT_WL(short total)
    517          
    518          /**********************************************
    519          СУПЕРВИЗОР
    520          удалить cntC клонов начиная с подсвеченного клона
    521          **********************************************/
    522          void deleteCOMPONENT(short cntC)
    523          {
    524          //удалить клон компонента
    525            short  offsetUstMng = cnfCOMPONENT[LIGHTCLON].offsetUstMng;  //смещение уставок внутри менеджера уставок
    526            short  offsetRangIO = getOffsetIOCmdCnf(LIGHTCLON);   //смещение команд IO
    527            short  offsetTL     = getOffsetTLCmdCnf(LIGHTCLON);   //смещение команд TL
    528            short  offsetENA    = getOffsetENACmdCnf(LIGHTCLON);  //смещение команд ENA
    529          //найти к-во уставок ранж и TL log для удаления
    530            short  cntUstMng  = 0;
    531            short  cntRangMng = 0;
    532            short  cntTL      = 0;
    533            short  cntENA     = 0;
    534            for(short i=0; i<cntC; i++)
    535            {
    536              cntUstMng  += cnfCOMPONENT[LIGHTCLON+i].cntUstMng;    //количество уставок компонента внутри менеджера уставок
    537              cntRangMng += cnfCOMPONENT[LIGHTCLON+i].cntIOCmd;     //количество команд IO
    538              cntTL      += cnfCOMPONENT[LIGHTCLON+i].cntTLCmd;     //количество команд TL
    539              cntENA     += cnfCOMPONENT[LIGHTCLON+i].cntENACmd;    //количество команд ENA
    540            }//for
    541          
    542          //массив клонов - конфигурация
    543          //копировать в тень
    544            memcpy((void*)getShadowBuf(), cnfCOMPONENT, sizeof(COMPONENT_OBJ)*MAX_CNFCOMPONENT);
    545          //копировать из тени Begin
    546            if(LIGHTCLON>0)
    547              memcpy(cnfCOMPONENT, (void*)getShadowBuf(), sizeof(COMPONENT_OBJ)*(LIGHTCLON));
    548          //копировать из тени End
    549            memcpy(&(cnfCOMPONENT[LIGHTCLON]),
    550                   &(((COMPONENT_OBJ *)getShadowBuf())[LIGHTCLON+ cntC]),
    551                   sizeof(COMPONENT_OBJ)*(MAX_CNFCOMPONENT-LIGHTCLON- cntC));
    552          
    553            if(cntUstMng>0)MngUstDeleteUSTAVKI(offsetUstMng, cntUstMng);//удалить уставки из mngUst
    554            MngRangDeleteNameStatusRANGIR(offsetRangIO, cntRangMng);//удалить команды
    555            if(cntTL>0)DeleteTEMPLOGIC(offsetTL, cntTL);
    556            if(cntENA>0)DeleteENACmd(offsetENA, cntENA);
    557            for(short i=0; i<UVV_TOTAL; i++)
    558            {
    559              MngRangDeleteQuadroRANGIR(&(ArrayRANGIR[i*DQUADRO]), offsetRangIO, cntRangMng);//удалить команды из Quadro
    560            }//for
    561          
    562            initCOMPONENT(INITUST_NULLCOMP);//уставки не инициализировать
    563          }//deleteCOMPONENT()
    564          
    565          /**********************************************
    566          СУПЕРВИЗОР
    567          удалить из РЛ cntC клонов начиная с подсвеченного клона
    568          **********************************************/
    569          void deleteCOMPONENT_WL(short cntC)
    570          {
    571          //удалить клон компонента
    572            short  offsetUstMng = cnfCOMPONENT_WL[LIGHTCLON].offsetUstMng;  //смещение уставок внутри менеджера уставок
    573            short  offsetRangIO = getOffsetIOCmdCnf_WL(LIGHTCLON);   //смещение команд IO
    574            short  offsetTL     = getOffsetTLCmdCnf_WL(LIGHTCLON);   //смещение команд TL
    575            short  offsetENA    = getOffsetENACmdCnf_WL(LIGHTCLON);  //смещение команд ENA
    576          //найти к-во уставок ранж и TL log для удаления
    577            short  cntUstMng  = 0;
    578            short  cntRangMng = 0;
    579            short  cntTL      = 0;
    580            short  cntENA     = 0;
    581            for(short i=0; i<cntC; i++)
    582            {
    583              cntUstMng  += cnfCOMPONENT_WL[LIGHTCLON+i].cntUstMng;    //количество уставок компонента внутри менеджера уставок
    584              cntRangMng += cnfCOMPONENT_WL[LIGHTCLON+i].cntIOCmd;     //количество команд IO
    585              cntTL      += cnfCOMPONENT_WL[LIGHTCLON+i].cntTLCmd;     //количество команд TL
    586              cntENA     += cnfCOMPONENT_WL[LIGHTCLON+i].cntENACmd;    //количество команд ENA
    587            }//for
    588          
    589          //массив клонов - конфигурация
    590          //копировать в тень
    591            memcpy((void*)getShadowBuf(), cnfCOMPONENT_WL, sizeof(COMPONENT_OBJ)*MAX_WLCOMPONENT);
    592          //копировать из тени Begin
    593            if(LIGHTCLON>0)
    594              memcpy(cnfCOMPONENT_WL, (void*)getShadowBuf(), sizeof(COMPONENT_OBJ)*(LIGHTCLON));
    595          //копировать из тени End
    596            memcpy(&(cnfCOMPONENT_WL[LIGHTCLON]),
    597                   &(((COMPONENT_OBJ *)getShadowBuf())[LIGHTCLON+ cntC]),
    598                   sizeof(COMPONENT_OBJ)*(MAX_WLCOMPONENT-LIGHTCLON- cntC));
    599          
    600            if(cntUstMng>0)MngUstDeleteUSTAVKI_WL(offsetUstMng, cntUstMng);//удалить уставки из mngUst
    601            MngRangDeleteNameStatusRANGIR_WL(offsetRangIO, cntRangMng);//удалить команды
    602            if(cntTL>0)DeleteTEMPLOGIC_WL(offsetTL, cntTL);
    603            if(cntENA>0)DeleteENACmd_WL(offsetENA, cntENA);
    604          
    605            initCOMPONENT_WL(INITUST_NULLCOMP);//уставки не инициализировать
    606          }//deleteCOMPONENT_WL()
    607          
    608          void * getShadowBuf()
    609          {
    610            //адрес теневого массива
    611            return &(common_shadow[0]);
    612          }//getShadowBuf()
    613          
    614          void TopAddTEMPLOGIC(short cntTL)
    615          {
    616          //добавить TL log на вершину tempLog
    617            //копировать tempLog в тень
    618            memcpy((void*)getShadowBuf(), tempLog, 4*MAX_TEMPLOG);
    619            //копировать из тени
    620            memcpy(&(tempLog[cntTL]), (void*)getShadowBuf(),
    621                   (4*MAX_TEMPLOG-4*cntTL));
    622            //обнулить
    623            memset(tempLog, 0, 4*cntTL);
    624          }//TopAddTEMPLOGIC()
    625          
    626          void TopAddTEMPLOGIC_WL(short cntTL)
    627          {
    628          //добавить TL log на вершину tempLog_WL
    629            //копировать tempLog_WL в тень
    630            memcpy((void*)getShadowBuf(), tempLog_WL, 4*MAX_TEMPLOG_WL);
    631            //копировать из тени
    632            memcpy(&(tempLog_WL[cntTL]), (void*)getShadowBuf(),
    633                   (4*MAX_TEMPLOG_WL-4*cntTL));
    634            //обнулить
    635            memset(tempLog_WL, 0, 4*cntTL);
    636          }//TopAddTEMPLOGIC_WL()
    637          
    638          void TopAddENACmd(short cntENA)
    639          {
    640          //добавить ENA на вершину ENAcmd
    641            //копировать tempLog в тень
    642            memcpy((void*)getShadowBuf(), ENAcmd, 4*MAX_ENACMD);
    643            //копировать из тени
    644            memcpy(&(ENAcmd[cntENA]), (void*)getShadowBuf(),
    645                   (4*MAX_ENACMD-4*cntENA));
    646            //обнулить
    647            memset(ENAcmd, 0, 4*cntENA);
    648          }//TopAddENACmd(short cntENA)
    649          
    650          void TopAddENACmd_WL(short cntENA)
    651          {
    652          //добавить ENA на вершину ENAcmd
    653            //копировать в тень
    654            memcpy((void*)getShadowBuf(), ENAcmd_WL, 4*MAX_ENACMD_WL);
    655            //копировать из тени
    656            memcpy(&(ENAcmd_WL[cntENA]), (void*)getShadowBuf(),
    657                   (4*MAX_ENACMD_WL-4*cntENA));
    658            //обнулить
    659            memset(ENAcmd_WL, 0, 4*cntENA);
    660          }//TopAddENACmd_WL(short cntENA)
    661          
    662          void DeleteTEMPLOGIC(short offsetTL, short cntTL)
    663          {
    664          //удалить команды TL log
    665            //копировать широкий ком массив в тень
    666            memcpy((void*)getShadowBuf(), tempLog, 4*MAX_TEMPLOG);
    667          //копировать из тени Begin
    668            if(offsetTL>0)
    669              memcpy(tempLog, (void*)getShadowBuf(), 4*offsetTL);
    670          //копировать из тени End
    671            memcpy(&(tempLog[offsetTL]),
    672                   &(((char *)getShadowBuf())[4*offsetTL+4*cntTL]),
    673                   (4*MAX_TEMPLOG-4*offsetTL-4*cntTL));
    674          }//DeleteTEMPLOGIC(short offsetTL, short cntTL)
    675          
    676          void DeleteTEMPLOGIC_WL(short offsetTL, short cntTL)
    677          {
    678          //удалить команды TL log РЛ
    679            //копировать широкий ком массив в тень
    680            memcpy((void*)getShadowBuf(), tempLog_WL, 4*MAX_TEMPLOG_WL);
    681          //копировать из тени Begin
    682            if(offsetTL>0)
    683              memcpy(tempLog_WL, (void*)getShadowBuf(), 4*offsetTL);
    684          //копировать из тени End
    685            memcpy(&(tempLog_WL[offsetTL]),
    686                   &(((char *)getShadowBuf())[4*offsetTL+4*cntTL]),
    687                   (4*MAX_TEMPLOG_WL-4*offsetTL-4*cntTL));
    688          }//DeleteTEMPLOGIC_WL(short offsetTL, short cntTL)
    689          
    690          void DeleteENACmd(short offsetENA, short cntENA)
    691          {
    692          //удалить команды ENA cmd
    693            //копировать ENA cmd в тень
    694            memcpy((void*)getShadowBuf(), ENAcmd, 4*MAX_ENACMD);
    695          //копировать из тени Begin
    696            if(offsetENA>0)
    697              memcpy(ENAcmd, (void*)getShadowBuf(), 4*offsetENA);
    698          //копировать из тени End
    699            memcpy(&(ENAcmd[offsetENA]),
    700                   &(((char *)getShadowBuf())[4*offsetENA+4*cntENA]),
    701                   (4*MAX_ENACMD-4*offsetENA-4*cntENA));
    702          }//DeleteENACmd(short offsetENA, short cntENA)
    703          
    704          void DeleteENACmd_WL(short offsetENA, short cntENA)
    705          {
    706          //удалить команды ENA cmd
    707            //копировать ENA cmd в тень
    708            memcpy((void*)getShadowBuf(), ENAcmd_WL, 4*MAX_ENACMD_WL);
    709          //копировать из тени Begin
    710            if(offsetENA>0)
    711              memcpy(ENAcmd_WL, (void*)getShadowBuf(), 4*offsetENA);
    712          //копировать из тени End
    713            memcpy(&(ENAcmd_WL[offsetENA]),
    714                   &(((char *)getShadowBuf())[4*offsetENA+4*cntENA]),
    715                   (4*MAX_ENACMD_WL-4*offsetENA-4*cntENA));
    716          }//DeleteENACmd_WL(short offsetENA, short cntENA)
    717          
    718          /**********************************************
    719          СУПЕРВИЗОР
    720          Инициализация таймеров всех компонентов из конфиг
    721          **********************************************/
    722          void INITtimersCOMPONENT()
    723          {
    724            //запретить лог таймера
    725            setTimerENABLE(0 ,0);
    726          // clearTimerLogBuffer
    727            memset(elTrgOldTimer,0,4*MAX_LOGTIMER);//EL триггера
    728            memset(elTrgOutTimer,0,4*MAX_LOGTIMER);//EL триггера
    729            memset(logMassTimer, 0,4*MAX_LOGTIMER);//массив запуска
    730          
    731            IndexTIMERS = 0;//таймерный индекс
    732            short tmp = 0;
    733            while (cnfCOMPONENT[tmp].componentEnable)
    734            {
    735              cnfCOMPONENT[tmp].offsetTimers = IndexTIMERS;
    736              cnfCOMPONENT[tmp].initTimers(tmp);
    737              tmp++;
    738            }//while
    739            setTimerENABLE(IndexTIMERS ,0);//запр последний таймер
    740          }//INITtimersCOMPONENT()
    741          
    742          /**********************************************
    743          СУПЕРВИЗОР
    744          Инициализация таймеров всех компонентов из конфиг РЛ
    745          **********************************************/
    746          void INITtimersCOMPONENT_WL()
    747          {
    748            setTimerENABLE_WL(0 ,0);
    749          // clearTimerLogBuffer
    750            memset(elTrgOldTimer_WL,0,4*MAX_LOGTIMER_WL);//EL триггера
    751            memset(elTrgOutTimer_WL,0,4*MAX_LOGTIMER_WL);//EL триггера
    752            memset(logMassTimer_WL, 0,4*MAX_LOGTIMER_WL);//массив запуска
    753          
    754            timerEnableWL = 0;//разрешение работы таймеров РЛ
    755            IndexTIMERS = 0;//таймерный индекс
    756            short tmp = 0;
    757            while (cnfCOMPONENT_WL[tmp].componentEnable)
    758            {
    759              cnfCOMPONENT_WL[tmp].offsetTimers = IndexTIMERS;
    760              cnfCOMPONENT_WL[tmp].initTimers(-tmp-1);
    761              tmp++;
    762            }//while
    763            setTimerENABLE_WL(IndexTIMERS ,0);//запр последний таймер
    764          }//INITtimersCOMPONENT()
    765          
    766          int getOffsetTimersCnf(int off)
    767          {
    768          //таймера компонента в конфигурации
    769            return cnfCOMPONENT[off].offsetTimers;   
    770          }//getOffsetTimersCnf(int off)
    771          
    772          int getOffsetTimersCnf_WL(int off)
    773          {
    774          //таймера компонента в конфигурации
    775            return cnfCOMPONENT_WL[-off-1].offsetTimers;   
    776          }//getOffsetTimersCnf(int off)
    777          
    778          int getOffsetIOCmdCnf(int off)
    779          {
    780           //IO команды
    781           return cnfCOMPONENT[off].offsetIOCmd;   
    782          }//getOffsetIOCmdCnf(int off)
    783          
    784          int getOffsetIOCmdCnf_WL(int off)
    785          {
    786           //IO команды
    787           return cnfCOMPONENT_WL[off].offsetIOCmd;   
    788          }//getOffsetIOCmdCnf_WL(int off)
    789          
    790          int getOffsetENACmdCnf(int off)
    791          {
    792          //ENA команды
    793            return cnfCOMPONENT[off].offsetENACmd;    
    794          }//getOffsetENACmdCnf(int off)
    795          
    796          int getOffsetENACmdCnf_WL(int off)
    797          {
    798          //ENA команды РЛ
    799            return cnfCOMPONENT_WL[off].offsetENACmd;    
    800          }//getOffsetENACmdCnf_WL(int off)
    801          
    802          int getOffsetTLCmdCnf(int off)
    803          {
    804          //TL команды
    805            return cnfCOMPONENT[off].offsetTLCmd;    
    806          }//getOffsetTLCmdCnf(int off)
    807          
    808          int getOffsetTLCmdCnf_WL(int off)
    809          {
    810          //TL команды
    811            return cnfCOMPONENT_WL[off].offsetTLCmd;    
    812          }//getOffsetTLCmdCnf_WL(int off)
    813          
    814          int getOffsetSPVUstCnf(int off)
    815          {
    816          //уставки SPV
    817            return cnfCOMPONENT[off].offsetUstSpv;    
    818          }//getOffsetSPVUstCnf(int off)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   DeleteENACmd
        24   -> __aeabi_memcpy
        24   -> getShadowBuf
      24   DeleteENACmd_WL
        24   -> __aeabi_memcpy
        24   -> getShadowBuf
      24   DeleteTEMPLOGIC
        24   -> __aeabi_memcpy
        24   -> getShadowBuf
      24   DeleteTEMPLOGIC_WL
        24   -> __aeabi_memcpy
        24   -> getShadowBuf
       8   INITENACmdCOMPONENT
         8   -- Indirect call
       8   INITENACmdCOMPONENT_WL
         8   -- Indirect call
       8   INITIOCmdCOMPONENT
         8   -- Indirect call
       8   INITIOCmdCOMPONENT_WL
         8   -- Indirect call
       8   INITTLCmdCOMPONENT
         8   -- Indirect call
       8   INITTLCmdCOMPONENT_WL
         8   -- Indirect call
      32   INITtimersCOMPONENT
        32   -- Indirect call
        32   -> __aeabi_memset
        32   -> setTimerENABLE
      32   INITtimersCOMPONENT_WL
        32   -- Indirect call
        32   -> __aeabi_memset
        32   -> setTimerENABLE_WL
      32   INITustrangCOMPONENT
        32   -- Indirect call
        32   -> MngRangTopAddNameStatusRANGIR
        32   -> MngRangTopAddQuadroRANGIR
        32   -> MngUstTopAddUSTAVKI
        32   -> TopAddENACmd
        32   -> TopAddTEMPLOGIC
      24   INITustrangCOMPONENT_WL
        24   -- Indirect call
        24   -> MngRangTopAddNameStatusRANGIR_WL
        24   -> MngRangTopAddQuadroRANGIR
        24   -> MngUstTopAddUSTAVKI_WL
        24   -> TopAddENACmd_WL
        24   -> TopAddTEMPLOGIC_WL
      16   PREPAREustCOMPONENT
        16   -- Indirect call
        16   -> setTimerENABLE
      16   PREPAREustCOMPONENT_WL
        16   -- Indirect call
        16   -> setTimerENABLE_WL
      40   TopAddENACmd
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset
        40   -> getShadowBuf
      40   TopAddENACmd_WL
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset
        40   -> getShadowBuf
      40   TopAddTEMPLOGIC
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset
        40   -> getShadowBuf
      40   TopAddTEMPLOGIC_WL
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset
        40   -> getShadowBuf
      48   addCOMPONENT
        48   -- Indirect call
        48   -> GetOffsetClonRpz
        48   -> __aeabi_memcpy
        48   -> getShadowBuf
      48   addCOMPONENT_WL
        48   -- Indirect call
        48   -> GetOffsetClonRpzWL
        48   -> __aeabi_memcpy
        48   -> getShadowBuf
      48   deleteCOMPONENT
        48   -> DeleteENACmd
        48   -> DeleteTEMPLOGIC
        48   -> MngRangDeleteNameStatusRANGIR
        48   -> MngRangDeleteQuadroRANGIR
        48   -> MngUstDeleteUSTAVKI
        48   -> __aeabi_memcpy
        48   -> getOffsetENACmdCnf
        48   -> getOffsetIOCmdCnf
        48   -> getOffsetTLCmdCnf
        48   -> getShadowBuf
        48   -> initCOMPONENT
      48   deleteCOMPONENT_WL
        48   -> DeleteENACmd_WL
        48   -> DeleteTEMPLOGIC_WL
        48   -> MngRangDeleteNameStatusRANGIR_WL
        48   -> MngUstDeleteUSTAVKI_WL
        48   -> __aeabi_memcpy
        48   -> getOffsetENACmdCnf_WL
        48   -> getOffsetIOCmdCnf_WL
        48   -> getOffsetTLCmdCnf_WL
        48   -> getShadowBuf
        48   -> initCOMPONENT_WL
       0   getOffsetENACmdCnf
       0   getOffsetENACmdCnf_WL
       0   getOffsetIOCmdCnf
       0   getOffsetIOCmdCnf_WL
       0   getOffsetSPVUstCnf
       0   getOffsetTLCmdCnf
       0   getOffsetTLCmdCnf_WL
       0   getOffsetTimersCnf
       0   getOffsetTimersCnf_WL
       0   getShadowBuf
       8   initCOMPONENT
         8   -> INITENACmdCOMPONENT
         8   -> INITIOCmdCOMPONENT
         8   -> INITTLCmdCOMPONENT
         8   -> INITustrangCOMPONENT
       8   initCOMPONENT_WL
         8   -> INITENACmdCOMPONENT_WL
         8   -> INITIOCmdCOMPONENT_WL
         8   -> INITTLCmdCOMPONENT_WL
         8   -> INITustrangCOMPONENT_WL


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable14
       4  ??DataTable16
       4  ??DataTable18
       4  ??DataTable21
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable33_10
       4  ??DataTable33_11
       4  ??DataTable33_12
       4  ??DataTable33_13
       4  ??DataTable33_14
       4  ??DataTable33_15
       4  ??DataTable33_16
       4  ??DataTable33_2
       4  ??DataTable33_3
       4  ??DataTable33_4
       4  ??DataTable33_5
       4  ??DataTable33_6
       4  ??DataTable33_7
       4  ??DataTable33_8
       4  ??DataTable33_9
     216  DeleteENACmd
     216  DeleteENACmd_WL
     216  DeleteTEMPLOGIC
     216  DeleteTEMPLOGIC_WL
     800  ENAcmd
     200  ENAcmd_WL
     160  INITENACmdCOMPONENT
     160  INITENACmdCOMPONENT_WL
     160  INITIOCmdCOMPONENT
     160  INITIOCmdCOMPONENT_WL
     160  INITTLCmdCOMPONENT
     160  INITTLCmdCOMPONENT_WL
     256  INITtimersCOMPONENT
     272  INITtimersCOMPONENT_WL
     792  INITustrangCOMPONENT
     800  INITustrangCOMPONENT_WL
       4  IndexENA
       4  IndexIO
       4  IndexTIMERS
       4  IndexTLog
       4  IndexUstSPV
     196  PREPAREustCOMPONENT
     204  PREPAREustCOMPONENT_WL
     152  TopAddENACmd
     152  TopAddENACmd_WL
     152  TopAddTEMPLOGIC
     152  TopAddTEMPLOGIC_WL
     452  addCOMPONENT
     444  addCOMPONENT_WL
    7200  cnfCOMPONENT
    1440  cnfCOMPONENT_WL
   21828  common_shadow
     144  ddv_fix
     144  ddv_inc
     760  deleteCOMPONENT
     672  deleteCOMPONENT_WL
      20  getOffsetENACmdCnf
      20  getOffsetENACmdCnf_WL
      20  getOffsetIOCmdCnf
      20  getOffsetIOCmdCnf_WL
      20  getOffsetSPVUstCnf
      20  getOffsetTLCmdCnf
      20  getOffsetTLCmdCnf_WL
      20  getOffsetTimersCnf
      24  getOffsetTimersCnf_WL
       8  getShadowBuf
      40  initCOMPONENT
      40  initCOMPONENT_WL
       4  isFAILU_COMMON_DZ
       4  isFAILU_COMMON_MTZ
       4  isFAILU_DZ
       4  maskaReleBO
       4  maskaReleBV
    1800  spvUSTAVKI
     400  spvUSTAVKI_WL
    2800  tempLog
     400  tempLog_WL

 
 37 196 bytes in section .bss
  7 680 bytes in section .text
 
  7 680 bytes of CODE memory
 37 196 bytes of DATA memory

Errors: none
Warnings: none
