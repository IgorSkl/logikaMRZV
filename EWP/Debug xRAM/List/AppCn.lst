###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Oct/2015  12:11:55
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  D:\IAR projects\HR1_0100_00_I720_new2\ici\AppCn.c
#    Command line =  
#        "D:\IAR projects\HR1_0100_00_I720_new2\ici\AppCn.c" -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --interwork --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\List\AppCn.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\Obj\AppCn.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\ici\AppCn.c
      1          /*------------------------------------------------------------------------------
      2          * Copyright (c) 2013 - Factory “KyivPrylad”
      3          * 
      4          * Permission to use, copy, modify, and distribute this software for any
      5          * purpose with or without fee is hereby granted, provided that the above
      6          * copyright notice and this permission notice appear in all copies.
      7          * 
      8          * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
      9          * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
     10          * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
     11          * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
     12          * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
     13          * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
     14          * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
     15          * 
     16          *------------------------------------------------------------------------------
     17          *
     18          * Processor       : Lpc_3240
     19          * File Name       : AppCn.c
     20          * Description     : Functions and Data application Layer
     21                              BM BR
     22          
     23          *  Version        : 1.00
     24          *
     25          *       +----- (NEW | MODify | ADD | DELete)
     26          *       |
     27          *  No   |   When       Who                What
     28          *-----+---+----------+------------------+--------------------------------------
     29          * 000  NEW  10/09/13   Markovsky A       Creation
     30          *----------------------------------------------------------------------------*/
     31          #include    "./inc/header.h"
     32          #include "./inc/type_definition_BL.h"
     33          #include    "ApCn.h"
     34          #include    "CTpu.h"
     35          #include    "lpu.h"
     36          #include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_timer_driver.h"
     37          #include    "PrCmn.h"
     38          #include    "MnPrPrt.h"
     39          #include <intrinsics.h>
     40          
     41          
     42          
     43          long lActualPrTrObj;
     44          long timerWaitReqHSU2 = (0);
     45          long timerWaitReqHSU1 = (0);
     46          long timerWaitReqHSU7 = (0);
     47          long timerWaitReqM2m = (0);
     48          long timerWaitReqSpi = (0);
     49          int TestReqTransmitT1;
     50          int TestReqReceiveT1;
     51          
     52          SrcSamplesUnitDsc  holderSrcSamplesUnit = {
     53          {
     54          0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
     55          23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45,
     56           46, 47, 48
     57          
     58          }
     59          };
     60          
     61          //long(*PFL_VL)(void* pv, long lV);
     62          long InitProxyTenPerSamples (void* pv, long lV);
     63          long WorkProxyTenPerSamples (void* pv, long lV);
     64          long ResetProxyTenPerSamples (void* pv, long lV);
     65          long ExecCmdProxyTenPerSamples (void* pv, long lV);
     66          ProxyTenPerSamplesUnitDsc  holderProxyTenPerSamplesUnit = {
     67          {
     68          ID_TEN_PERIOD_SAMPLES_UNIT,
     69          0,0,0,0,0,
     70          (unsigned char*)0,(unsigned char*)0,
     71          //(PFL_VL)0,(PFL_VL)0,(PFL_VL)0,(PFL_VL)0
     72          InitProxyTenPerSamples,ResetProxyTenPerSamples,WorkProxyTenPerSamples,ExecCmdProxyTenPerSamples
     73          },
     74          
     75          // arUchExecCmd[4] = {
     76                             {0,0,0,0},
     77          ///arUchRvParamCmd[32] = {
     78          {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0 } 
     79          };
     80          int TestReqTransmitTenPerSamples;
     81          int TestReqReceiveTenPerSamples;
     82          
     83          ProxyTotMeasUnitDsc  holderProxyTotMeasUnit = {
     84          {
     85          ID_TOTAL_MEAS_UNIT,
     86          0,0,0,0,0,
     87          (unsigned char*)0,(unsigned char*)0,
     88          //(PFL_VL)0,(PFL_VL)0,(PFL_VL)0,(PFL_VL)0
     89          InitProxyTotMeas,ResetProxyTotMeas,WorkProxyTotMeas,ExecCmdProxyTotMeas
     90          },
     91          
     92          // arUchExecCmd[4] = {
     93                             {0,0,0,0},
     94          ///arUchRvParamCmd[32] = {
     95          {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0 } 
     96          };
     97          int TestReqTransmitTotMeas;
     98          int TestReqReceiveTotMeas;
     99          
    100          
    101          int TestReqTransmitT2;
    102          int TestReqReceiveT2;
    103          SrcAPCSUnitDsc   holderSrcAPCSUnit;
    104          
    105          
    106          int TestReqTransmitT3;
    107          int TestReqReceiveT3;
    108          
    109          SrcTest1UnitDsc holderSrcTest1Unit;
    110          static long lMaxTimeOut = 0;
    111          extern long lTmrDisableHSU2;extern unsigned long lTmrHSU2Val;
    112          extern long lDelta ;extern  long lDeltaTmrHSU2;extern  char chEndTransmitHSU2;
    113          
    114          
    115          
    116          
    117          
    118          
    119          
    120          
    121          
    122          
    123          
    124          
    125          
    126          
    127          
    128          void ProcessTransmitEvt(void)   @ "Fast_function"
    129          {
    130          register long i;
    131          unsigned long uVl;
    132          register void *pv;
    133          struct 
    134          	{
    135          
    136          		//char chFld1,chFld2,chFld3,chFld4;
    137          		char chTrCnl1,chTrHSU1,chTrHSU2,chTrHSU7;//chFld2,chFld3,chFld4;
    138          		char chTrM2m,chTrSpi;
    139          		char chRetCode,chBusyChnl;
    140          		unsigned short ushIdObj;
    141          	    //.unsigned char *pUchTR;//
    142          		//void  *pOriginTR, *pOriginTpCn;
    143          		
    144          	} sLV;
    145          sLV.chBusyChnl = 0;sLV.chTrHSU7 = 0;sLV.chTrHSU1 = 0;sLV.chTrHSU2 = 0;uVl = 0;
    146          	pv = (void*)&hldrTpCnState; sLV.chTrM2m = 0;sLV.chTrSpi = 0;
    147          	i = ((StateTpCnDsc*)pv)-> lCapicity_CNL_1;
    148          	//Control then All Channels Full
    149          	if(i<4)
    150          	{
    151          		sLV.chBusyChnl |= 1; 
    152          	}
    153          	//Insert HSU7
    154          	//.i = ((StateTpCnDsc*)pv)-> lCapicity_CNL_2;
    155          	//.if(i<4)
    156          	//.{
    157          	//.	sLV.chBusyChnl |= 2; 
    158          	//.}
    159          	//Add here additional Logic for control another Layer state
    160          	if((sLV.chBusyChnl&3) == 3 )
    161          	goto DecomposeDataCnl2;//return;
    162          	//Transmit on Phys Leyer
    163          	
    164          	
    165          DecomposeDataCnl2:
    166           
    167              //if(lTmrDisableHSU2>lDelta)
    168          	
    169          	if( hldrHSU2LpduTRUnit.uchLpuHSU2State==0)// &&(lTmrAcivatorRawSamples ==0))
    170          	{
    171          		PrepDecompouseSrcSamplesUnitHSU2();
    172          		//PrepDecompouseTotMeasGUnitHSU2();
    173          		PrepDecompouse10PeriodUnitHSU2();
    174          		PrepDecompouseTotMeasUnitHSU2();
    175          		//PrepDecompouseSettingsPrMngHSU2();
    176          		//PrepDecompouseStngTptUnitHSU2();
    177          		//PrepDecompouseYustTptUnitHSU2();
    178          		//PrepDecompouse Xxx Test1Unit
    179          		
    180          		i = ((StateTpCnDsc*)pv)-> uchTpState_CNL_HSU2;
    181          		if (i)
    182          		{
    183          			if (i&(1<<7))//Channel Full
    184          			{
    185          				sLV.chTrHSU2 = 2;//Transmition should start
    186          				
    187          			}
    188          			else
    189          			{
    190          				if(i>=1)//Any Obj Full his data. And you should control TimeOut Wait for Req
    191          				{
    192          					if(timerWaitReqHSU2&0xfffffff8) timerWaitReqHSU2  = 5;//This Temporary Code for Permit Usual Tranmitting
    193          					
    194          					if(timerWaitReqHSU2>0)//timerWaitReq
    195          					timerWaitReqHSU2--;
    196          					if(timerWaitReqHSU2==0)//timerWaitReq==0|| timerWaitReq>= 2000<-Max time waiting Req )
    197          					{
    198          						sLV.chTrHSU2 = 1;//Transmition should start
    199          					}	
    200          				}
    201          			}
    202          			
    203          		
    204          		}
    205          		else
    206          		goto temp_lab;//DecomposeDataCnl1;//return;
    207          		// Transmition data on HSU7
    208          		if(sLV.chTrHSU2)
    209          		{
    210          			//StartTrasmit:
    211          			//if(lTmrDisableHSU2>lDelta)
    212          			ProcessTransmitLpduHSU2();lTmrDisableHSU2 = 0;//lTmrHSU2Val = ((TIMER_CNTR_REGS_T *)TIMER_CNTR0)-> tc;	
    213          			timerWaitReqHSU2 = (-1);//This do for permit start after Curr Samples Ready Now Reset this Timer after first Req RDY
    214          			
    215          		}
    216          temp_lab:		
    217          		//-test  code.if((chEndTransmitHSU2<250)&&(chEndTransmitHSU2>0))
    218          		//-test  code.{if( hldrHSU2LpduTRUnit.uchLpuHSU2State==0) outU2((unsigned char *)&hldrHSU2LpduTRUnit.arUch[0],0x00000043);hldrHSU2LpduTRUnit.uchLpuHSU2State = 1;//.((StateTpCnDsc*)pv)-> uchTpState_CNL_HSU2 += 1;  outU2((unsigned char *)&hldrHSU2LpduTRUnit.arUch[0],0x00000043);//ProcessTransmitLpduHSU2();
    219          		;//-test  code.}
    220          	}
    221          DecomposeDataCnl1:
    222          ;
    223          	if( (hldrHSU1LpduTRUnit.uchLpuHSU1State==0))//&&(lTmrAcivatorRawSamples ==0))
    224          	{
    225          		//PrepDecompouseRawSamplUnitHSU1();//,ProcessTransmitLpduHSU1();
    226          		i = ((StateTpCnDsc*)pv)-> uchTpState_CNL_HSU1;
    227          		if (i)
    228          		{
    229          			if (i&(1<<7))//Channel Full
    230          			{
    231          				sLV.chTrHSU1 = 2;//Transmition should start
    232          				
    233          			}
    234          			else
    235          			{
    236          				if(i>=1)//Any Obj Full his data. And you should control TimeOut Wait for Req
    237          				{
    238          					if(timerWaitReqHSU1>0)//timerWaitReq
    239          					timerWaitReqHSU1--;
    240          					if(timerWaitReqHSU1==0)//timerWaitReq==0|| timerWaitReq>= 2000<-Max time waiting Req )
    241          					{
    242          						sLV.chTrHSU1 = 1;//Transmition should start
    243          					}	
    244          				}
    245          			}
    246          			
    247          		
    248          		}
    249          		else 
    250          		goto DecomposeDataCnl7;
    251          		if(sLV.chTrHSU1)
    252          		{
    253          			//StartTrasmit:
    254          			//if(lTmrDisableHSU2>lDelta)
    255          			//ProcessTransmitLpduHSU1();
    256          			//lTmrDisableHSU1 = 0;//lTmrHSU2Val = ((TIMER_CNTR_REGS_T *)TIMER_CNTR0)-> tc;	
    257          			timerWaitReqHSU1 = (-1);
    258          		}
    259          		
    260          	
    261          	}
    262          
    263          DecomposeDataCnl7:	
    264          ;
    265          /*	PrepDecompouseSrcSamplesUnit();
    266          	
    267          	
    268          	//PrepDecompouse Xxx Test1Unit
    269          	i = ((StateTpCnDsc*)pv)-> uchTpState_CNL_HSU7;
    270          	if (i)
    271          	{
    272          	    if (i&(1<<7))//Channel Full
    273          	    {
    274          		    sLV.chTrHSU7 = 1;//Transmition should start 
    275          		}
    276          		else
    277          		{
    278          		    if(i>1)//Any Obj Full his data
    279          			{
    280          			    sLV.chTrHSU7 = 1;//Transmition should start
    281          			}
    282          		}
    283          		
    284          	
    285          	}
    286          	else
    287          	return;
    288          	// Transmition data on HSU7
    289          	if(sLV.chTrHSU7)
    290          	{
    291          	    ProcessTransmitLpduHSU7();
    292          	
    293          	}
    294          	*/
    295          	
    296          	
    297          	if( hldrM2mLpduTRUnit.uchLpuM2mState==0)
    298          	{
    299          		//PrepDecompouseTotMeasRUnitM2m();
    300          		//PrepDecompouseDiagnostic
    301          		PrepDecompouseAuxStngUnitM2m();
    302          		
    303          		i = ((StateTpCnDsc*)pv)-> uchTpState_CNL_M2m;
    304          		if (i)
    305          		{
    306          			if (i&(1<<7))//Channel Full
    307          			{
    308          				sLV.chTrM2m = 2;//Transmition should start
    309          				
    310          			}
    311          			else
    312          			{
    313          				if(i>=1)//Any Obj Full his data. And you should control TimeOut Wait for Req
    314          				{
    315          					if(timerWaitReqM2m&0xfffffff8) timerWaitReqM2m  = 2;//This Temporary Code for Permit Usual Tranmitting
    316          					
    317          					if(timerWaitReqM2m>0)//timerWaitReq
    318          					timerWaitReqM2m--;
    319          					if(timerWaitReqM2m==0)//timerWaitReq==0|| timerWaitReq>= 2000<-Max time waiting Req )
    320          					{
    321          						sLV.chTrM2m = 1;//Transmition should start
    322          					}	
    323          				}
    324          			}
    325          			
    326          		
    327          		}
    328          		else
    329          		goto EndBlockM2mState;//DecomposeDataCnl1;//return;
    330          		// Transmition data on HSU7
    331          		if(sLV.chTrM2m)
    332          		{
    333          			//StartTrasmit:
    334          			//if(lTmrDisableM2m>lDelta)
    335          			ProcessTransmitLpduM2m();
    336          			//lTmrDisableM2m = 0;//lTmrM2mVal = ((TIMER_CNTR_REGS_T *)TIMER_CNTR0)-> tc;	
    337          			timerWaitReqM2m = (-1);//This do for permit start after Curr Samples Ready Now Reset this Timer after first Req RDY
    338          			
    339          		}
    340          EndBlockM2mState:		
    341              ; 
    342          	}
    343          	;
    344          	
    345          	if( hldrSpiLpduTRUnit.uchLpuSpiState==0)//For Hardware Reason SPI can come to state blocked very long Time control this and try Reset 
    346          	{
    347          		PrepDecompouseTeleMechsUnitSpi();
    348          //		PrepDecompouseApcsUnitSpi();
    349          //		PrepDecompouseGoosAUnitSpi();
    350          		PrepDecompousePrtTblTptUnitSpi();//..PrepDecompousePrtTblTptUnitHSU2();
    351          		PrepDecompouseDiagnUnitSPI();
    352          		PrepDecompouseTotVerInfoUnitHSU2();
    353          		
    354          //		PrepDecompouseGoosAUnitSpi();//Next Iteration
    355          		i = ((StateTpCnDsc*)pv)-> uchTpState_CNL_Spi;
    356          		if (i)
    357          		{
    358          			if (i&(1<<7))//Channel Full
    359          			{
    360          				sLV.chTrSpi = 2;//Transmition should start
    361          				
    362          			}
    363          			else
    364          			{
    365          				if(i>=1)//Any Obj Full his data. And you should control TimeOut Wait for Req
    366          				{
    367          					if(timerWaitReqSpi&0xfffffff8) timerWaitReqSpi  = 5;//This Temporary Code for Permit Usual Tranmitting
    368          					
    369          					if(timerWaitReqSpi>0)//timerWaitReq
    370          					timerWaitReqSpi--;
    371          					if(timerWaitReqSpi==0)//timerWaitReq==0|| timerWaitReq>= 2000<-Max time waiting Req )
    372          					{
    373          						sLV.chTrSpi = 1;//Transmition should start
    374          					}	
    375          				}
    376          			}
    377          			
    378          		
    379          		}
    380          		else
    381          		goto EndBlockSpiState;//DecomposeDataCnl1;//return;
    382          		// Transmition data on HSU7
    383          		if(sLV.chTrSpi)
    384          		{
    385          			//StartTrasmit:
    386          			//if(lTmrDisableSpi>lDelta)
    387          			ProcessTransmitLpduSpi();//<--  ProcessTransmitStubSeqSpi();
    388          			//lTmrDisableSpi = 0;//lTmrSpiVal = ((TIMER_CNTR_REGS_T *)TIMER_CNTR0)-> tc;	
    389          			timerWaitReqSpi = (-1);//This do for permit start after Curr Samples Ready Now Reset this Timer after first Req RDY
    390          			
    391          		}
    392          EndBlockSpiState:
    393          		if(timerWaitReqSpi == 0 || timerWaitReqSpi == (-1)) ProcessTransmitStubSeqSpi();
    394          ;	
    395          	}
    396          	else
    397          	{
    398          		if(lBlockSpiCtr != 0)
    399          		//Decrease Timer SPI Block
    400          		lBlockSpiCtr--;
    401          		else//
    402          		{
    403          			//Call Handler ReInit SPI State
    404          			SpiStallHundler();
    405          		}
    406          	
    407          	}
    408          	
    409          ExitProcessTransmitEvt:	
    410          ;
    411          return;
    412          }
    413          //void ProcessTransmitEvt1(void)
    414          //{
    415          //register long i;
    416          //	//Control then All Channels Full
    417          //	if()
    418          //	{
    419          //	
    420          //	}
    421          //	//Control State Obj if Need Transmit
    422          //	//Process
    423          //	if()
    424          //	{
    425          //		//Control State Channel
    426          //		//If busy - Try another
    427          //		if()
    428          //		{
    429          //			//ProcessTransmit Obj
    430          //			if()
    431          //			{
    432          //				
    433          //			}
    434          //		}
    435          //		//Try another
    436          //		
    437          //	}
    438          //	
    439          //
    440          //}
    441          void PrepDecompouseSrcSamplesUnit(void)
    442          {
    443          register long i,j;
    444          register void *pv;
    445          	pv = (void*)&hldrTpCnState;
    446          	//Control then All Channels Full
    447          	//.if()
    448          	//.{
    449          	//.
    450          	//.}
    451          	//Control State Obj if Need Transmit
    452          	//Process
    453          	if(TestReqTransmitT1)
    454          	{
    455          		//Control State Channel
    456          		i = ((StateTpCnDsc*)pv)-> lCapicity_CNL_HSU7;j = sizeof(SrcSamplesUnitDsc)>>2;
    457          		//If busy - Try another
    458          		if( i > j )//Minimal Size - Stop try transmit
    459          		{
    460          			if (TestReqTransmitT1==START)
    461          			{
    462          				ActivateServTrApCnSamplesCTpuUnit();
    463          				TestReqTransmitT1 = EXEC;
    464          			}
    465          			//ProcessTransmit Obj
    466          			if(TestReqTransmitT1==EXEC)
    467          			{
    468          				i = ServiceTRApCn2((void*)&holderTRSrcSamplesCTpuUnit.TrCnHldr,(void*)&hldrTpCnState);
    469          				if(i &(1<<6))
    470          				{
    471          					TestReqTransmitT1 = TERM;//sLV.chRetCode |= (1<<6);
    472          					
    473          					
    474          				}	
    475          				if(i &(1<<7))//channel Full
    476          				{
    477          					TestReqTransmitT1 = EXEC;//Activate Channel transmition and Set Zapret vizova ses poka ne otrabotaet chanel transmit LPU
    478          					
    479          					//((StateTpCnDsc*)pv)-> 
    480          				}
    481          
    482          				if (TestReqTransmitT1==TERM)
    483          				{
    484          					//.TerminateServiceApCn((void*)& holderSrcSamplesUnit,ID_SRC_SAMPLES_UNIT);
    485          					TestReqTransmitT1 = 0;
    486          				}
    487          			}
    488          		}
    489          		//Try another???
    490          		
    491          	}
    492          	
    493          
    494          }
    495          void PrepDecompouseSrcSamplesUnitHSU2(void)
    496          {
    497          register long i,j;
    498          register void *pv;
    499          	pv = (void*)&hldrTpCnState;
    500          	//Control then All Channels Full
    501          	//.if()
    502          	//.{
    503          	//.
    504          
    505          	//.}
    506          	//Control State Obj if Need Transmit
    507          	//Process
    508          	if(TestReqTransmitT1)
    509          	{
    510          		//Control State Channel
    511          		i = ((StateTpCnDsc*)pv)-> lCapicity_CNL_HSU2;j = sizeof(SrcSamplesUnitDsc)>>2;
    512          		//If busy - Try another
    513          		if( i > j )//Minimal Size - Stop try transmit
    514          		{
    515          			if (TestReqTransmitT1==START)
    516          			{
    517          				ActivateServTrApCnSamplesCTpuUnitHSU2();
    518          				TestReqTransmitT1 = EXEC;
    519          			}
    520          			//ProcessTransmit Obj
    521          			if(TestReqTransmitT1==EXEC)
    522          			{
    523          				i = ServiceTRApCn2((void*)&holderTRSrcSamplesCTpuUnit.TrCnHldr,(void*)&hldrTpCnState);
    524          				if(i &(1<<6))
    525          				{
    526          					TestReqTransmitT1 = TERM;//sLV.chRetCode |= (1<<6);
    527          					
    528          					
    529          				}	
    530          				if(i &(1<<7))//channel Full
    531          				TestReqTransmitT1 = EXEC;//Activate Channel transmition and Set Zapret vizova ses poka ne otrabotaet chanel transmit LPU
    532          
    533          				if (TestReqTransmitT1==TERM)
    534          				{
    535          					//.TerminateServiceApCn((void*)& holderSrcSamplesUnit,ID_SRC_SAMPLES_UNIT);
    536          					TestReqTransmitT1 = 0;
    537          				}
    538          			}
    539          		}
    540          		//Try another???
    541          		
    542          	}
    543          	
    544          
    545          }
    546          
    547          
    548          /*
    549          void ProcessTransmitEvt1(void)
    550          {
    551          register long i;
    552          	
    553          	//	//Control then All Channels Full
    554           	if()
    555           	{
    556          		return;
    557           	}
    558          	//Select Obj
    559          	i = SelectObj();
    560          	//Handle Selected Obj
    561          	HBgnTrSrcSamplesUnit();
    562          	
    563          }
    564          
    565          long SelectObj(void)
    566          {
    567          register long i,j;
    568          register void *pv;
    569          struct 
    570          	{
    571          
    572          		//char chFld1,chFld2,chFld3,chFld4;
    573          		char chRetCode;
    574          		unsigned short ushIdObj;
    575          	    //.unsigned char *pUchTR;//
    576          		//void  *pOriginTR, *pOriginTpCn;
    577          		
    578          	} sLV;
    579          union 
    580              {
    581              	unsigned char   uchAr [4];
    582              	unsigned short  ushAr [2];
    583                  unsigned long   ulVal;
    584              }unnV1;
    585          //Look Param SrcSamplesUnit
    586          	sLV.ushIdObj = 0;
    587          //Look Param SrcTest1Unit
    588          	
    589          	return sLV.ushIdObj;
    590          }
    591          long PrepareDecompouseTrEvt(long lIdObj)
    592          {
    593          
    594          	return 0;//Return Handle Data 
    595          }
    596          
    597          */
    598          long lAmtScanChnlSpiErrors = 0;
    599          long lAmtScanChnlM2mErrors = 0;
    600          
    601          void ProcessReceiveEvt(void)   @ "Fast_function"
    602          {
    603          register long i;
    604          register void *pv;
    605          struct 
    606          	{
    607          
    608          		//char chFld1,chFld2,chFld3,chFld4;
    609          		char chRetCode,chBusyChnl;
    610          		unsigned short ushIdObj;
    611          	    //.unsigned char *pUchTR;//
    612          		//void  *pOriginTR, *pOriginTpCn;
    613          		
    614          	} sLV;
    615          sLV.chBusyChnl = 0;i = 0;
    616          	pv = (void*)&hldrHSU7LpduUnit;
    617          	if( ((RVStateLpuHSU7Dsc*)pv)->uchLpuHSU7State == 1 )
    618          	i = ScanCnl(ID_CNL_HSU7);
    619          	if (i==0 || i==0xff )
    620          	((RVStateLpuHSU7Dsc*)pv)->uchLpuHSU7State = 0;
    621          	else
    622          	{
    623          		;//Handle Error !!!!!!!!!
    624          	}
    625          	pv = (void*)&hldrHSU2LpduUnit;
    626          	if( ((RVStateLpuHSU2Dsc*)pv)->uchLpuHSU2State == 1 )
    627          	i = ScanCnl(ID_CNL_HSU2);
    628          	if (i==0 || i==0xff )
    629          	((RVStateLpuHSU2Dsc*)pv)->uchLpuHSU2State = 0;
    630          	else
    631          	{
    632          		;//Handle Error !!!!!!!!!
    633          	}
    634          	pv = (void*)&hldrM2mLpduUnit;
    635          	if( ((RVStateLpuM2mDsc*)pv)->uchLpuM2mState == 1 )
    636          	i = ScanCnl(ID_CNL_M2M);
    637          	if (i==0 || i==0xff )
    638          	((RVStateLpuM2mDsc*)pv)->uchLpuM2mState = 0;
    639          	else
    640          	{
    641          		lAmtScanChnlM2mErrors++;//Handle Error !!!!!!!!!
    642          		((RVStateLpuM2mDsc*)pv)->uchLpuM2mState = 0;
    643          	}
    644          	pv = (void*)&hldrSpiLpduUnit;
    645          	if( ((RVStateLpuSpiDsc*)pv)->uchLpuSpiState == 1 )
    646          	i = ScanCnlSpi(ID_CNL_SPI);//i = ScanCnl(ID_CNL_SPI);
    647          	if (i==0 || i==0xff )
    648          	((RVStateLpuSpiDsc*)pv)->uchLpuSpiState = 0;
    649          	else
    650          	{
    651          		 lAmtScanChnlSpiErrors++;//Handle Error !!!!!!!!!
    652          		((RVStateLpuSpiDsc*)pv)->uchLpuSpiState = 0;
    653          	}
    654          	
    655          	
    656          	//.if( ((RVStateLpuCn1Dsc*)pv)->uchLpuCn1State )
    657          	//.//ExtractLdcCnl1
    658          	//.ScanCnl1Data();
    659          	
    660          	//Control Process Receive Object Verification
    661          
    662          
    663          
    664          }
    665          
    666          void SamplesRvServCTpuApCnUnit(void);
    667          
    668          void UpdateAppData(void)   @ "Fast_function"
    669          {
    670          //Hundle here All Ses Fix Msg 
    671          	if (TestReqReceiveT1)
    672          	{
    673          		SamplesRvServCTpuApCnUnit();
    674          		
    675          	}
    676          	if(AppReqReceiveTotMeasR)
    677          	{
    678          		TotMeasRRvServCTpuApCnUnit();
    679          	}
    680          }
    681          
    682          void SamplesRvServCTpuApCnUnit(void)
    683          {
    684          register long i,j;
    685          register char *pch;
    686          register void* pv;
    687          //Detect if Data Not Used Update
    688          
    689          
    690          //Copy
    691            pch = (char *)&( holderRVSrcSamplesCTpuUnit.arUchRV);
    692            pv  = (void*)& holderSrcSamplesUnit;
    693            j = sizeof(SrcSamplesUnitDsc);
    694            for (i = 0; i < j; i++)
    695            {
    696               ((char*)pv)[i] = pch[i];
    697            }
    698            //Reset Connect State
    699          //   pv  = (void*)& (holderTRSrcSamplesCTpuUnit.TrCnHldr);
    700             
    701          //.   ((TRBaseCTpuUnitDsc*)pv)->uchBaseTransport  = ID_CNL_HSU7;// If need change
    702          //.   ((TRBaseCTpuUnitDsc*)pv)->uchUsedTransport  = ID_CNL_HSU7;// Logic can ctrl
    703          //.   
    704          //.  
    705          //.   ((TRBaseCTpuUnitDsc*)pv)->ConState   = 0;//Reset Con State
    706          //.   ((TRBaseCTpuUnitDsc*)pv)->SizeAppObj = sizeof(SrcSamplesUnitDsc);
    707          //.   ((TRBaseCTpuUnitDsc*)pv)->IdConObj   = ID_SRC_SAMPLES_UNIT;
    708          //.   ((TRBaseCTpuUnitDsc*)pv)->ulTrCount  = 0;//Reset  counter
    709          //.   ((TRBaseCTpuUnitDsc*)pv)->pUchTR     = (unsigned char*)& holderTRSrcSamplesCTpuUnit.arUchTR;
    710             TestReqReceiveT1 = 0;
    711             //Set Addition data for Use Data
    712             
    713          }
    714          
    715          
    716          
    717          void TestSetup_SrcSamples_ForTransmit(void)
    718          {
    719           TestReqTransmitT1 = START;
    720          hldrTpCnState.uchTpState_CNL_HSU2  += 0;
    721          
    722          /*
    723          hldrTpCnState.uchTpState_CNL_HSU2  = 1;
    724          hldrTpCnState.PayloadLPDU_HSU2     = //SIZE_LPDU_CNL_HSU7
    725          0;//(SIZE_LPCI_FLD_CNL_HSU7+SIZE_LDC_FLD_CNL_HSU7);
    726          hldrTpCnState.lCapicity_CNL_HSU2   = SIZE_LPDU_CNL_HSU2
    727          -(SIZE_LPCI_FLD_CNL_HSU2+SIZE_LDC_FLD_CNL_HSU2+SIZE_CS_FLD_CNL_HSU2+SIZE_TOTAL_LDC );
    728          hldrTpCnState.pUchLpuTR_CNL_HSU2   = (unsigned char*)&hldrHSU2LpduTRUnit.arUch[SIZE_LPCI_FLD_CNL_HSU2+SIZE_LDC_FLD_CNL_HSU2+SIZE_TOTAL_LDC];//DemoStr;
    729          
    730          
    731          
    732          
    733          hldrHSU2LpduTRUnit.uchLpuHSU2State = 0;
    734          //	unsigned char      arUch[SIZE_LPDU_CNL_HSU7];//0   Data  field
    735          
    736          	
    737          hldrHSU2LpduTRUnit.lCapicity  = 0;//
    738          hldrHSU2LpduTRUnit.uchCI      = 0;
    739          hldrHSU2LpduTRUnit.ushSizeLDC = 0;
    740          hldrHSU2LpduTRUnit.lCs        = 0;
    741          */
    742          
    743          
    744          }
    745          
    746          void ExecExistProxyManager(void* pvPrMng)   @ "Fast_function"
    747          {
    748              //register void* pv;
    749          	register long i,j;
    750          	struct 
    751          	{
    752          		unsigned char uChIdxBit ;
    753          		//short shErr;
    754          		//unsigned short ushSizeLDC;
    755          		//unsigned short IdConObj;
    756          		//void *pOriginLDC;
    757          		PFL_VL pfl_vl;
    758          	} sLV;
    759          	//PFL_VL pfl_vl;
    760          	sLV.uChIdxBit = 0;
    761          	
    762          	
    763          	//pv = (void*)&holderProxyTenPerSamplesUnit;
    764          	i = ((ProxyMangerStateDsc*)pvPrMng)-> shPrMngConState;
    765          	
    766          	j = (i&(PM_STT_USING_OCS_MSK)); 
    767          	if (j==0) return;
    768          	
    769          	j = ((i&PM_STT_WORK_OCS_MSK)== 0 )&& (i&(PM_STT_START_OCS_MSK));
    770          	j = (i&(PM_STT_WORK_OCS_MSK));
    771          	j = (i&(PM_STT_START_OCS_MSK));
    772          	if (j)
    773          	sLV.uChIdxBit =  PM_STT_START_OCS_ONB;
    774          	j =  (i&(PM_STT_WORK_OCS_MSK)) && ((i&( PM_STT_STOP_OCS_MSK ))==0);
    775          	if (j)
    776          	sLV.uChIdxBit =  PM_STT_WORK_OCS_ONB;
    777          	j = (i&(PM_STT_STOP_OCS_MSK));
    778          	if (j)
    779          	sLV.uChIdxBit =  PM_STT_STOP_OCS_ONB;
    780          	 
    781          	if(sLV.uChIdxBit)
    782          	{
    783          	    i = (long)((ProxyMangerStateDsc*)pvPrMng)-> pf_Work;
    784          		if(i)
    785          		{
    786          			sLV.pfl_vl = (PFL_VL)i;
    787          			i = sLV.pfl_vl(pvPrMng,sLV.uChIdxBit);//sLV.IdConObj);Mow Only One Cmd
    788          		}	
    789          	}
    790          	
    791          
    792          
    793          
    794          }
    795          void ExecExistProxy(void* pvProxy)   @ "Fast_function"
    796          {
    797              //register void* pv;
    798          	register long i,j;
    799          	struct 
    800          	{
    801          		unsigned char uChIdxBit ;
    802          		//short shErr;
    803          		//unsigned short ushSizeLDC;
    804          		//unsigned short IdConObj;
    805          		//void *pOriginLDC;
    806          		PFL_VL pfl_vl;
    807          	} sLV;
    808          	//PFL_VL pfl_vl;
    809          	sLV.uChIdxBit = 0;
    810          	
    811          	
    812          	//pv = (void*)&holderProxyTenPerSamplesUnit;
    813          	i = ((BaseAcpuCMUnitDsc*)pvProxy)-> AppObjConState;
    814          	
    815          	j = (i&(USING_OCS_MSK)); 
    816          	if (j==0) return;
    817          	
    818          	j = ((i&STT_WORK_OCS_MSK)== 0 )&& (i&(STT_START_OCS_MSK));
    819          	j = (i&(STT_WORK_OCS_MSK));
    820          	j = (i&(STT_START_OCS_MSK));
    821          	if (j)
    822          	sLV.uChIdxBit =  STT_START_OCS_ONB;
    823          	j =  (i&(STT_WORK_OCS_MSK)) && ((i&( STT_STOP_OCS_MSK ))==0);
    824          	if (j)
    825          	sLV.uChIdxBit =  STT_WORK_OCS_ONB;
    826          	j = (i&(STT_STOP_OCS_MSK));
    827          	if (j)
    828          	sLV.uChIdxBit =  STT_STOP_OCS_ONB;
    829          	 
    830          	if(sLV.uChIdxBit)
    831          	{
    832          	    i = (long)((BaseAcpuCMUnitDsc*)pvProxy)-> pf_Work;
    833          		if(i)
    834          		{
    835          			sLV.pfl_vl = (PFL_VL)i;
    836          			i = sLV.pfl_vl(pvProxy,sLV.uChIdxBit);//sLV.IdConObj);Mow Only One Cmd
    837          		}	
    838          	}
    839          	
    840          
    841          
    842          
    843          }
    844          void ExecProxy(void)   @ "Fast_function"
    845          {
    846              register void* pv;
    847          	register long i,j;
    848          	struct 
    849          	{
    850          		unsigned char uChIdxBit ;
    851          		//short shErr;
    852          		//unsigned short ushSizeLDC;
    853          		//unsigned short IdConObj;
    854          		//void *pOriginLDC;
    855          		PFL_VL pfl_vl;
    856          	} sLV;
    857          	//PFL_VL pfl_vl;
    858          	sLV.uChIdxBit = 0;
    859          	
    860          	
    861          	pv = (void*)&holderProxyTenPerSamplesUnit;
    862          	ExecExistProxy(pv);
    863          	pv = (void*)&holderProxyTotMeasUnit;
    864          	ExecExistProxy(pv);
    865          	pv = (void*)&hldPrMngPrtTbl;//`hldPrMngYust;
    866          	ExecExistProxyManager(pv);
    867          	
    868          	pv = (void*)&hldPrTrptPrtTbl; //` hldPrTrptYust;
    869          	ExecExistProxy(pv);
    870          	
    871          
    872          }
    873          
    874          #include    "proxy4.c"
    875          #include    "mTotprx.c"
    876          #include    "mTotR.c"
    877          #include    "Apcs.c"
    878          #include    "MnPrPrt.c"
    879          #include    "GoosA.c"
    880          #include    "GoosB.c"
    881          #include    "Tlmc.c"
    882          #include    "verInfo.c"
    883          #include    "fcoil.c"
    884          #include    "atrcmd.c"
    885          
    886          #include    "dt_tm.c"
    887          #include    "AuxStng.c"
    888          #include    "AbnD.c"
    889          
    890          
    891          
    892          
    893          /* EOF */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   ActivateProxyTenPerSamples
        24   -> ActivateRVProxyTenPerSamplesCTpuUnit
      24   ActivateProxyTotMeas
        24   -> ActivateRVProxyTotMeasCTpuUnit
       0   ActivatePrtTblPrMng
       0   ActivatePrtTblRvPrTpt
       0   ActivatePrtTblTrPrTpt
      12   ActivateRVProxyTenPerSamplesCTpuUnit
      12   ActivateRVProxyTotMeasCTpuUnit
       8   ActivateServTrApCnApcsCTpuUnitSpi
         8   -> __aeabi_memcpy4
       0   ActivateServTrApCnAuxStngCTpuUnit
       4   ActivateServTrApCnDiagnCTpuUnitSPI
       8   ActivateServTrApCnGoosACTpuUnitSpi
         8   -> __aeabi_memcpy4
       8   ActivateServTrApCnGoosBCTpuUnitSpi
         8   -> __aeabi_memcpy4
       4   ActivateServTrApCnPrtTblPrMngSpi
       0   ActivateServTrApCnPrtTblTptUnitSpi
       4   ActivateServTrApCnTeleMechsCTpuUnitSpi
       0   ActivateServTrApCnTenPerSamplesUnitHSU2
       8   ActivateServTrApCnTotMeasRCTpuUnitM2m
         8   -> __aeabi_memcpy4
       0   ActivateServTrApCnTotMeasUnitHSU2
       8   ActivateServTrApCnTotVerInfoCTpuUnitSPI
         8   -> strlen
         8   -> strncpy
      40   AlgPrtTblWriteEct
        40   -> ResetAlgPrtTblWrEctDsc
       8   AtrCmdRvServCTpuApCnUnit
         8   -> __aeabi_memcpy
      16   CalcGoosBHldCs
        16   -> Eval_CS
      16   CheckGoosBHldCs
        16   -> Eval_CS
      32   CtrlSendPrtTblEct
        32   -> ResetProxyTransport
       0   DateTimeRvServCTpuApCnUnit
      24   DpcsPrtTblPrMngMsg
        24   -> TryPrtTblActivateExch
       0   ExecCmdProxyTenPerSamples
       0   ExecCmdProxyTotMeas
      32   ExecCmdPrtTblPrTpt
        32   -> Eval_CS
        32   -> TryPrtTblPrMngAlgWrActivate
      24   ExecExistProxy
        24   -- Indirect call
      24   ExecExistProxyManager
        24   -- Indirect call
      16   ExecProxy
        16   -> ExecExistProxy
        16   -> ExecExistProxyManager
      24   ExecPrtTblCmdPrMng
        24   -> AlgPrtTblWriteEct
        24   -> CtrlSendPrtTblEct
        24   -> DpcsPrtTblPrMngMsg
        24   -> WaitPrtTblCmdHmEct
       8   FCoilRvServCTpuApCnUnit
         8   -> __aeabi_memcpy
      16   GetMeasPrt
        16   -> __aeabi_memcpy4
       0   GetMeasPrt_
       8   HoldTeleMechs
         8   -> GetInState
         8   -> GetLedState
         8   -> GetOutState
         8   -> GetTrgLedState
         8   -> GetTrgOutState
       0   InitProxyTenPerSamples
       0   InitProxyTotMeas
       0   InitProxyTransport
      12   MoveCTputoAppObj
      24   PassPrtTblPrMngRvMsg
        24   -> PassPrtTblPrMngRvMsgOrigin
      16   PassPrtTblPrMngRvMsgOrigin
      16   PrepDecompouse10PeriodUnitHSU2
        16   -> ActivateServTrApCnTenPerSamplesUnitHSU2
        16   -> ServiceTRApCn2
        16   -> TerminateServiceApCnProxyTenPerSamples
      16   PrepDecompouseApcsUnitSpi
        16   -> ActivateServTrApCnApcsCTpuUnitSpi
        16   -> ServiceTRApCn2
        16   -> TerminateServiceApCnApcs
      16   PrepDecompouseAuxStngUnitM2m
        16   -> ActivateServTrApCnAuxStngCTpuUnit
        16   -> ServiceTRApCn2
        16   -> TerminateServiceApCnAuxStng
      16   PrepDecompouseDiagnUnitSPI
        16   -> ActivateServTrApCnDiagnCTpuUnitSPI
        16   -> ServiceTRApCn2
        16   -> TerminateServiceApCnDiagn
      16   PrepDecompouseGoosAUnitSpi
        16   -> ActivateServTrApCnGoosACTpuUnitSpi
        16   -> ServiceTRApCn2
        16   -> TerminateServiceApCnGoosA
      16   PrepDecompouseGoosBUnitSpi
        16   -> ActivateServTrApCnGoosBCTpuUnitSpi
        16   -> ServiceTRApCn2
        16   -> TerminateServiceApCnGoosB
      16   PrepDecompousePrtTblPrMngSpi
        16   -> ActivateServTrApCnPrtTblPrMngSpi
        16   -> ServiceTRApCn2
        16   -> TerminateServiceApCnPrtTblPrMng
      16   PrepDecompousePrtTblTptUnitSpi
        16   -> ActivateServTrApCnPrtTblTptUnitSpi
        16   -> ServiceTRApCn2
        16   -> TerminateServiceApCnPrPrtTblTpt
      16   PrepDecompouseSrcSamplesUnit
        16   -> ActivateServTrApCnSamplesCTpuUnit
        16   -> ServiceTRApCn2
      16   PrepDecompouseSrcSamplesUnitHSU2
        16   -> ActivateServTrApCnSamplesCTpuUnitHSU2
        16   -> ServiceTRApCn2
      16   PrepDecompouseTeleMechsUnitSpi
        16   -> ActivateServTrApCnTeleMechsCTpuUnitSpi
        16   -> ServiceTRApCn2
        16   -> TerminateServiceApCnTeleMechs
      16   PrepDecompouseTotMeasRUnitM2m
        16   -> ActivateServTrApCnTotMeasRCTpuUnitM2m
        16   -> ServiceTRApCn2
        16   -> TerminateServiceApCnTotMeasR
      16   PrepDecompouseTotMeasUnitHSU2
        16   -> ActivateServTrApCnTotMeasUnitHSU2
        16   -> ServiceTRApCn2
        16   -> TerminateServiceApCnProxyTotMeas
      16   PrepDecompouseTotVerInfoUnitHSU2
        16   -> ActivateServTrApCnTotVerInfoCTpuUnitSPI
        16   -> ServiceTRApCn2
        16   -> TerminateServiceApCnTotVerInfo
       0   ProcessProgramEvt
      16   ProcessReceiveEvt
        16   -> ScanCnl
        16   -> ScanCnlSpi
      32   ProcessTransmitEvt
        32   -> PrepDecompouse10PeriodUnitHSU2
        32   -> PrepDecompouseAuxStngUnitM2m
        32   -> PrepDecompouseDiagnUnitSPI
        32   -> PrepDecompousePrtTblTptUnitSpi
        32   -> PrepDecompouseSrcSamplesUnitHSU2
        32   -> PrepDecompouseTeleMechsUnitSpi
        32   -> PrepDecompouseTotMeasUnitHSU2
        32   -> PrepDecompouseTotVerInfoUnitHSU2
        32   -> ProcessTransmitLpduHSU2
        32   -> ProcessTransmitLpduM2m
        32   -> ProcessTransmitLpduSpi
        32   -> ProcessTransmitStubSeqSpi
        32   -> SpiStallHundler
       0   ResetAlgPrtTblWrEctDsc
       0   ResetAlgYustWrEctDsc
       0   ResetProxyTenPerSamples
       0   ResetProxyTotMeas
       0   ResetProxyTransport
       4   SamplesRvServCTpuApCnUnit
       4   SelectorCmd
      16   SendPrtTblTbl
        16   -> ActivatePrtTblTrPrTpt
       0   TerminateServiceApCnApcs
       0   TerminateServiceApCnAuxStng
       0   TerminateServiceApCnDiagn
       0   TerminateServiceApCnGoosA
       0   TerminateServiceApCnGoosB
       0   TerminateServiceApCnPrPrtTblTpt
       0   TerminateServiceApCnProxyTenPerSamples
       0   TerminateServiceApCnProxyTotMeas
       0   TerminateServiceApCnPrtTblPrMng
       0   TerminateServiceApCnTeleMechs
       0   TerminateServiceApCnTotMeasR
       0   TerminateServiceApCnTotVerInfo
       0   TestSetup_SrcSamples_ForTransmit
       8   TotMeasRRvServCTpuApCnUnit
         8   -> __aeabi_memcpy4
      32   TryPrtTblActivateExch
        32   -> ActivatePrtTblTrPrTpt
        32   -> Eval_CS
      16   TryPrtTblPrMngAlgWrActivate
        16   -> ActivatePrtTblPrMng
       0   TryPrtTblSetSendEct
       8   UpdateAppData
         8   -> SamplesRvServCTpuApCnUnit
         8   -> TotMeasRRvServCTpuApCnUnit
      16   UpdateRVAbnNumBrBsTpuUnit
      16   UpdateRVDiagnBrBmTpuUnit
      16   UpdateRVDiagnBrBsTpuUnit
      16   UpdateRVGoosACTpuUnit
      32   UpdateRVGoosBCTpuUnit
        32   -> CheckGoosBHldCs
      48   UpdateRVPrTptPrtTbl
        48   -> ActivatePrtTblRvPrTpt
        48   -> MoveCTputoAppObj
      24   UpdateRVPrTptPrtTbl1
        24   -> ActivatePrtTblRvPrTpt
      16   UpdateRVTotAtrCmdTpuUnit
      16   UpdateRVTotDateTimeTpuUnit
      16   UpdateRVTotFCoilTpuUnit
      16   UpdateRVTotMeasRCTpuUnit
       0   WaitPrtTblCmdHmEct
      24   WorkProxyTenPerSamples
        24   -> ExecCmdProxyTenPerSamples
      24   WorkProxyTotMeas
        24   -> ExecCmdProxyTotMeas
      16   WorkPrtTblPrMng
        16   -> ExecPrtTblCmdPrMng
      24   WorkPrtTblPrTpt
        24   -- Indirect call
        24   -> SelectorCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable102
       4  ??DataTable102_1
       4  ??DataTable102_2
       4  ??DataTable104
       4  ??DataTable104_1
       4  ??DataTable104_2
       4  ??DataTable106
       4  ??DataTable108
       4  ??DataTable108_1
       4  ??DataTable109
       4  ??DataTable109_1
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable11
       4  ??DataTable111
       4  ??DataTable111_1
       4  ??DataTable112
       4  ??DataTable112_1
       4  ??DataTable112_2
       4  ??DataTable112_3
       4  ??DataTable112_4
       4  ??DataTable113
       4  ??DataTable113_1
       4  ??DataTable113_10
       4  ??DataTable113_11
       4  ??DataTable113_12
       4  ??DataTable113_13
       4  ??DataTable113_14
       4  ??DataTable113_15
       4  ??DataTable113_16
       4  ??DataTable113_17
       4  ??DataTable113_18
       4  ??DataTable113_19
       4  ??DataTable113_2
       4  ??DataTable113_20
       4  ??DataTable113_21
       4  ??DataTable113_22
       4  ??DataTable113_23
       4  ??DataTable113_24
       4  ??DataTable113_25
       4  ??DataTable113_26
       4  ??DataTable113_27
       4  ??DataTable113_28
       4  ??DataTable113_29
       4  ??DataTable113_3
       4  ??DataTable113_30
       4  ??DataTable113_31
       4  ??DataTable113_32
       4  ??DataTable113_33
       4  ??DataTable113_34
       4  ??DataTable113_35
       4  ??DataTable113_36
       4  ??DataTable113_37
       4  ??DataTable113_38
       4  ??DataTable113_4
       4  ??DataTable113_5
       4  ??DataTable113_6
       4  ??DataTable113_7
       4  ??DataTable113_8
       4  ??DataTable113_9
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_21
       4  ??DataTable12_22
       4  ??DataTable12_23
       4  ??DataTable12_24
       4  ??DataTable12_25
       4  ??DataTable12_26
       4  ??DataTable12_27
       4  ??DataTable12_28
       4  ??DataTable12_29
       4  ??DataTable12_3
       4  ??DataTable12_30
       4  ??DataTable12_31
       4  ??DataTable12_32
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       4  ??DataTable62
       4  ??DataTable63
       4  ??DataTable64
       4  ??DataTable65
       4  ??DataTable65_1
       4  ??DataTable66
       4  ??DataTable66_1
       4  ??DataTable66_2
       4  ??DataTable66_3
       4  ??DataTable66_4
       4  ??DataTable66_5
       4  ??DataTable67
       4  ??DataTable70
       4  ??DataTable72
       4  ??DataTable72_1
       4  ??DataTable73
       4  ??DataTable73_1
       4  ??DataTable74
       4  ??DataTable74_1
       4  ??DataTable74_2
       4  ??DataTable74_3
       4  ??DataTable74_4
       4  ??DataTable75
       4  ??DataTable75_1
       4  ??DataTable76
       4  ??DataTable77
       4  ??DataTable78
       4  ??DataTable78_1
       4  ??DataTable78_2
       4  ??DataTable78_3
       4  ??DataTable81
       4  ??DataTable81_1
       4  ??DataTable82
       4  ??DataTable84
       4  ??DataTable84_1
       4  ??DataTable85
       4  ??DataTable85_1
       4  ??DataTable86
       4  ??DataTable86_1
       4  ??DataTable87
       4  ??DataTable88
       4  ??DataTable89
       4  ??DataTable89_1
       4  ??DataTable89_2
       4  ??DataTable91
       4  ??DataTable91_1
       4  ??DataTable91_2
       4  ??DataTable92
       4  ??DataTable93
       4  ??DataTable93_1
       4  ??DataTable93_2
       4  ??DataTable93_3
       4  ??DataTable93_4
       4  ??DataTable93_5
       4  ??DataTable94
       4  ??DataTable94_1
       4  ??DataTable94_2
       4  ??DataTable94_3
       4  ??DataTable94_4
       4  ??DataTable95
       4  ??DataTable96
       4  ??DataTable97
      96  ActivateProxyTenPerSamples
      96  ActivateProxyTotMeas
      88  ActivatePrtTblPrMng
     124  ActivatePrtTblRvPrTpt
     120  ActivatePrtTblTrPrTpt
     236  ActivateRVProxyTenPerSamplesCTpuUnit
     236  ActivateRVProxyTotMeasCTpuUnit
     192  ActivateServTrApCnApcsCTpuUnitSpi
      68  ActivateServTrApCnAuxStngCTpuUnit
     104  ActivateServTrApCnDiagnCTpuUnitSPI
     192  ActivateServTrApCnGoosACTpuUnitSpi
     196  ActivateServTrApCnGoosBCTpuUnitSpi
     220  ActivateServTrApCnPrtTblPrMngSpi
     124  ActivateServTrApCnPrtTblTptUnitSpi
     192  ActivateServTrApCnTeleMechsCTpuUnitSpi
     124  ActivateServTrApCnTenPerSamplesUnitHSU2
     148  ActivateServTrApCnTotMeasRCTpuUnitM2m
     124  ActivateServTrApCnTotMeasUnitHSU2
     180  ActivateServTrApCnTotVerInfoCTpuUnitSPI
     484  AlgPrtTblWriteEct
       4  AppReqReceiveAbnNum
       4  AppReqReceiveApcs
       4  AppReqReceiveAtrCmd
       4  AppReqReceiveDateTime
       4  AppReqReceiveDiagnBmBr
       4  AppReqReceiveDiagnBsBr
       4  AppReqReceiveFCoil
       4  AppReqReceiveGoosA
       4  AppReqReceiveGoosB
       4  AppReqReceiveTeleMechs
       4  AppReqReceiveTotMeasR
       4  AppReqTransmitApcs
       4  AppReqTransmitAuxStng
       4  AppReqTransmitDiagnBrBM
       4  AppReqTransmitDiagnBrBs
       4  AppReqTransmitGoosA
       4  AppReqTransmitGoosB
       4  AppReqTransmitTeleMechs
       4  AppReqTransmitTotMeasR
       4  AppReqTransmitTotVerInfoBrBs
      84  AtrCmdRvServCTpuApCnUnit
      52  CalcGoosBHldCs
      52  CheckGoosBHldCs
     136  CtrlSendPrtTblEct
      80  DateTimeRvServCTpuApCnUnit
     176  DpcsPrtTblPrMngMsg
     648  ExecCmdProxyTenPerSamples
     576  ExecCmdProxyTotMeas
     908  ExecCmdPrtTblPrTpt
     216  ExecExistProxy
     216  ExecExistProxyManager
      80  ExecProxy
     356  ExecPrtTblCmdPrMng
      84  FCoilRvServCTpuApCnUnit
     112  GetMeasPrt
      32  GetMeasPrt_
      68  HoldTeleMechs
      12  InitProxyTenPerSamples
      12  InitProxyTotMeas
      12  InitProxyTransport
     244  MoveCTputoAppObj
      88  PassPrtTblPrMngRvMsg
     352  PassPrtTblPrMngRvMsgOrigin
     172  PrepDecompouse10PeriodUnitHSU2
     172  PrepDecompouseApcsUnitSpi
     172  PrepDecompouseAuxStngUnitM2m
     172  PrepDecompouseDiagnUnitSPI
     172  PrepDecompouseGoosAUnitSpi
     172  PrepDecompouseGoosBUnitSpi
     192  PrepDecompousePrtTblPrMngSpi
     192  PrepDecompousePrtTblTptUnitSpi
     188  PrepDecompouseSrcSamplesUnit
     188  PrepDecompouseSrcSamplesUnitHSU2
     172  PrepDecompouseTeleMechsUnitSpi
     172  PrepDecompouseTotMeasRUnitM2m
     172  PrepDecompouseTotMeasUnitHSU2
     172  PrepDecompouseTotVerInfoUnitHSU2
     140  ProcessProgramEvt
     312  ProcessReceiveEvt
     960  ProcessTransmitEvt
    8992  PrtTbl
       4  ReqReceivePrtTblPrMng
       4  ReqReceivePrtTblPrTpt
       4  ReqTransmitPrtTblPrMng
       4  ReqTransmitPrtTblPrTpt
      52  ResetAlgPrtTblWrEctDsc
      52  ResetAlgYustWrEctDsc
      12  ResetProxyTenPerSamples
      12  ResetProxyTotMeas
     132  ResetProxyTransport
      76  SamplesRvServCTpuApCnUnit
     176  SelectorCmd
     100  SendPrtTblTbl
      44  TerminateServiceApCnApcs
       4  TerminateServiceApCnAuxStng
       4  TerminateServiceApCnDiagn
      44  TerminateServiceApCnGoosA
      44  TerminateServiceApCnGoosB
      16  TerminateServiceApCnPrPrtTblTpt
       4  TerminateServiceApCnProxyTenPerSamples
       4  TerminateServiceApCnProxyTotMeas
      36  TerminateServiceApCnPrtTblPrMng
      44  TerminateServiceApCnTeleMechs
      44  TerminateServiceApCnTotMeasR
       4  TerminateServiceApCnTotVerInfo
       4  TestReqReceiveT1
       4  TestReqReceiveT2
       4  TestReqReceiveT3
       4  TestReqReceiveTenPerSamples
       4  TestReqReceiveTotMeas
       4  TestReqTransmitT1
       4  TestReqTransmitT2
       4  TestReqTransmitT3
       4  TestReqTransmitTenPerSamples
       4  TestReqTransmitTotMeas
      32  TestSetup_SrcSamples_ForTransmit
      84  TotMeasRRvServCTpuApCnUnit
     252  TryPrtTblActivateExch
     144  TryPrtTblPrMngAlgWrActivate
      12  TryPrtTblSetSendEct
      48  UpdateAppData
     160  UpdateRVAbnNumBrBsTpuUnit
     160  UpdateRVDiagnBrBmTpuUnit
     160  UpdateRVDiagnBrBsTpuUnit
     708  UpdateRVGoosACTpuUnit
     748  UpdateRVGoosBCTpuUnit
     780  UpdateRVPrTptPrtTbl
     372  UpdateRVPrTptPrtTbl1
     688  UpdateRVTotAtrCmdTpuUnit
     688  UpdateRVTotDateTimeTpuUnit
     688  UpdateRVTotFCoilTpuUnit
     708  UpdateRVTotMeasRCTpuUnit
      12  WaitPrtTblCmdHmEct
     368  WorkProxyTenPerSamples
     368  WorkProxyTotMeas
     184  WorkPrtTblPrMng
     316  WorkPrtTblPrTpt
      52  arBaseFile
      12  arDateCompilation
      12  arTimeCompilation
       1  chUsehldPrtTblCmmMsgRV
       8  hlVerInfo
      24  hldApcsWrp
      24  hldAtrCmdWrp
      24  hldDateTimeWrp
      24  hldFCoilWrp
      24  hldGoosAWrp
      24  hldGoosBWrp
      44  hldPrMngPrtTbl
      68  hldPrTrptPrtTbl
      12  hldPrtTblCmmMsgRV
      12  hldPrtTblCmmMsgTR
      24  hldTeleMechsWrp
       8  hldTestPrtTblParam
      24  hldTotMeasRWrp
      56  hldTotVerInfoBr
       8  hldrAlgPrtTblWrEct
      12  hldrErrEvt
      36  holderApcs
      36  holderApcsIciCopy
      32  holderAtrCmd
      32  holderAtrCmdIciCopy
       4  holderAuxStng
       8  holderDateTime
       8  holderDateTimeIciCopy
      12  holderDiagnBmBr
      12  holderDiagnBrBm
      12  holderDiagnBrBs
      12  holderDiagnBsBr
      12  holderFCoil
      12  holderFCoilIciCopy
     816  holderGoosA
     816  holderGoosAIciCopy
     824  holderGoosB
     824  holderGoosBIciCopy
     100  holderProxyTenPerSamplesUnit
     100  holderProxyTotMeasUnit
    9000  holderPrtTbl
      80  holderSrcAPCSUnit
      48  holderSrcSamplesUnit
     800  holderSrcTest1Unit
      16  holderTeleMechs
      16  holderTeleMechsIciCopy
     588  holderTotMeasR
       4  lActualPrTrObj
       4  lAmtScanChnlM2mErrors
       4  lAmtScanChnlSpiErrors
       4  lSizeOf_PrtTbl
       8  llBuidNumber
       8  llIarVersion
     572  meas_protection
       8  testPrtTblState
       4  timerWaitReqHSU1
       4  timerWaitReqHSU2
       4  timerWaitReqHSU7
       4  timerWaitReqM2m
       4  timerWaitReqSpi

 
 14 049 bytes in section .bss
 10 364 bytes in section .data
    100 bytes in section .rodata
 16 644 bytes in section .text
  4 408 bytes in section Fast_function
 
 21 052 bytes of CODE  memory
    100 bytes of CONST memory
 24 413 bytes of DATA  memory

Errors: none
Warnings: 29
