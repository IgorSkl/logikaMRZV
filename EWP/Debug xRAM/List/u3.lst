###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Oct/2015  12:12:06
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  D:\IAR projects\HR1_0100_00_I720_new2\ici\u3.c
#    Command line =  
#        "D:\IAR projects\HR1_0100_00_I720_new2\ici\u3.c" -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --interwork --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\List\u3.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\Obj\u3.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\ici\u3.c
      1          #include "../LIB/CDL_AV0/lpc/include/lpc_types.h"
      2          #include "../LIB/CDL_AV0/lpc/include/lpc_irq_fiq.h"
      3          #include "../LIB/CDL_AV0/lpc/include/lpc_arm922t_cp15_driver.h"
      4          //#include "ea3250_board.h"
      5          #include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_uart_driver.h"
      6          #include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_intc_driver.h"
      7          #include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_timer_driver.h"
      8          #include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_clkpwr_driver.h"
      9          #include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_ssp_driver.h"
     10          #include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_gpio_driver.h"
     11          
     12          extern void Rst_LpduHSU2_TpCnState(void);
     13          extern long ssp1_hdr_init(void);
     14          void M16_J18_K18_A15_PioInit(void);
     15          
     16          extern void recv_cb(void);
     17          extern void send_cb(void);
     18          extern long uartdev;
     19          extern UNS_8 txbuff [512], rxbuff [512];
     20          extern int txsize, rxsize;
     21          extern int txfill, rxget, txget, rxfill;
     22          
     23          extern  int AppReqTransmitTotVerInfoBrBs;
     24          
     25          
     26          
     27          INT_32 timer0dev = 0;
     28          
     29          //static INT_32 uartdev;
     30          //static UNS_8 txbuff [512], rxbuff [512];
     31          //volatile static int txsize, rxsize;
     32          //static int txfill, rxget, txget, rxfill;
     33          extern void hs7_uart_hdw_init(void);
     34          extern void hs1_uart_hdw_init(void);
     35          extern void hs2_uart_hdw_init(void);
     36          void P02Int(void);
     37          extern UNS_32 Timer_usec_to_val(CLKPWR_CLK_T clknum, UNS_32 usec);
     38          BOOL_32 Int_install_ext_irq_handler(INTERRUPT_SOURCE_T source,
     39                                              PFV func_ptr,
     40                                              INTERRUPT_TYPE_T type,
     41                                              int high);
     42          STATUS Timer_ioctl(INT_32 devid,
     43                             INT_32 cmd,
     44                             INT_32 arg);									
     45          									
     46          BOOL_32 Int_clear(INTERRUPT_SOURCE_T source);
     47          
     48          
     49          void timer0_user_interrupt(void);
     50          
     51          
     52          
     53          
     54          
     55          void ici_hdw_init(void)
     56          {
     57          //register long i;
     58          
     59          UART_CBS_T cbs;
     60          UART_CONTROL_T ucntl;
     61          
     62          //- typedef enum
     63          //- {
     64          //-   UART_PAR_NONE,
     65          //-   UART_PAR_EVEN,
     66          //-   UART_PAR_ODD
     67          //- } UART_PAR_T;
     68          //- 
     69          //- /* UART control */
     70          //- typedef struct
     71          //- {
     72          //-   UNS_32 baud_rate;     /* Device baud rate */
     73          //-   UART_PAR_T parity;    /* Parity selection */
     74          //-   UNS_32 databits;      /* Number of data bits */
     75          //-   UNS_32 stopbits;      /* Number of stop bits */
     76          //- } UART_CONTROL_T;
     77          
     78          timer0dev = Timer_open(TIMER_CNTR0, 0);
     79          TIMER_CNTR_REGS_T *pTimer = TIMER_CNTR0;
     80          /*
     81           //-* Reset timer *-/
     82            pTimer->tcr = TIMER_CNTR_TCR_RESET;
     83            pTimer->tcr = 0;
     84            
     85             //-* Count mode is PCLK edge *-/
     86            pTimer->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
     87          
     88            //-* Set prescale counter value for a 1uS tick *-/
     89            pTimer->pr = (UNS_32) Timer_usec_to_val(
     90                           CLKPWR_TIMER0_CLK, 1);
     91          				 
     92          	//case TMR_VALUE_ST:
     93              //          status = pTimer->tc;
     94              //          break;			 
     95            //-* Enable the timer *-/
     96            pTimer->tcr = TIMER_CNTR_TCR_EN;
     97          
     98            //-* Stop timer *-/
     99            //pTimer->tcr = 0;
    100          */
    101          //Init Module New
    102          
    103           //-* Enable timer system clock *-/
    104            //.clkpwr_clk_en_dis(timer_num_to_clk_enum[timernum], 1);
    105          
    106            //-* Reset timer *-/
    107            pTimer->tcr = TIMER_CNTR_TCR_RESET;
    108            pTimer->tcr = 0;pTimer->tc  = 0;
    109          
    110            //-* Clear and enable match function *-/
    111            pTimer->ir = TIMER_CNTR_MTCH_BIT(0);
    112          
    113            //-* Count mode is PCLK edge *-/
    114            pTimer->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
    115          
    116            //-* Set prescale counter value for a 1uS tick *-/
    117            pTimer->pr = (UNS_32) Timer_usec_to_val(
    118                           CLKPWR_TIMER0_CLK, 1);
    119          
    120            //-* Set match for number of usecs *-/
    121            pTimer->mr[0] = 20000;//-usec;
    122          
    123            //-* Interrupt on match 0 *-/
    124            pTimer->mcr = TIMER_CNTR_MCR_MTCH(0)|TIMER_CNTR_MCR_RESET(0);	
    125          
    126             //-* Install timer interrupts handlers as a IRQ interrupts *-/
    127            int_install_irq_handler(IRQ_TIMER0, (PFV) timer0_user_interrupt);
    128          
    129          
    130          
    131          
    132          
    133          
    134          
    135          
    136          //~  ucntl.baud_rate = 115200;
    137          //~  ucntl.parity = UART_PAR_NONE;
    138          //~  ucntl.databits = 8;
    139          //~  ucntl.stopbits = 1;
    140          //~  uartdev = Uart_open((void *) UART3, (INT_32) & ucntl);
    141          //~  if (uartdev != 0)
    142          //~  {
    143          //~    /* Setup RX and TX callbacks */
    144          //~    cbs.rxcb = recv_cb;
    145          //~    cbs.txcb = send_cb;
    146          //~    cbs.rxerrcb = NULL;
    147          //~    Uart_ioctl(uartdev, UART_INSTALL_CBS, (INT_32) &cbs);
    148          //~    //.int_enable(IRQ_UART_IIR3);
    149          //~  }
    150          //~
    151          //~  /* Initialize TX and RX ring buffers */
    152          //~  //txfill = txget = rxfill = rxget = txsize = rxsize = 0;
    153          //~  Rst_LpduHSU2_TpCnState();
    154          //~  /* Enable interrupts */
    155          //~  int_enable(IRQ_UART_IIR3);
    156          //~  hs7_uart_hdw_init();
    157          //~  hs1_uart_hdw_init();
    158          //~  hs2_uart_hdw_init();
    159          //~  
    160          //~  enable_irq();
    161          //~  //int_enable(IRQ_UART_IIR7);
    162          //~  int_enable(IRQ_UART_IIR1);
    163          //~  int_enable(IRQ_UART_IIR2);
    164             ssp1_hdr_init();
    165          Rst_LpduM2m_TpCnState();
    166          Rst_LpduSpi_TpCnState();
    167             GPIO->p0_mux_clr = 0xff;
    168            GPIO->p0_dir_clr = 0xff;   
    169            GPIO->p0_dir_set = 0xf0;   
    170            GPIO->p0_outp_clr =0xf0;
    171            M16_J18_K18_A15_PioInit();
    172          
    173            //p3_outp_state
    174           
    175          AppReqTransmitTotVerInfoBrBs = 1;
    176            
    177            Int_install_ext_irq_handler(IRQ_GPIO_01,P02Int,FALLING_EDGE,0);//Interrupt in this place never can be workd look p606 datasheet - Only pin sic[8] activated
    178            Int_install_ext_irq_handler(IRQ_P0_P1_IRQ,P02Int,FALLING_EDGE,0);
    179            
    180            CLKPWR ->clkpwr_p01_er = CLKPWR_INTSRC_GPIO_01_BIT;// *((long*)0x40004018) |= 2;
    181            
    182          	  Int_enable(IRQ_GPIO_01);
    183          	  Int_enable(IRQ_P0_P1_IRQ);
    184            MIC->er |= (1<<(IRQ_SUB2IRQ));
    185            
    186           //~^  pTimer->tcr = TIMER_CNTR_TCR_EN;//timer_ioctl(timer0dev, TMR_ENABLE, 1);
    187           //~^ int_enable(IRQ_TIMER0);
    188            
    189            
    190          }
    191          //extern unsigned char chMemCY7;
    192          extern void CY7_rv_cb(void);
    193          
    194          
    195          
    196          void P02Int(void)
    197          {
    198          //SIC2->rsr |= (1<<(8)); //Clear Sic2 RSR IRQ_P0_P1_IRQ ||Bit->.8.<  <-Pn_GPIO ALL Port 0 and Port 1 GPIO pins OR’ed.
    199          Int_clear(IRQ_P0_P1_IRQ);
    200          CY7_rv_cb();//chMemCY7++;
    201          return;
    202          }
    203          void M16_J18_K18_A15_PioInit(void)
    204          {
    205          //Init GPO23 - M16
    206             UARTCNTL->ctrl &= ~(UART_U3_MD_CTRL_EN);//0x40054000
    207            GPIO->p3_outp_clr = (1<<23); 
    208            //Init GPI16 - J18
    209            
    210            //Init GPI17 - K18
    211            
    212           //Init GPO7 - A15
    213            GPIO->p3_outp_clr = (1<<7);
    214          
    215          }
    216          
    217          
    218          
    219          
    220          
    221          /*
    222          
    223          speculative
    224          
    225          : based on guesses or ideas about what might happen or be true rather than on facts
    226          
    227          : tending to think about what might happen or be true : tending to speculate
    228          
    229          : showing curiosity or uncertainty
    230          
    231          Speculative - Merriam-Webster.com
    232          
    233          
    234          */
    235          
    236          void timer0_user_interrupt(void)
    237          {
    238            //--* Clear latched timer interrupt *--/
    239            //-* Reset timer *-/
    240            TIMER_CNTR_REGS_T *pTimer = TIMER_CNTR0;
    241            pTimer->tcr = TIMER_CNTR_TCR_RESET;
    242            Int_clear(IRQ_TIMER0);
    243           // Timer_ioctl(timer0dev, TMR_CLEAR_INTS, TIMER_CNTR_MTCH_BIT(0));
    244            
    245          
    246          }
    247          
    248          
    249          
    250          
    251          
    252          
    253          
    254          
    255          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   M16_J18_K18_A15_PioInit
       8   P02Int
         8   -> CY7_rv_cb
         8   -> Int_clear
       8   ici_hdw_init
         8   -> Int_enable
         8   -> Int_install_ext_irq_handler
         8   -> M16_J18_K18_A15_PioInit
         8   -> Rst_LpduM2m_TpCnState
         8   -> Rst_LpduSpi_TpCnState
         8   -> Timer_open
         8   -> Timer_usec_to_val
         8   -> int_install_irq_handler
         8   -> ssp1_hdr_init
       8   timer0_user_interrupt
         8   -> Int_clear


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
       4  ??DataTable0_5
      64  M16_J18_K18_A15_PioInit
      20  P02Int
     304  ici_hdw_init
      32  timer0_user_interrupt
       4  timer0dev

 
   4 bytes in section .bss
 444 bytes in section .text
 
 444 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: 19
