###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        15/Oct/2015  14:31:22
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\ici\CTpu.c
#    Command line =  
#        "D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\ici\CTpu.c"
#        -lcN "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug xRAM\List\" -o
#        "D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\Obj\" --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=ARM926EJ-S -e --fpu=VFP9-S --dlib_config "D:\Program Files\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\Igor\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\component\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I
#        "D:\Program Files\IAR
#        Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\Program
#        Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\..\" --interwork
#        --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\List\CTpu.lst
#    Object file  =  
#        D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\Obj\CTpu.o
#
###############################################################################

D:\Program Files\IAR Systems\MYWORK\HR1_0100_00_I720_new2\ici\CTpu.c
      1          /*------------------------------------------------------------------------------
      2          * Copyright (c) 2013 - Factory “KyivPrylad”
      3          * 
      4          * Permission to use, copy, modify, and distribute this software for any
      5          * purpose with or without fee is hereby granted, provided that the above
      6          * copyright notice and this permission notice appear in all copies.
      7          * 
      8          * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
      9          * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
     10          * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
     11          * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
     12          * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
     13          * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
     14          * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
     15          * 
     16          *------------------------------------------------------------------------------
     17          *
     18          * Processor       : Lpc_3240
     19          * File Name       : Ctpu.c
     20          * Description     : Functions and Data for Transport Leyer
     21                              BM BR
     22          
     23          *  Version        : 1.00
     24          *
     25          *       +----- (NEW | MODify | ADD | DELete)
     26          *       |
     27          *  No   |   When       Who                What
     28          *-----+---+----------+------------------+--------------------------------------
     29          * 000  NEW  10/09/13   Markovsky A       Creation
     30          *----------------------------------------------------------------------------*/
     31          
     32          #include    "ApCn.h"
     33          #include    "CTpu.h"
     34          #include    "lpu.h"
     35          #include    "ApMeasR.h"
     36          #include    "Apcs.h"
     37          #include    "GoosB.h"
     38          #include    "Tlmc.h"
     39          
     40          
     41          
     42          
     43          TRSrcSamplesCTpuUnitDsc holderTRSrcSamplesCTpuUnit;
     44          
     45          RVSrcSamplesCTpuUnitDsc  holderRVSrcSamplesCTpuUnit;
     46          
     47          TR10PeriodCTpuUnitDsc  holderTR10PeriodCTpuUnit;
     48          RV10PeriodCTpuUnitDsc  holderRV10PeriodCTpuUnit;
     49          
     50          TRTotMeasCTpuUnitDsc holderTRTotMeasCTpuUnit;
     51          RVTotMeasCTpuUnitDsc  holderRVTotMeasCTpuUnit;
     52          
     53          TRTotMeasRSOCTpuUnitDsc holderTRTotMeasRSOCTpuUnit;
     54          RVTotMeasRSOCTpuUnitDsc  holderRVTotMeasRSOCTpuUnit;
     55          //.RVTotMeasGSOCTpuUnitDsc holderRVTotMeasGSOCTpuUnit = {
     56          //.{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
     57          //.{0,0,0,0,(void*)&holderTotMeasG.UNTotMeas.chArTotMeas[0]}
     58          //.};
     59          RVTotMeasRSOCTpuUnitDsc  holderRVTotMeasRSOCTpuUnit = {
     60           {0,0,0,0},//{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
     61           {0,0,SIZE_TPDU_TOT_MEASR_CNL_HSU2,0,0,(void*)&holderTotMeasR.UNTotMeas.chArTotMeas[0]}
     62           };
     63          
     64          TRApcsSOCTpuUnitDsc  holderTRApcsSOCTpuUnit;
     65          RVApcsSOCTpuUnitDsc  holderRVApcsSOCTpuUnit = {
     66           {0,0,0,0},//{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
     67           {0,0,SIZE_TPDU_APCS_CNL_SPI,0,0,(void*)&holderApcs.UNApcs.chArApcs[0]}
     68           };
     69          
     70          
     71          TRTeleMechsSOCTpuUnitDsc  holderTRTeleMechsSOCTpuUnit = {
     72          {0,0,0,0},//{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
     73          {ID_CNL_SPI,ID_CNL_SPI,0,0, SIZE_TPDU_TELE_MECHS_CNL_SPI   ,
     74          SIZE_TELE_INFO,ID_TELE_MECHS_UNIT,0,(void*)&(holderTeleMechs.UNTeleMechs.lArTeleMechs[0])}
     75          
     76          }; 
     77          
     78          
     79          
     80           
     81          TRPrtTblPrMngCTpuUnitDsc hldrTRPrtTblPrMngCTpuUnit; 
     82          RVPrtTblPrMngCTpuUnitDsc hldrRVPrtTblPrMngCTpuUnit; 
     83           #define DEFAULT_SIZE_PR_TBL_MSG 1 
     84          TRPrtTblTransportCTpuUnitDsc hldrTRPrtTblTransportCTpuUnit = {
     85          {'P','r','t','T','b','l','T','r'},//
     86          {ID_CNL_SPI,ID_CNL_SPI,0,0,SIZE_TPDU_TRANSPORT_PRT_CNL_SPI,
     87          DEFAULT_SIZE_PR_TBL_MSG,ID_PRT_PR_MNG,0,hldrTRPrtTblPrMngCTpuUnit.arUchTR}
     88          };  
     89          RVPrtTblTransportCTpuUnitDsc hldrRVPrtTblTransportCTpuUnit= {
     90          {'P','r','t','T','b','l','R','V'},
     91          {ID_CNL_SPI,0, SIZE_TPDU_TRANSPORT_PRT_CNL_SPI,0,0,(unsigned char*)&(hldrRVPrtTblPrMngCTpuUnit.arUchRV)}
     92          }; 
     93          
     94          
     95          
     96          
     97          RVFCoilSOCTpuUnitDsc  holderRVFCoilSOCTpuUnit = {
     98          {'F','C','o','i','l',' ','R','V'},
     99          {ID_CNL_SPI,0, SIZE_TPDU_FCOIL_CNL_SPI,0,0,(unsigned char*)&(holderRVFCoilSOCTpuUnit.arUchRV)}
    100          };
    101          
    102          
    103          RVDateTimeSOCTpuUnitDsc  holderRVDateTimeSOCTpuUnit = {
    104          {'D','a','t','e','T','i','m','e'},
    105          {ID_CNL_SPI,0, SIZE_TPDU_DATE_TIME_CNL_SPI,0,0,(unsigned char*)&(holderRVDateTimeSOCTpuUnit.arUchRV)}
    106          
    107          };
    108          
    109          
    110          RVAtrCmdSOCTpuUnitDsc  holderRVAtrCmdSOCTpuUnit = {
    111          {'A','t','r',' ','C','m','d',' '},
    112          {ID_CNL_SPI,0, SIZE_TPDU_ATR_CMD_CNL_SPI,0,0,(unsigned char*)&(holderRVAtrCmdSOCTpuUnit.arUchRV)}
    113          
    114          };
    115          
    116          
    117          #define DEFAULT_SIZE_DIAGN_MSG 16 
    118          
    119          TRDiagnBrBsSOCTpuUnitDsc  holderTRDiagnBrBsSOCTpuUnit  = {
    120          {'D','i','a','g','n',' ','B','r'},
    121          {ID_CNL_SPI,ID_CNL_SPI,0,0,SIZE_TPDU_DIAGN_BR_CNL_SPI,DEFAULT_SIZE_DIAGN_MSG,ID_DIAGN_BR_UNIT,0,holderTRDiagnBrBsSOCTpuUnit.arUchTR}
    122          };
    123          RVDiagnBrBsSOCTpuUnitDsc  holderRVDiagnBrBsSOCTpuUnit  = { 
    124          {'D','i','a','g','n',' ','B','s'},
    125          {ID_CNL_SPI,0, SIZE_TPDU_DIAGN_BR_CNL_SPI,0,0,(unsigned char*)&(holderRVDiagnBrBsSOCTpuUnit.arUchRV)}
    126          }; 
    127          
    128          TRDiagnBrBmSOCTpuUnitDsc  holderTRDiagnBrBmSOCTpuUnit  = {
    129          {'D','i','a','g','n',' ','B','r'},
    130          {ID_CNL_M2M,ID_CNL_M2M,0,0,SIZE_TPDU_DIAGN_BR_CNL_M2M,DEFAULT_SIZE_DIAGN_MSG,ID_DIAGN_BR_UNIT,0,holderTRDiagnBrBmSOCTpuUnit.arUchTR}
    131          };
    132          
    133          
    134          
    135          
    136          RVDiagnBrBmSOCTpuUnitDsc  holderRVDiagnBrBmSOCTpuUnit  = { 
    137          {'D','i','a','g','n',' ','B','m'},
    138          {ID_CNL_M2M,0, SIZE_TPDU_DIAGN_BR_CNL_M2M,0,0,(unsigned char*)&(holderRVDiagnBrBmSOCTpuUnit.arUchRV)}
    139          }; 
    140          
    141           #define DEFAULT_SIZE_VER_INFO_BR_MSG 64
    142          TRTotVerInfoBrBsSOCTpuUnitDsc  holderTRTotVerInfoBrBsSOCTpuUnit = {
    143          {'T','o','t',' ','v','e','r',' ','I','n','f','o'},
    144          {ID_CNL_SPI,ID_CNL_SPI,0,0,SIZE_TPDU_VER_INFO_BR_CNL_SPI, DEFAULT_SIZE_VER_INFO_BR_MSG ,ID_VER_INFO_BR_UNIT,0,holderTRTotVerInfoBrBsSOCTpuUnit.arUchTR}
    145          };
    146          
    147          
    148           #define DEFAULT_SIZE_AUX_STNG_MSG 8
    149          TRAuxStngSOCTpuUnitDsc  holderTRAuxStngSOCTpuUnit = {
    150          {'G','U','s','t'},
    151          {ID_CNL_M2M,ID_CNL_M2M,0,0,
    152          SIZE_TPDU_AUX_STNG_BR_CNL_M2M, DEFAULT_SIZE_AUX_STNG_MSG ,
    153          ID_AUX_STNG_UNIT,0,
    154          holderTRAuxStngSOCTpuUnit.arUchTR}
    155          };
    156          
    157          RVAbsNumeratorUnnSOCTpuUnitDsc holderRVAbsNumeratorUnnSOCTpuUnit  = { 
    158          {'N','u','n','e','r','a','t','r'},
    159          {ID_CNL_SPI,0, SIZE_TPDU_UNN_ABS_NUMERTRS_BR_CNL_SPI,0,0,(unsigned char*)&(holderRVAbsNumeratorUnnSOCTpuUnit.arUchRV)}
    160          }; 
    161           #define DEFAULT_SIZE_ANL_RECORD_MSG (SIZE_AWC_LOG_DATA+4)
    162          TRUN_ArecSOCTpuUnitDsc  holderTRUN_ArecSOCTpuUnit = {
    163          {'G','U','s','t'},
    164          {ID_CNL_SPI,ID_CNL_SPI,0,0,
    165          SIZE_TPDU_ANL_RECORD_BR_CNL_SPI, DEFAULT_SIZE_ANL_RECORD_MSG ,
    166          ID_ANL_RECORD_UNIT,0,
    167           holderTRUN_ArecSOCTpuUnit.arUchTR}
    168          };
    169          
    170          
    171          
    172           
    173          TRGoosASOCTpuUnitDsc  holderTRGoosASOCTpuUnit;
    174          RVGoosASOCTpuUnitDsc  holderRVGoosASOCTpuUnit;
    175          TRGoosBSOCTpuUnitDsc  holderTRGoosBSOCTpuUnit; 
    176          //RVGoosBSOCTpuUnitDsc  holderRVGoosBSOCTpuUnit; 
    177          RVGoosBSOCTpuUnitDsc  holderRVGoosBSOCTpuUnit = {
    178           {0,0,0,0},
    179           {ID_CNL_SPI,0, SIZE_TPDU_GOOS_B_CNL_SPI,0,0,(void*)&holderGoosBIciCopy.UNGoosB.chArGoosB[0]}
    180          }; 
    181           
    182          StateTpCnDsc hldrTpCnState;
    183          StateTpCnDsc  hldrRVTpCnState;
    184          
    185          
    186          
    187          
    188          
    189          void ActivateServTrApCnSamplesCTpuUnit(void);
    190          
    191          void ActivateServiceTrApCn(void* pvD,long IdObj)
    192          {
    193          //register long i,j;
    194          //register char *pch;
    195          ////Copy
    196          //  pch = (char *)&(holderTRSrcSamplesCTpuUnit.arUchTR);
    197          //  for (i = 0; i < sizeof(SrcSamplesUnitDsc); i++)
    198          //  {
    199          //    pch[i] = ((char*)pvD)[i];
    200          //  }
    201          //
    202          	ActivateServTrApCnSamplesCTpuUnit();
    203          	TestReqTransmitT1 = EXEC;
    204          }
    205          
    206          void ActivateServTrApCnSamplesCTpuUnit(void)
    207          {
    208          register long i,j;
    209          register char *pch;
    210          register void* pv;
    211          //Copy
    212            pch = (char *)&(holderTRSrcSamplesCTpuUnit.arUchTR);
    213            pv  = (void*)& holderSrcSamplesUnit;
    214            j = sizeof(SrcSamplesUnitDsc);
    215            for (i = 0; i < j; i++)
    216            {
    217              pch[i] = ((char*)pv)[i];
    218            }
    219            //Reset Connect State
    220             pv  = (void*)& (holderTRSrcSamplesCTpuUnit.TrCnHldr);
    221             
    222             ((TRBaseCTpuUnitDsc*)pv)->uchBaseTransport  = ID_CNL_HSU7;// If need change
    223             ((TRBaseCTpuUnitDsc*)pv)->uchUsedTransport  = ID_CNL_HSU7;// Logic can ctrl
    224             
    225             //((TRBaseCTpuUnitDsc*)pv)->NumComSes  = ;
    226             ((TRBaseCTpuUnitDsc*)pv)->ConState   = 0;//Reset Con State
    227             ((TRBaseCTpuUnitDsc*)pv)->SizeAppObj = sizeof(SrcSamplesUnitDsc);
    228             ((TRBaseCTpuUnitDsc*)pv)->IdConObj   = ID_SRC_SAMPLES_UNIT;
    229             ((TRBaseCTpuUnitDsc*)pv)->ulTrCount  = 0;//Reset  counter
    230             ((TRBaseCTpuUnitDsc*)pv)->pUchTR     = (unsigned char*)& holderTRSrcSamplesCTpuUnit.arUchTR;
    231             
    232          }
    233          void ActivateServTrApCnSamplesCTpuUnitHSU2(void)
    234          {
    235          register long i,j;
    236          register char *pch;
    237          register void* pv;
    238          //Copy
    239            pch = (char *)&(holderTRSrcSamplesCTpuUnit.arUchTR);
    240            pv  = (void*)& holderSrcSamplesUnit;
    241            j = sizeof(SrcSamplesUnitDsc);
    242            for (i = 0; i < j; i++)
    243            {
    244              pch[i] = ((char*)pv)[i];
    245            }
    246            //Reset Connect State
    247             pv  = (void*)& (holderTRSrcSamplesCTpuUnit.TrCnHldr);
    248             
    249             ((TRBaseCTpuUnitDsc*)pv)->uchBaseTransport  = ID_CNL_HSU2;// If need change
    250             ((TRBaseCTpuUnitDsc*)pv)->uchUsedTransport  = ID_CNL_HSU2;// Logic can ctrl
    251             
    252             //((TRBaseCTpuUnitDsc*)pv)->NumComSes  = ;
    253             ((TRBaseCTpuUnitDsc*)pv)->ConState   = 0;//Reset Con State
    254             ((TRBaseCTpuUnitDsc*)pv)->SizeAppObj = sizeof(SrcSamplesUnitDsc);
    255             ((TRBaseCTpuUnitDsc*)pv)->IdConObj   = ID_SRC_SAMPLES_UNIT;
    256             ((TRBaseCTpuUnitDsc*)pv)->ulTrCount  = 0;//Reset  counter
    257             ((TRBaseCTpuUnitDsc*)pv)->pUchTR     = (unsigned char*)& holderTRSrcSamplesCTpuUnit.arUchTR;
    258             
    259          }
    260          
    261          void ServiceTRApCn(void* pvD,long IdObj)
    262          {
    263          //register long i,j;
    264          //Detect Type Desirable  Cannel
    265          
    266          }
    267          /*
    268          int ServiceTRApCn1(void* pvCTpuTR,void* pvStateTpCnDsc )
    269          {
    270          register long i,j;
    271          register void *pv;
    272          struct 
    273          	{
    274          		//short         shCountCmd;  
    275          		//unsigned char uChIdxByte ;
    276          		//unsigned char uChIdxBit ;
    277          		//short shErr;
    278          		char ch1,ch2,ch3,ch4;
    279          		unsigned short ConState;
    280          		unsigned short ushTrCount;
    281          		unsigned short ushCapicity;
    282          		unsigned short ushSizeLDC;
    283          	    //.unsigned char *pUchTR;//
    284          		void  *pOriginTR, *pOriginTpCn;
    285          		
    286          	} sLV;
    287              union 
    288          	    {
    289          	    	unsigned char   uchAr [4];
    290          	    	unsigned short  ushAr [2];
    291                      unsigned long   ulVal;
    292          	    }unnV1;
    293          	
    294          //Save pointers
    295          sLV.pOriginTR     = pvCTpuTR;
    296          sLV.pOriginTpCn   = pvStateTpCnDsc;
    297          	j = ((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_1;
    298          	i = ((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_1;
    299          	
    300          	if (i<4 && j )
    301          	return 1;//Capicity full
    302          	//-sLV.ConState    = 0;sLV.ushTrCount  = 0;	sLV.ushCapicity = 0;
    303          	sLV.ushSizeLDC  = 0;
    304          	//Detect State 	CTpuTR side
    305          	sLV.ch1 = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->uchBaseTransport;
    306          	sLV.ch2 = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->uchUsedTransport;
    307          	sLV.ch3 = i = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->ConState;
    308          	if ((i&0xf) == SUCCESS_EXEC)
    309          	{
    310          		
    311          		return 0;
    312          	}
    313          	i = sLV.ch3;//Connection state
    314          	if (i&(MODE_LDC))
    315          	goto ttt;
    316          	
    317          	
    318          	
    319          	
    320          	//Detect state TpCn side
    321          	sLV.Capicity = j = ((StateTpCnDsc*)pvStateTpCnDsc)->lCapicity_CNL_1;
    322          	sLV.ushTrCount = i = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->ulTrCount;
    323          	if (j>i)
    324          	{
    325          		//Put Total
    326          	}
    327          	else
    328          	{
    329          		//Detect Avail Part 
    330          		i = sLV.Capicity - 4;
    331          		sLV.ushTrCount = i;
    332          		j = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->ulTrCount;
    333          		((TRBaseCTpuUnitDsc*)pvCTpuTR)->ulTrCount = j - i;//
    334          		
    335          		i = sLV.Capicity - sLV.ushTrCount
    336          		((StateTpCnDsc*)pvStateTpCnDsc)->lCapicity_CNL_1  = i;
    337          		((StateTpCnDsc*)pvStateTpCnDsc)->uchTpState_CNL_1 = 1;
    338          		pv = (void*)(((StateTpCnDsc*)pvStateTpCnDsc)->pUchLpuTR_CNL_1);
    339          	}
    340          	
    341          //Prepea transmision data
    342          
    343          
    344          //Put 	transmision data
    345          AsemblyLDC:
    346          
    347          
    348          	
    349          	
    350          	
    351          //((EmrEventDsc*)p_out_param)->EvtField	
    352          }
    353          */
    354          
    355          long SetCnlStatetoRun(long lID_Cnl,void* pvStateTpCnDsc)
    356          {
    357          
    358          return 0;
    359          }
    360          long CutCnlCapicity(long lID_Cnl,void* pvStateTpCnDsc)
    361          {
    362          
    363          return 0;
    364          } 
    365          
    366          long SetStateCnlTpCn(long lID_Cnl,void* pvStateTpCnDsc, void* pvTpCn)  @ "Fast_function"
    367          {
    368          switch (lID_Cnl)
    369          	{
    370          	case ID_CNL_TEST1:
    371          		  
    372          		
    373          		 
    374          		((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_1 =  
    375          		((StateCnlTRTpCnDsc*)pvTpCn)->uchTpState_CNL;
    376          		
    377          		(((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_CNL_1) = 
    378          		((StateCnlTRTpCnDsc*)pvTpCn)->shPayloadLPDU;
    379          		   
    380          		((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_1 =
    381          		((StateCnlTRTpCnDsc*)pvTpCn)->lCapicity_CNL;
    382          		   
    383          		//.(((StateTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL_1) = 		
    384          		//.((StateCnlTRTpCnDsc*)pvTpCn)->pUchLpuTR_CNL;
    385          		break;
    386          	case ID_CNL_HSU7:
    387          		
    388          		
    389          		  
    390          		((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_HSU7 =
    391          		((StateCnlTRTpCnDsc*)pvTpCn)->uchTpState_CNL;
    392          		   
    393          		(((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_HSU7) =
    394          		((StateCnlTRTpCnDsc*)pvTpCn)->shPayloadLPDU;
    395          		   
    396          		((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_HSU7 = 
    397          		((StateCnlTRTpCnDsc*)pvTpCn)->lCapicity_CNL;
    398          		((StateTpCnDsc*)pvStateTpCnDsc)-> chTotalLDC_CNL_HSU7 = 
    399          		((StateCnlTRTpCnDsc*)pvTpCn)->chTotalLDC_CNL;
    400          		
    401          		 
    402          		//.(((StateTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL_HSU7) = 
    403          		//.((StateCnlTRTpCnDsc*)pvTpCn)->pUchLpuTR_CNL ;	
    404          		
    405          		break;
    406           	case ID_CNL_HSU2:
    407           		((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_HSU2 =
    408          		((StateCnlTRTpCnDsc*)pvTpCn)->uchTpState_CNL;
    409          		   
    410          		(((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_HSU2) =
    411          		((StateCnlTRTpCnDsc*)pvTpCn)->shPayloadLPDU;
    412          		   
    413          		((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_HSU2 = 
    414          		((StateCnlTRTpCnDsc*)pvTpCn)->lCapicity_CNL;
    415          		((StateTpCnDsc*)pvStateTpCnDsc)-> chTotalLDC_CNL_HSU2 = 
    416          		((StateCnlTRTpCnDsc*)pvTpCn)->chTotalLDC_CNL;
    417          		
    418           		break;
    419          	case ID_CNL_M2M:
    420           		((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_M2m =
    421          		((StateCnlTRTpCnDsc*)pvTpCn)->uchTpState_CNL;
    422          		   
    423          		(((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_M2m) =
    424          		((StateCnlTRTpCnDsc*)pvTpCn)->shPayloadLPDU;
    425          		   
    426          		((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_M2m = 
    427          		((StateCnlTRTpCnDsc*)pvTpCn)->lCapicity_CNL;
    428          		((StateTpCnDsc*)pvStateTpCnDsc)-> chTotalLDC_CNL_M2m = 
    429          		((StateCnlTRTpCnDsc*)pvTpCn)->chTotalLDC_CNL;
    430          		
    431           		break;
    432          	case ID_CNL_SPI:
    433           		((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_Spi =
    434          		((StateCnlTRTpCnDsc*)pvTpCn)->uchTpState_CNL;
    435          		   
    436          		(((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_Spi) =
    437          		((StateCnlTRTpCnDsc*)pvTpCn)->shPayloadLPDU;
    438          		   
    439          		((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_Spi = 
    440          		((StateCnlTRTpCnDsc*)pvTpCn)->lCapicity_CNL;
    441          		((StateTpCnDsc*)pvStateTpCnDsc)-> chTotalLDC_CNL_Spi = 
    442          		((StateCnlTRTpCnDsc*)pvTpCn)->chTotalLDC_CNL;
    443          		
    444           		break;
    445          		
    446          //.	case 6:
    447          //.	
    448          //.		break;
    449          	default:
    450          	lID_Cnl =0;
    451          	}	
    452          
    453          return lID_Cnl;
    454          }
    455          long GetStateCnlTpCn(long lID_Cnl,void* pvStateTpCnDsc, void* pvTpCn)  @ "Fast_function"
    456          {
    457          switch (lID_Cnl)
    458          	{
    459          	case ID_CNL_TEST1:
    460          		((StateCnlTRTpCnDsc*)pvTpCn)->uchTpState_CNL = 
    461          		((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_1;
    462          		
    463          		((StateCnlTRTpCnDsc*)pvTpCn)->shPayloadLPDU  = 
    464          		(((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_CNL_1);
    465          		((StateCnlTRTpCnDsc*)pvTpCn)->lCapicity_CNL  = 
    466          		((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_1;
    467          		((StateCnlTRTpCnDsc*)pvTpCn)->pUchLpuTR_CNL  = 
    468          		(((StateTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL_1);		
    469          		//.j = ((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_1;
    470          	    //.i = ((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_1;
    471          		//.sLV.IdxLpuBuf = (((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_CNL_1)
    472          		//.- (((StateTpCnDsc*)pvStateTpCnDsc)->lCapicity_CNL_1);
    473          		//.sLV.pUchTR = (((StateTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL_1);
    474          		break;
    475          	case ID_CNL_HSU7:
    476          		
    477          		//.j = ((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_HSU7;
    478          	    //.i = ((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_HSU7;
    479          		//.sLV.IdxLpuBuf = (((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_HSU7)
    480          		//.- (((StateTpCnDsc*)pvStateTpCnDsc)->lCapicity_CNL_HSU7);
    481          		//.sLV.pUchTR = (((StateTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL_HSU7);
    482          		((StateCnlTRTpCnDsc*)pvTpCn)->uchTpState_CNL = 
    483          		((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_HSU7;
    484          		((StateCnlTRTpCnDsc*)pvTpCn)->chTotalLDC_CNL = 
    485          		((StateTpCnDsc*)pvStateTpCnDsc)-> chTotalLDC_CNL_HSU7;
    486          		
    487          		((StateCnlTRTpCnDsc*)pvTpCn)->shPayloadLPDU  = 
    488          		(((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_HSU7);
    489          		((StateCnlTRTpCnDsc*)pvTpCn)->lCapicity_CNL  = 
    490          		((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_HSU7;
    491          		((StateCnlTRTpCnDsc*)pvTpCn)->pUchLpuTR_CNL  = 
    492          		(((StateTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL_HSU7);	
    493          		
    494          		break;
    495          	case ID_CNL_HSU2:
    496          	    ((StateCnlTRTpCnDsc*)pvTpCn)->uchTpState_CNL = 
    497          		((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_HSU2;
    498          		((StateCnlTRTpCnDsc*)pvTpCn)->chTotalLDC_CNL = 
    499          		((StateTpCnDsc*)pvStateTpCnDsc)-> chTotalLDC_CNL_HSU2;
    500          		
    501          		((StateCnlTRTpCnDsc*)pvTpCn)->shPayloadLPDU  = 
    502          		(((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_HSU2);
    503          		((StateCnlTRTpCnDsc*)pvTpCn)->lCapicity_CNL  = 
    504          		((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_HSU2;
    505          		((StateCnlTRTpCnDsc*)pvTpCn)->pUchLpuTR_CNL  = 
    506          		(((StateTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL_HSU2);	
    507          		
    508          		break;
    509          		case ID_CNL_M2M:
    510          	    ((StateCnlTRTpCnDsc*)pvTpCn)->uchTpState_CNL = 
    511          		((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_M2m;
    512          		((StateCnlTRTpCnDsc*)pvTpCn)->chTotalLDC_CNL = 
    513          		((StateTpCnDsc*)pvStateTpCnDsc)-> chTotalLDC_CNL_M2m;
    514          		
    515          		((StateCnlTRTpCnDsc*)pvTpCn)->shPayloadLPDU  = 
    516          		(((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_M2m);
    517          		((StateCnlTRTpCnDsc*)pvTpCn)->lCapicity_CNL  = 
    518          		((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_M2m;
    519          		((StateCnlTRTpCnDsc*)pvTpCn)->pUchLpuTR_CNL  = 
    520          		(((StateTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL_M2m);	
    521          		
    522          		break;	
    523          	case ID_CNL_SPI:
    524          	    ((StateCnlTRTpCnDsc*)pvTpCn)->uchTpState_CNL = 
    525          		((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_Spi;
    526          		((StateCnlTRTpCnDsc*)pvTpCn)->chTotalLDC_CNL = 
    527          		((StateTpCnDsc*)pvStateTpCnDsc)-> chTotalLDC_CNL_Spi;
    528          		
    529          		((StateCnlTRTpCnDsc*)pvTpCn)->shPayloadLPDU  = 
    530          		(((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_Spi);
    531          		((StateCnlTRTpCnDsc*)pvTpCn)->lCapicity_CNL  = 
    532          		((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_Spi;
    533          		((StateCnlTRTpCnDsc*)pvTpCn)->pUchLpuTR_CNL  = 
    534          		(((StateTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL_Spi);	
    535          		
    536          		break;	
    537          	
    538          //.	case 6:
    539          //.	
    540          //.		break;
    541          	default:
    542          	lID_Cnl =0;
    543          	}	
    544          
    545          return lID_Cnl;
    546          }
    547          long SetFld_TpState_CNL(long lID_Cnl,void* pvStateTpCnDsc,long lV);
    548          long GetFld_TpState_CNL(long lID_Cnl);
    549          int ServiceTRApCn2(void* pvCTpuTR,void* pvStateTpCnDsc )   @ "Fast_function"
    550          {
    551          register long i,j;
    552          register void *pv;
    553          struct 
    554          	{
    555          
    556          		char chFld1,chFld2,chFld3,chFld4;
    557          		char AuxSesFldWeight,chRetCode;
    558          		char chIDCNL;
    559          		unsigned short ConState,IdxLpuBuf;
    560          		unsigned short ushTrCount;
    561          		unsigned short ushCapicity;
    562          		unsigned short ushSizeLDC;
    563          	    unsigned char *pUchTR;//
    564          		void  *pOriginTR, *pOriginTpCn;
    565          		
    566          	} sLV;
    567          	
    568              union 
    569          	    {
    570          	    	unsigned char   uchAr [4];
    571          	    	unsigned short  ushAr [2];
    572                      unsigned long   ulVal;
    573          	    }unnV1;
    574          LDCIDsc hldLDCI;
    575          StateCnlTRTpCnDsc hldStateCnlTRTpCnDsc;	
    576          //Save pointers
    577          sLV.pOriginTR     = pvCTpuTR;
    578          sLV.pOriginTpCn   = pvStateTpCnDsc;
    579          //sLV.pUchTR  = ((StateTpCnDsc*)pvStateTpCnDsc)->pUchLpuTR_CNL_HSU7;
    580          //Detect channell
    581              i = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->uchUsedTransport;
    582          	sLV.chIDCNL = i;
    583          	sLV.chFld4 = sLV.chFld3 = sLV.chFld2 = sLV.chFld1= sLV.chRetCode = 0;
    584              GetStateCnlTpCn(i,pvStateTpCnDsc,(void*)&hldStateCnlTRTpCnDsc );
    585          	
    586          	
    587          	pvStateTpCnDsc = (void*)&hldStateCnlTRTpCnDsc;
    588          	sLV.IdxLpuBuf = (((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> shPayloadLPDU);
    589          	sLV.pUchTR  = ((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL;
    590          	//.(((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL);
    591          	//((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL;
    592              //...j = ((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_1;
    593          	//...i = ((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_1;
    594              j = ((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL;
    595          	i = ((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL;
    596          	
    597          	sLV.chRetCode = 0;sLV.chFld2 = 0;
    598          	if (i<4 && j )
    599          	{
    600          		sLV.chRetCode |= (1<<7);
    601          		return sLV.chRetCode;//Capicity full
    602          	}	
    603          	//-sLV.ConState    = 0;sLV.ushTrCount  = 0;	sLV.ushCapicity = 0;
    604          	sLV.ushSizeLDC  = 0;
    605          	sLV.ushCapicity = i;sLV.chFld4 = j;
    606          	sLV.AuxSesFldWeight = SIZE_WLDC_FLD;//.!!! Insert Control using sLV.chIDCNL 
    607          	//Detect State 	CTpuTR side
    608          	//..sLV.ch1 = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->uchBaseTransport;
    609          	//..sLV.ch2 = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->uchUsedTransport;
    610          	//..sLV.ch3 = i = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->ConState;
    611          	i = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->SizeAppObj;
    612          	sLV. ushTrCount = j = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->ulTrCount;
    613          	if(i>j)
    614          	;
    615          	else
    616          	{
    617          		//Terminate Transport
    618          	}
    619          
    620          	//Detect state TpCn side
    621          	//if (sLV. ushTrCount)
    622          	if (j==0)
    623          	{
    624          		//Start Sesion
    625          		i = sLV.ushCapicity - sLV.AuxSesFldWeight;
    626          		if (i >(((TRBaseCTpuUnitDsc*)pvCTpuTR)->uchSizeCTpuBuf)) 
    627          		{
    628          			i = (((TRBaseCTpuUnitDsc*)pvCTpuTR)->uchSizeCTpuBuf);
    629          			i -= sLV.AuxSesFldWeight;//sLV.ushCapicity - sLV.AuxSesFldWeight;
    630          		}	
    631          		if (i>(((TRBaseCTpuUnitDsc*)pvCTpuTR)->SizeAppObj))
    632          		{
    633          			pv = (void*)&hldLDCI;
    634          			((LDCIDsc*)pv)->uchConMode     = 0;
    635          			((LDCIDsc*)pv)->uchStartSesion = 1;
    636          			((LDCIDsc*)pv)->uchTR_C        = (((TRBaseCTpuUnitDsc*)pvCTpuTR)->SizeAppObj);//Size
    637          			((LDCIDsc*)pv)->NumComSes      = 0;
    638          			((LDCIDsc*)pv)->IdConObj       = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->IdConObj;
    639          			((LDCIDsc*)pv)->pSrc           = (char*)(((TRBaseCTpuUnitDsc*)pvCTpuTR)->pUchTR);
    640          			//...j = (((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_CNL_1)
    641          			//...- (((StateTpCnDsc*)pvStateTpCnDsc)->lCapicity_CNL_1);//Actual Index lpu buf
    642          			j =((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> shPayloadLPDU;
    643          			//-((StateCnlTRTpCnDsc*)pvStateTpCnDsc)->lCapicity_CNL;
    644          			sLV.IdxLpuBuf = j;
    645          			
    646          			((LDCIDsc*)pv)->pDst           = (char*)(j +sLV.pUchTR);//(SIZE_LPDU_CNL1)
    647          			//...(((StateTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL_1));//+ ((LDCIDsc*)pv)->uchTR_C -old 
    648          			;
    649          			//Call Assembly Routine
    650          			sLV.ushSizeLDC  =  AsemblyLDC(&hldLDCI);
    651          			//Reset Var need for Transmit
    652          			((TRBaseCTpuUnitDsc*)pvCTpuTR)->ulTrCount = 0;
    653          			((TRBaseCTpuUnitDsc*)pvCTpuTR)->ConState  = 0;//SUCCESS_EXEC???
    654          			
    655          			//...j =((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_1;j++;
    656          			//...((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_1 = j;
    657          			//..j = SetCnlStatetoRun(sLV.chIDCNL,sLV.pOriginTpCn,pvStateTpCnDsc);//
    658          			j =((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL;j++;
    659          			((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL = j;
    660          			
    661          			
    662          			
    663          			j = ((LDCIDsc*)pv)->uchTR_C;j = sLV.ushSizeLDC;// + sLV.AuxSesFldWeight;
    664          			//...((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_1 -= j;
    665          			//...CutCnlCapicity(sLV.chIDCNL);
    666          			((StateCnlTRTpCnDsc*)pvStateTpCnDsc)->lCapicity_CNL -= j+(SIZE_WLDC_FLD);
    667          			(((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> shPayloadLPDU) += j+(SIZE_WLDC_FLD);
    668          			(((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> chTotalLDC_CNL) += 1;
    669          			unnV1.ulVal = SetStateCnlTpCn(sLV.chIDCNL,sLV.pOriginTpCn,pvStateTpCnDsc);
    670          			//Terminate Session Curr Obj
    671          			sLV.chRetCode |= (1<<6);
    672          		}
    673          		else
    674          		{
    675          			i = sLV.ushCapicity - sLV.AuxSesFldWeight;
    676          			i -= (SIZE_ID_COM_SES + SIZE_NUM_COM_SES ); //+ SIZE_TR_C
    677          			if (i> 4)//-Minimal Size LDC((TRBaseCTpuUnitDsc*)pvCTpuTR)->SizeAppObj
    678          			{
    679          			
    680          				if (i >(((TRBaseCTpuUnitDsc*)pvCTpuTR)->uchSizeCTpuBuf)) 
    681          				{
    682          					i = (((TRBaseCTpuUnitDsc*)pvCTpuTR)->uchSizeCTpuBuf);
    683          					i -=sLV.AuxSesFldWeight+(SIZE_ID_COM_SES + SIZE_NUM_COM_SES );
    684          				}	
    685          				//Cut Obj
    686          				pv = (void*)&hldLDCI;
    687          				((LDCIDsc*)pv)->IdConObj       = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->IdConObj;
    688          				((LDCIDsc*)pv)->pSrc           = (char*)(((TRBaseCTpuUnitDsc*)pvCTpuTR)->pUchTR);
    689          				
    690          				((LDCIDsc*)pv)->uchConMode     = 1;
    691          				((LDCIDsc*)pv)->uchStartSesion = 1;
    692          				((LDCIDsc*)pv)->uchTR_C        = i;//now full chan Load
    693          				//(((TRBaseCTpuUnitDsc*)pvCTpuTR)->SizeAppObj);//Size
    694          				//if (((TRBaseCTpuUnitDsc*)pvCTpuTR)->ConState)
    695          				//{
    696          				//	
    697          				//	((LDCIDsc*)pv)->NumComSes = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->NumComSes;
    698          				//}
    699          				//else
    700          				{
    701          					j = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->NumComSes;j++;//Start Sesison
    702          					//((LDCIDsc*)pv)->NumComSes;j++;
    703          					if(j>=16) j=1;
    704          					((LDCIDsc*)pv)->NumComSes      = j;
    705          				
    706          				}
    707          				//Теоретически tut весь объект можно было-бы порезать на куски
    708          				//разной величины и каждому куску дать свой идентификатор
    709          				//затем после получения в буфер кусков по идентификаторам можно собрать объект
    710          				//если какого-то куска не хватает то его можно перезапросить
    711          				
    712          				//.j = (((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_CNL_1)
    713          				//.- (((StateTpCnDsc*)pvStateTpCnDsc)->lCapicity_CNL_1);//Actual Index lpu buf
    714          				j = ((StateCnlTRTpCnDsc*)pvStateTpCnDsc)->shPayloadLPDU;
    715          				sLV.IdxLpuBuf = j;//-1;
    716          				
    717          				((LDCIDsc*)pv)->pDst           = (char*)(j +//
    718          				((StateCnlTRTpCnDsc*)pvStateTpCnDsc)->pUchLpuTR_CNL);
    719          				
    720          				sLV.ushSizeLDC  =  AsemblyLDC(&hldLDCI);
    721          				
    722          				((TRBaseCTpuUnitDsc*)pvCTpuTR)->ulTrCount = ((LDCIDsc*)pv)->uchTR_C; //sLV.ushSizeLDC;
    723          			    ((TRBaseCTpuUnitDsc*)pvCTpuTR)->ConState  = 1;//
    724          				((TRBaseCTpuUnitDsc*)pvCTpuTR)->NumComSes = ((LDCIDsc*)pv)->NumComSes;
    725          				sLV.chFld2 = ((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL;
    726          				j = 0x7f&sLV.chFld2; j++;sLV.chFld2 &=0x80;//j =((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL;j++;
    727          				((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL = j|sLV.chFld2;
    728          				j = ((LDCIDsc*)pv)->uchTR_C;j = sLV.ushSizeLDC;// + sLV.AuxSesFldWeight;
    729          				
    730          				((StateCnlTRTpCnDsc*)pvStateTpCnDsc)->lCapicity_CNL -= j+(SIZE_WLDC_FLD);
    731          				(((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> shPayloadLPDU) += j+(SIZE_WLDC_FLD);
    732          				(((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> chTotalLDC_CNL) += 1;
    733          				unnV1.ulVal = SetStateCnlTpCn(sLV.chIDCNL,sLV.pOriginTpCn,pvStateTpCnDsc);
    734          				sLV.chRetCode |= (1<<5);//Start Sesion
    735          			
    736          			}
    737          			else
    738          			{
    739          				;//Terminate Transport
    740          				((LDCIDsc*)pv)->uchConMode     = 0;
    741          				sLV.chRetCode |= (1<<7);
    742          			}
    743          			
    744          		}	
    745          	}
    746          	else
    747          	{ 
    748          		i = sLV.ushCapicity - sLV.AuxSesFldWeight;
    749          		i -= (SIZE_ID_COM_SES + SIZE_NUM_COM_SES ); //+ SIZE_TR_C
    750          		if (i> 4)//-Minimal Size LDC((TRBaseCTpuUnitDsc*)pvCTpuTR)->SizeAppObj
    751          		{
    752          			if (i >(((TRBaseCTpuUnitDsc*)pvCTpuTR)->uchSizeCTpuBuf)) 
    753          			{
    754          				i = (((TRBaseCTpuUnitDsc*)pvCTpuTR)->uchSizeCTpuBuf);
    755          				i -= sLV.AuxSesFldWeight + (SIZE_ID_COM_SES + SIZE_NUM_COM_SES );
    756          			}	
    757          			unnV1.ushAr [0] = i;//
    758          			i = (((TRBaseCTpuUnitDsc*)pvCTpuTR)->SizeAppObj);
    759          			j = (((TRBaseCTpuUnitDsc*)pvCTpuTR)->ulTrCount);
    760          			if( j <i)
    761          			{
    762          				//sLV.AuxSesFldWeight = SIZE_WLDC_FLD  +  SIZE_ID_COM_SES  + SIZE_NUM_COM_SES;
    763          				//i = unnV1.ushAr [0];//Actual Capicity
    764          				unnV1.ushAr [1]  = i- j;
    765          				if (unnV1.ushAr [1]<unnV1.ushAr [0])
    766          				{
    767          					sLV.ushTrCount = unnV1.ushAr [1];//Last Transmision
    768          					//((LDCIDsc*)pv)->uchConMode     = 1;//
    769          					sLV.chFld1 = 1;//end of Session
    770          				}
    771          				else
    772          				{
    773          					sLV.ushTrCount = unnV1.ushAr [0];//Order Transmision
    774          					//sLV.ushTrCount += unnV1.ushAr [0];
    775          					sLV.chFld1 = 0;
    776          				}
    777          				pv = (void*)&hldLDCI;
    778          				((LDCIDsc*)pv)->uchConMode     =  1;//
    779          				((LDCIDsc*)pv)->uchStartSesion = 0;
    780          				((LDCIDsc*)pv)->uchTR_C        = sLV.ushTrCount;//unnV1.ushAr [0];//Size curr portion
    781          				((LDCIDsc*)pv)->NumComSes      = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->NumComSes;
    782          				((LDCIDsc*)pv)->IdConObj       = ((TRBaseCTpuUnitDsc*)pvCTpuTR)->IdConObj;
    783          				((LDCIDsc*)pv)->pSrc           = (char*)(
    784          				(((TRBaseCTpuUnitDsc*)pvCTpuTR)->pUchTR ) + j);
    785          				
    786          				//...sLV.IdxLpuBuf = (((StateTpCnDsc*)pvStateTpCnDsc)-> PayloadLPDU_CNL_1)
    787          				//...- (((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_1);
    788          				sLV.IdxLpuBuf = (((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> shPayloadLPDU);
    789          				
    790          				
    791          				//...((LDCIDsc*)pv)->pDst           = (char*)((StateTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL_1
    792          				//...+ sLV.IdxLpuBuf;
    793          				((LDCIDsc*)pv)->pDst           = (char*)((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL
    794          				+ sLV.IdxLpuBuf;
    795          				sLV.ushSizeLDC  =  AsemblyLDC(&hldLDCI);
    796          				
    797          				j = (((TRBaseCTpuUnitDsc*)pvCTpuTR)->ulTrCount);
    798          				((TRBaseCTpuUnitDsc*)pvCTpuTR)->ulTrCount = sLV.ushTrCount + j;
    799          				//(((TRBaseCTpuUnitDsc*)pvCTpuTR)->ulTrCount) == (((TRBaseCTpuUnitDsc*)pvCTpuTR)->SizeAppObj)
    800          				if ( sLV.chFld1 == 1)//sLV.chFld4||
    801          				{
    802          					((TRBaseCTpuUnitDsc*)pvCTpuTR)->ConState  = 0;//;//close session
    803          					sLV.chRetCode |= (1<<6);//Terminate Session Curr Obj Activate timeOut prepea transmit
    804          					sLV.chFld2 = ((StateCnlTRTpCnDsc*)pvStateTpCnDsc)->uchTpState_CNL;
    805          					j = 0x7f&sLV.chFld2; j++;sLV.chFld2 &=0x80;
    806          					((StateCnlTRTpCnDsc*)pvStateTpCnDsc)->uchTpState_CNL = j|(sLV.chFld2);
    807          					//Activate Timer
    808          				}
    809          				else ((TRBaseCTpuUnitDsc*)pvCTpuTR)->ConState  = 1;//
    810          				
    811          				sLV.chFld2 = ((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL;
    812          				j = 0x7f&sLV.chFld2; j++;sLV.chFld2 &=0x80;
    813          				((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL = j|sLV.chFld2;
    814          				j = ((LDCIDsc*)pv)->uchTR_C;j = sLV.ushSizeLDC;// + sLV.AuxSesFldWeight;
    815          				
    816          				((StateCnlTRTpCnDsc*)pvStateTpCnDsc)->lCapicity_CNL -= j+(SIZE_WLDC_FLD);
    817          				(((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> shPayloadLPDU) += j+(SIZE_WLDC_FLD);
    818          				(((StateCnlTRTpCnDsc*)pvStateTpCnDsc)-> chTotalLDC_CNL) += 1;
    819          				unnV1.ulVal = SetStateCnlTpCn(sLV.chIDCNL,sLV.pOriginTpCn,pvStateTpCnDsc);
    820          				sLV.chRetCode |= (1<<5);//Continiue Sesion
    821          			}
    822          			else
    823          			{
    824          				sLV.chRetCode |= (1<<6);;//Terminate Session Curr Obj
    825          			}
    826          			
    827          			
    828          		}
    829          		else
    830          		{
    831          			sLV.chRetCode |= (1<<7);;//Terminate Transport
    832          		}
    833          		
    834          	
    835          	}
    836          	
    837          //Prepea transmision data
    838          
    839          
    840          //Put 	transmision data
    841          //AsemblyLDC:
    842          
    843          
    844          	if( (((StateCnlTRTpCnDsc*)pvStateTpCnDsc)->lCapicity_CNL) < 4)
    845          	{
    846          		sLV.chRetCode |= (1<<7);
    847          		j =  GetFld_TpState_CNL(sLV.chIDCNL);
    848          		SetFld_TpState_CNL(sLV.chIDCNL,sLV.pOriginTpCn,j|(1<<7));
    849          	}	
    850          	return sLV.chRetCode ;
    851          	
    852          //((EmrEventDsc*)p_out_param)->EvtField	
    853          }
    854          #define SIZE_WLDC_FLD     1
    855          #define SIZE_ID_COM_SES   2
    856          #define SIZE_NUM_COM_SES  1
    857          #define SIZE_TR_C         1
    858          
    859          
    860          #define HDR_IDX_SIZE_LDC        0
    861          #define HDR_IDX_ID_COM_SES      HDR_IDX_SIZE_LDC    + SIZE_WLDC_FLD
    862          #define HDR_IDX_NUM_COM_SES     HDR_IDX_ID_COM_SES  + SIZE_ID_COM_SES
    863          #define HDR_IDX_TR_C            HDR_IDX_NUM_COM_SES + SIZE_NUM_COM_SES
    864          
    865          int AsemblyLDC(void *pvLDCInfo)   @ "Fast_function"
    866          {
    867          register long i,j;
    868          register char *pSrc,*pDst;
    869          struct 
    870          	{
    871          		unsigned char uchTR_C;
    872          		unsigned char uChIdxByte ;
    873          		//unsigned char uChIdxBit ;
    874          		//short shErr;
    875          		unsigned short ushSizeLDC;
    876          		
    877          	    //.unsigned char *pUchTR;//
    878          		
    879          		
    880          	} sLV;
    881          union 
    882              {
    883              	unsigned char   uchAr [4];
    884              	unsigned short  ushAr [2];
    885                  unsigned long   ulVal;
    886              }unnV1;
    887          	
    888          	sLV.ushSizeLDC = 0;
    889          	sLV.uChIdxByte = SIZE_WLDC_FLD;//Pointer In LDC Buf
    890          	pSrc = (char*) ((LDCIDsc*)pvLDCInfo)->pSrc;
    891          	pDst = (char*) ((LDCIDsc*)pvLDCInfo)->pDst;
    892          	i = ((LDCIDsc*)pvLDCInfo)->IdConObj; 
    893          	if( ((LDCIDsc*)pvLDCInfo)->uchConMode == 0)
    894          	{
    895          		unnV1.ushAr [0] = (unsigned short)i<<1;
    896          		pDst[HDR_IDX_ID_COM_SES]	 = unnV1.uchAr[0];
    897          		pDst[(HDR_IDX_ID_COM_SES)+1] = unnV1.uchAr[1];
    898          		sLV.uChIdxByte += SIZE_ID_COM_SES;
    899          		sLV.ushSizeLDC += SIZE_ID_COM_SES;
    900          	
    901          	}
    902          	else
    903          	{
    904          		unnV1.ushAr [0] = (unsigned short) (i<<1)|1;
    905          		pDst[HDR_IDX_ID_COM_SES]	 = unnV1.uchAr[0];
    906          		pDst[(HDR_IDX_ID_COM_SES)+1] = unnV1.uchAr[1];
    907           
    908          		sLV.uChIdxByte += SIZE_ID_COM_SES;
    909          		sLV.ushSizeLDC += SIZE_ID_COM_SES;
    910          		i = ((LDCIDsc*)pvLDCInfo)-> NumComSes;
    911          		i <<= 4;
    912          		if (((LDCIDsc*)pvLDCInfo)->uchStartSesion )
    913          		{
    914          			pDst[HDR_IDX_NUM_COM_SES] = i | (1<<START_SES_FLD_ONB);
    915          		}
    916          		else
    917          		{
    918          			pDst[HDR_IDX_NUM_COM_SES] = i;
    919          		}
    920          		sLV.uChIdxByte += SIZE_NUM_COM_SES;
    921          		sLV.ushSizeLDC += SIZE_NUM_COM_SES;
    922          		//((LDCIDsc*)pvLDCInfo)-> 
    923          	}
    924          	sLV.uchTR_C = ((LDCIDsc*)pvLDCInfo)-> uchTR_C;//size
    925          	j = sLV.uChIdxByte;
    926          	for (i = 0;i< (sLV.uchTR_C);i++)
    927          	{
    928          		pDst[i+j] = pSrc[i];
    929          	}   
    930          	
    931          	sLV.ushSizeLDC += sLV.uchTR_C;
    932          	pDst[HDR_IDX_SIZE_LDC] = (char)sLV.ushSizeLDC;//Put Size LDC
    933          	
    934          return (int)sLV.ushSizeLDC;
    935          }
    936          int ScanCn1(void *pLpuCn1 )   @ "Fast_function"
    937          {
    938          register long i,j;
    939          register void *pv;
    940          union 
    941          {
    942          	unsigned char   uchAr [4];
    943          	unsigned short  ushAr [2];
    944              unsigned long   ulVal;
    945          }unnV1;
    946          struct 
    947          	{
    948          
    949          		//char chFld1,chFld2,chFld3,chFld4;
    950          		char AuxSesFldWeight,chRetCode;
    951          		char IdxLpuBuf,chTotalLDC;
    952          		//unsigned short ConState;
    953          		unsigned short ushSzCurrLDC;//ushRvCount;
    954          		//unsigned short ushCapicity;
    955          		unsigned short ushSizeLDC;
    956          	    unsigned char *pUchRV;//
    957          		void  *pOriginLpu;//, *pOriginTpCn;
    958          		
    959          	} sLV;
    960          LDCIDsc hldLDCI;
    961          	//
    962          	sLV.pOriginLpu  = pLpuCn1;
    963          	sLV.chTotalLDC  = 0;
    964          	sLV.ushSizeLDC  =  ((RVStateLpuCn1Dsc*)pLpuCn1)->ushSizeLDC;
    965          	//Find Idx
    966          	i = ((RVStateLpuCn1Dsc*)pLpuCn1)->uchCI;
    967          	switch (i )
    968          	{
    969          		case 0:
    970          			sLV.IdxLpuBuf = 1;
    971          		break;
    972          		case 1:
    973          			sLV.IdxLpuBuf = 2;
    974          		break;
    975          		case 2://
    976          			sLV.IdxLpuBuf = 3;
    977          		break;
    978          	 default:
    979          		sLV.IdxLpuBuf = 2;
    980          	}
    981          	j = sLV.IdxLpuBuf;//Skip Aux Data In Buf
    982          	sLV.pUchRV = &(((RVStateLpuCn1Dsc*)pLpuCn1)->arUch[j]);//! Be Carefull!!!/
    983          	pLpuCn1 = (void*)&hldLDCI;
    984          	while (sLV.ushSizeLDC)
    985          	{
    986          		;//Get Size curr LDC
    987          		j = sLV.IdxLpuBuf;
    988          		pv = (void*)(sLV.pUchRV+j);
    989          		unnV1.uchAr[0] = *((char*)pv);
    990          		((LDCIDsc*)pLpuCn1)-> uchTR_C = unnV1.uchAr[0];
    991          		sLV.ushSzCurrLDC = unnV1.uchAr[0];//
    992          		
    993          		j = (SIZE_WLDC_FLD) + sLV.IdxLpuBuf;
    994          		pv = (void*)(sLV.pUchRV + j);
    995          		unnV1.uchAr[2] = (unsigned char) *((char*)pv);
    996          		unnV1.uchAr[3] = (unsigned char) *((char*)pv+1);
    997          		i = unnV1.ushAr[1];
    998          		((LDCIDsc*)pLpuCn1)->uchConMode = i&1;
    999          		((LDCIDsc*)pLpuCn1)->IdConObj   = i>>1;
   1000          		if( ((LDCIDsc*)pLpuCn1)->uchConMode == 0)
   1001          		{
   1002          			((LDCIDsc*)pLpuCn1)-> uchTR_C = sLV.ushSzCurrLDC - ((SIZE_ID_COM_SES));
   1003          			j = (SIZE_WLDC_FLD) + sLV.IdxLpuBuf+(SIZE_ID_COM_SES);
   1004          			((LDCIDsc*)pLpuCn1)->pSrc = (char*)(sLV.pUchRV + j);
   1005          			((LDCIDsc*)pLpuCn1)->pDst = (char*)0;
   1006          			ExtractLdc((void*)&hldLDCI);
   1007          			
   1008          		}
   1009          		else
   1010          		{
   1011          			j = (SIZE_WLDC_FLD) + sLV.IdxLpuBuf+(SIZE_ID_COM_SES);
   1012          			pv = (void*)(sLV.pUchRV+j);
   1013          			unnV1.uchAr[0] = *((char*)pv);
   1014          			i = unnV1.uchAr[0];
   1015          			((LDCIDsc*)pLpuCn1)-> NumComSes = i;
   1016          			if ( i & (1<<START_SES_FLD_ONB))
   1017          			{
   1018          				((LDCIDsc*)pLpuCn1)-> uchStartSesion = i & (1<<START_SES_FLD_ONB);
   1019          			}
   1020          			else
   1021          			((LDCIDsc*)pLpuCn1)-> uchStartSesion = 0;
   1022          			//((LDCIDsc*)pLpuCn1)-> uchTR_C = sLV.ushSzCurrLDC - ((SIZE_ID_COM_SES));
   1023          			//j = (SIZE_WLDC_FLD) + sLV.IdxLpuBuf+(SIZE_ID_COM_SES);
   1024          			//((LDCIDsc*)pLpuCn1)->pSrc = (char*)(sLV.pUchRV + j)
   1025          			//((LDCIDsc*)pLpuCn1)->pDst = (char*)0;
   1026          			ExtractLdc((void*)&hldLDCI);
   1027          		
   1028          		}	
   1029          
   1030          	}
   1031          	
   1032          return 0;
   1033          }
   1034          long GetRVStateLpuCnl(long lID_Cnl,void* pvHolderRVStateLpuCnl, void* pvRVStateLpuCnl)   @ "Fast_function"
   1035          {
   1036          switch (lID_Cnl)
   1037          	{
   1038          	case ID_CNL_TEST1:
   1039          		//.((StateCnlTRTpCnDsc*)pvTpCn)->uchTpState_CNL = 
   1040          		//.((StateTpCnDsc*)pvStateTpCnDsc)-> uchTpState_CNL_1;
   1041          		//.
   1042          		//.((StateCnlTRTpCnDsc*)pvTpCn)->shPayloadLPDU  = 
   1043          		//.(((StateTpCnDsc*)pvStateTpCnDsc)->PayloadLPDU_CNL_1);
   1044          		//.((StateCnlTRTpCnDsc*)pvTpCn)->lCapicity_CNL  = 
   1045          		//.((StateTpCnDsc*)pvStateTpCnDsc)-> lCapicity_CNL_1;
   1046          		//.((StateCnlTRTpCnDsc*)pvTpCn)->pUchLpuTR_CNL  = 
   1047          		//.(((StateTpCnDsc*)pvStateTpCnDsc)-> pUchLpuTR_CNL_1);		
   1048          		
   1049          		break;
   1050          	case ID_CNL_HSU7:
   1051          		
   1052          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->lCapicity = 
   1053          		((RVStateLpuHSU7Dsc*)pvHolderRVStateLpuCnl)-> lCapicity;
   1054          		
   1055          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->pUch = &
   1056          		(((RVStateLpuHSU7Dsc*)pvHolderRVStateLpuCnl)->  arUch[0]);
   1057          		
   1058          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->uchLpuCn1State = 
   1059          		((RVStateLpuHSU7Dsc*)pvHolderRVStateLpuCnl)-> uchLpuHSU7State;
   1060          		
   1061          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->uchCI = 
   1062          		((RVStateLpuHSU7Dsc*)pvHolderRVStateLpuCnl)-> uchCI;
   1063          		
   1064          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->ushSizeLDC = 
   1065          		((RVStateLpuHSU7Dsc*)pvHolderRVStateLpuCnl)-> ushSizeLDC;
   1066          		
   1067          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->lCs = 
   1068          		((RVStateLpuHSU7Dsc*)pvHolderRVStateLpuCnl)-> lCs;
   1069          		
   1070          		break;
   1071           	case ID_CNL_HSU2:
   1072           		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->lCapicity = 
   1073          		((RVStateLpuHSU2Dsc*)pvHolderRVStateLpuCnl)-> lCapicity;
   1074          		
   1075          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->pUch = &
   1076          		(((RVStateLpuHSU2Dsc*)pvHolderRVStateLpuCnl)->  arUch[0]);
   1077          		
   1078          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->uchLpuCn1State = 
   1079          		((RVStateLpuHSU2Dsc*)pvHolderRVStateLpuCnl)-> uchLpuHSU2State;
   1080          		
   1081          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->uchCI = 
   1082          		((RVStateLpuHSU2Dsc*)pvHolderRVStateLpuCnl)-> uchCI;
   1083          		
   1084          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->ushSizeLDC = 
   1085          		((RVStateLpuHSU2Dsc*)pvHolderRVStateLpuCnl)-> ushSizeLDC;
   1086          		
   1087          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->lCs = 
   1088          		((RVStateLpuHSU2Dsc*)pvHolderRVStateLpuCnl)-> lCs;
   1089           		break;
   1090          	case ID_CNL_M2M:
   1091          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->lCapicity = 
   1092          		((RVStateLpuM2mDsc*)pvHolderRVStateLpuCnl)-> lCapicity;
   1093          		
   1094          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->pUch = &
   1095          		(((RVStateLpuM2mDsc*)pvHolderRVStateLpuCnl)->  arUch[0]);
   1096          		
   1097          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->uchLpuCn1State = 
   1098          		((RVStateLpuM2mDsc*)pvHolderRVStateLpuCnl)-> uchLpuM2mState;
   1099          		
   1100          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->uchCI = 
   1101          		((RVStateLpuM2mDsc*)pvHolderRVStateLpuCnl)-> uchCI;
   1102          		
   1103          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->ushSizeLDC = 
   1104          		((RVStateLpuM2mDsc*)pvHolderRVStateLpuCnl)-> ushSizeLDC;
   1105          		
   1106          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->lCs = 
   1107          		((RVStateLpuM2mDsc*)pvHolderRVStateLpuCnl)-> lCs;
   1108          		break;
   1109          	case ID_CNL_SPI:
   1110          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->lCapicity = 
   1111          		((RVStateLpuSpiDsc*)pvHolderRVStateLpuCnl)-> lCapicity;
   1112          		
   1113          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->pUch = &
   1114          		(((RVStateLpuSpiDsc*)pvHolderRVStateLpuCnl)->  arUch[0]);
   1115          		
   1116          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->uchLpuCn1State = 
   1117          		((RVStateLpuSpiDsc*)pvHolderRVStateLpuCnl)-> uchLpuSpiState;
   1118          		
   1119          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->uchCI = 
   1120          		((RVStateLpuSpiDsc*)pvHolderRVStateLpuCnl)-> uchCI;
   1121          		
   1122          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->ushSizeLDC = 
   1123          		((RVStateLpuSpiDsc*)pvHolderRVStateLpuCnl)-> ushSizeLDC;
   1124          		
   1125          		((RVStateLpuCnlDsc*)pvRVStateLpuCnl)->lCs = 
   1126          		((RVStateLpuSpiDsc*)pvHolderRVStateLpuCnl)-> lCs;
   1127          	
   1128          		break;
   1129          //.	case 6:
   1130          //.	
   1131          //.		break;
   1132          	default:
   1133          	lID_Cnl =0;
   1134          	}	
   1135          
   1136          return lID_Cnl;
   1137          }
   1138          void* GetLpduAddr(long ID_Cnl)   @ "Fast_function"
   1139          {
   1140          struct 
   1141          	{
   1142          		void  *pLpu;
   1143          	} sLV;
   1144          switch (ID_Cnl )
   1145          	{
   1146          		case ID_CNL_HSU7:
   1147          			sLV.pLpu = (void*)&hldrHSU7LpduUnit;
   1148          		break;
   1149          		case ID_CNL_TEST1:
   1150          			sLV.pLpu = (void*)&hldrCn1LpduUnit;
   1151          		break;
   1152          		case ID_CNL_HSU2://
   1153          			sLV.pLpu = (void*)&hldrHSU2LpduUnit;
   1154          		break;
   1155          		case ID_CNL_M2M://
   1156          			sLV.pLpu = (void*)&hldrM2mLpduUnit;
   1157          		break;
   1158          		case ID_CNL_SPI://
   1159          			sLV.pLpu = (void*)&hldrSpiLpduUnit;
   1160          		break;
   1161          		
   1162          		
   1163          	 default:
   1164          		sLV.pLpu = (void*)0;
   1165          	}	
   1166          return sLV.pLpu;
   1167          } 
   1168          int ScanCnl(long lIDr)   @ "Fast_function" //void *pLpuCnl )
   1169          {
   1170          register long i,j;
   1171          register void *pv;
   1172          register void *pLpuCnl;
   1173          union 
   1174          {
   1175          	unsigned char   uchAr [4];
   1176          	unsigned short  ushAr [2];
   1177              unsigned long   ulVal;
   1178          }unnV1;
   1179          struct 
   1180          	{
   1181          
   1182          		//char chFld1,chFld2,chFld3,chFld4;
   1183          		char AuxSesFldWeight,chRetCode;
   1184          		char chTotalLDC;
   1185          		char chIDCNL;
   1186          		//unsigned short ConState;
   1187          		unsigned short IdxLpuBuf,ushSzCurrLDC;//ushRvCount;
   1188          		//unsigned short ushCapicity;
   1189          		unsigned short ushSizeLDC;
   1190          	    unsigned char *pUchRV;//
   1191          		void  *pOriginLpu;//, *pOriginTpCn;
   1192          		
   1193          	} sLV;
   1194          LDCIDsc hldLDCI;
   1195          RVStateLpuCnlDsc hldRVStateLpuCnlDsc;	
   1196          unnV1.uchAr[0] = 0x0;
   1197          	sLV.chIDCNL = lIDr;
   1198          	//Detect Id + addr
   1199          	pLpuCnl = GetLpduAddr( lIDr);
   1200          	sLV.pOriginLpu  = pLpuCnl;
   1201          	//(long lID_Cnl,void* pvHolderRVStateLpuCnl, void* pvRVStateLpuCnl)
   1202          	GetRVStateLpuCnl( lIDr,pLpuCnl,(void*)&hldRVStateLpuCnlDsc);
   1203          	pLpuCnl = (void*)&hldRVStateLpuCnlDsc;
   1204          	sLV.chTotalLDC  = 0;
   1205          	
   1206          		
   1207          	//sLV.ushSizeLDC  = ((RVStateLpuCnlDsc*)pLpuCnl)->pUch[1];//ushSizeLDC;
   1208          	//Find Idx
   1209          	i = ((RVStateLpuCnlDsc*)pLpuCnl)->pUch[0];//uchCI;
   1210          	i &= 0xf;i>>=1;
   1211          	switch (i )
   1212          	{
   1213          		case 0:
   1214          			sLV.IdxLpuBuf = 1;
   1215          		break;
   1216          		case 1:
   1217          			sLV.IdxLpuBuf = 2;
   1218          		break;
   1219          		case 2://
   1220          			sLV.IdxLpuBuf = 3;
   1221          		break;
   1222          	 default:
   1223          		sLV.IdxLpuBuf = 2;
   1224          	}
   1225          	j = sLV.IdxLpuBuf;//Skip Aux Data In Buf
   1226          	// &(((RVStateLpuCn1Dsc*)pLpuCnl)->arUch[j]);//! Be Carefull!!!/
   1227          	sLV.ushSizeLDC  = ((RVStateLpuCnlDsc*)pLpuCnl)->pUch[j];//Count LDC
   1228          	if( (sLV.ushSizeLDC>0) && (sLV.ushSizeLDC<10))
   1229          	{
   1230          	
   1231          	}
   1232          	else
   1233          	return 0xff;
   1234          	sLV.pUchRV = ((RVStateLpuCnlDsc*)pLpuCnl)->pUch;
   1235          	j++;
   1236          	sLV.IdxLpuBuf = j;
   1237          	pLpuCnl = (void*)&hldLDCI;
   1238          	while (sLV.ushSizeLDC--)
   1239          	{
   1240          		;//Get Size curr LDC
   1241          		j = sLV.IdxLpuBuf;
   1242          		pv = (void*)(sLV.pUchRV+j);
   1243          		unnV1.uchAr[0] = *((char*)pv);
   1244          		((LDCIDsc*)pLpuCnl)-> uchTR_C = unnV1.uchAr[0];
   1245          		sLV.ushSzCurrLDC = unnV1.uchAr[0];//
   1246          		
   1247          		j = (SIZE_WLDC_FLD) + sLV.IdxLpuBuf;
   1248          		pv = (void*)(sLV.pUchRV + j);
   1249          		unnV1.uchAr[2] = (unsigned char) *((char*)pv);
   1250          		unnV1.uchAr[3] = (unsigned char) *((char*)pv+1);
   1251          		i = unnV1.ushAr[1];
   1252          		((LDCIDsc*)pLpuCnl)->uchConMode = i&1;
   1253          		((LDCIDsc*)pLpuCnl)->IdConObj   = i>>1;
   1254          		if( ((LDCIDsc*)pLpuCnl)->uchConMode == 0)
   1255          		{
   1256          			((LDCIDsc*)pLpuCnl)-> uchTR_C = sLV.ushSzCurrLDC - ((SIZE_ID_COM_SES));
   1257          			j = (SIZE_WLDC_FLD) + sLV.IdxLpuBuf+(SIZE_ID_COM_SES);
   1258          			((LDCIDsc*)pLpuCnl)->pSrc = (char*)(sLV.pUchRV + j);
   1259          			((LDCIDsc*)pLpuCnl)->pDst = (char*)0;
   1260          			ExtractLdc((void*)&hldLDCI);
   1261          			sLV.IdxLpuBuf += sLV.ushSzCurrLDC+(SIZE_WLDC_FLD);
   1262          		}
   1263          		else
   1264          		{
   1265          			j = (SIZE_WLDC_FLD) + sLV.IdxLpuBuf+(SIZE_ID_COM_SES);
   1266          			pv = (void*)(sLV.pUchRV+j);
   1267          			unnV1.uchAr[0] = *((char*)pv);
   1268          			i = unnV1.uchAr[0];
   1269          			((LDCIDsc*)pLpuCnl)-> NumComSes = i;
   1270          			if ( i & (1<<START_SES_FLD_ONB))
   1271          			{
   1272          				((LDCIDsc*)pLpuCnl)-> uchStartSesion = i & (1<<START_SES_FLD_ONB);
   1273          			}
   1274          			else
   1275          			((LDCIDsc*)pLpuCnl)-> uchStartSesion = 0;
   1276          			((LDCIDsc*)pLpuCnl)-> uchTR_C = sLV.ushSzCurrLDC - ((SIZE_NUM_COM_SES)+(SIZE_ID_COM_SES));
   1277          			j = (SIZE_WLDC_FLD) + sLV.IdxLpuBuf+(SIZE_ID_COM_SES)+(SIZE_NUM_COM_SES);
   1278          			((LDCIDsc*)pLpuCnl)->pSrc = (char*)(sLV.pUchRV + j);
   1279          			((LDCIDsc*)pLpuCnl)->pDst = (char*)0;
   1280          			ExtractLdc((void*)&hldLDCI);
   1281          			sLV.IdxLpuBuf += sLV.ushSzCurrLDC+(SIZE_WLDC_FLD);
   1282          		
   1283          		}	
   1284          
   1285          	}
   1286          	unnV1.uchAr[0] = sLV.ushSizeLDC;
   1287          	
   1288          	
   1289          return unnV1.uchAr[0];
   1290          }
   1291          void* GetAddrObj(long IdObj);
   1292          void ExtractLdc(void *pLDC)   @ "Fast_function"
   1293          {
   1294          register long i;//,j;
   1295          //register char *pSrc;//,*pDst;
   1296          
   1297          struct 
   1298          	{
   1299          		unsigned char  uchConMode;
   1300          		unsigned char uchRV_C;
   1301          		unsigned char uChIdxByte ;
   1302          		//unsigned char uChIdxBit ;
   1303          		//short shErr;
   1304          		unsigned short ushSizeLDC;
   1305          		unsigned short IdConObj;
   1306          		void *pOriginLDC;
   1307          		PFL_VL pfl_vl;
   1308          	} sLV;
   1309          //    union 
   1310          //	    {
   1311          //	    	unsigned char   uchAr [4];
   1312          //	    	unsigned short  ushAr [2];
   1313          //            unsigned long   ulVal;
   1314          //	    }unnV1;	
   1315          sLV.uchConMode  = ((LDCIDsc*)pLDC)->uchConMode;
   1316          sLV.IdConObj    = ((LDCIDsc*)pLDC)->IdConObj;
   1317          sLV.pOriginLDC  = pLDC;
   1318          /*		
   1319          pSrc = (char*)pLDC;
   1320          sLV.ushSizeLDC   = (unsigned short)pSrc[HDR_IDX_SIZE_LDC];
   1321          unnV1.uchAr [0] = pSrc[HDR_IDX_ID_COM_SES];
   1322          unnV1.uchAr [1] = pSrc[HDR_IDX_ID_COM_SES+1];
   1323          i = unnV1.ushAr [0];
   1324          sLV.uchConMode = i&1;
   1325          sLV.IdConObj    = (unsigned short )(i>>1);
   1326          */
   1327          if(sLV.uchConMode )
   1328          	{
   1329          		
   1330          		//sLV.uChIdxByte += SIZE_ID_COM_SES;
   1331          		//sLV.ushSizeLDC += SIZE_ID_COM_SES;
   1332          	
   1333          	}
   1334          	else
   1335          	{
   1336          		//sLV.uChIdxByte += SIZE_ID_COM_SES;
   1337          		//sLV.ushSizeLDC += SIZE_ID_COM_SES;
   1338          		sLV.uchRV_C =  ((LDCIDsc*)pLDC)-> uchTR_C;//size
   1339          		//pSrc = (char*) ((LDCIDsc*)pLDC)->pSrc;
   1340          		//pLDC = GetAddrObj();
   1341          		
   1342          		
   1343          		
   1344          		
   1345          	}
   1346          	sLV.pfl_vl = (PFL_VL) GetAddrPFL_VL(sLV.IdConObj);
   1347          	i = (long)sLV.pfl_vl;
   1348          	if(i)
   1349          	i = sLV.pfl_vl(pLDC,sLV.IdConObj);
   1350          	else
   1351          	{
   1352          		return;//Hundle Error Now
   1353          	}
   1354          }
   1355          
   1356          void TerminateServiceTrApCn(void* pvD,long IdObj)
   1357          {
   1358          //-long i,j;
   1359          //
   1360          TestReqTransmitT1 = 0;
   1361          
   1362          }
   1363          int ScanCnlSpi(long lIDr )   @ "Fast_function"
   1364          {
   1365          register long i,j;
   1366          register void *pv;
   1367          register void *pLpuCnl;
   1368          union 
   1369          {
   1370          	unsigned char   uchAr [4];
   1371          	unsigned short  ushAr [2];
   1372              unsigned long   ulVal;
   1373          }unnV1;
   1374          struct 
   1375          	{
   1376          
   1377          		//char chFld1,chFld2,chFld3,chFld4;
   1378          		char AuxSesFldWeight,chRetCode;
   1379          		char chTotalLDC;
   1380          		char chIDCNL;
   1381          		//unsigned short ConState;
   1382          		unsigned short IdxLpuBuf,ushSzCurrLDC;//ushRvCount;
   1383          		//unsigned short ushCapicity;
   1384          		unsigned short ushSizeLDC;
   1385          	    unsigned char *pUchRV;//
   1386          		void  *pOriginLpu;//, *pOriginTpCn;
   1387          		
   1388          	} sLV;
   1389          LDCIDsc hldLDCI;
   1390          RVStateLpuCnlDsc hldRVStateLpuCnlDsc;	
   1391          unnV1.uchAr[0] = 0x0;
   1392          	sLV.chIDCNL = lIDr;
   1393          	//Detect Id + addr
   1394          	pLpuCnl = GetLpduAddr( lIDr);
   1395          	sLV.pOriginLpu  = pLpuCnl;
   1396          	//(long lID_Cnl,void* pvHolderRVStateLpuCnl, void* pvRVStateLpuCnl)
   1397          	GetRVStateLpuCnl( lIDr,pLpuCnl,(void*)&hldRVStateLpuCnlDsc);
   1398          	pLpuCnl = (void*)&hldRVStateLpuCnlDsc;
   1399          	sLV.chTotalLDC  = 0;
   1400          	
   1401          		
   1402          	//sLV.ushSizeLDC  = ((RVStateLpuCnlDsc*)pLpuCnl)->pUch[1];//ushSizeLDC;
   1403          	//Find Idx
   1404          	i = ((RVStateLpuCnlDsc*)pLpuCnl)->pUch[0];//uchCI;
   1405          	i &= 0xf;i>>=1;
   1406          	switch (i )
   1407          	{
   1408          		case 0:
   1409          			sLV.IdxLpuBuf = 1;
   1410          		break;
   1411          		case 1:
   1412          			sLV.IdxLpuBuf = 2;
   1413          		break;
   1414          		case 2://
   1415          			sLV.IdxLpuBuf = 3;
   1416          		break;
   1417          	 default:
   1418          		sLV.IdxLpuBuf = 2;
   1419          	}
   1420          	j = sLV.IdxLpuBuf;//Skip Aux Data In Buf
   1421          	// &(((RVStateLpuCn1Dsc*)pLpuCnl)->arUch[j]);//! Be Carefull!!!/
   1422          	sLV.ushSizeLDC  = ((RVStateLpuCnlDsc*)pLpuCnl)->pUch[j];//Count LDC
   1423          	sLV.pUchRV = ((RVStateLpuCnlDsc*)pLpuCnl)->pUch;
   1424          	j++;
   1425          	sLV.IdxLpuBuf = j;
   1426          	pLpuCnl = (void*)&hldLDCI;
   1427          	while (sLV.ushSizeLDC--)
   1428          	{
   1429          		;//Get Size curr LDC
   1430          		j = sLV.IdxLpuBuf;
   1431          		pv = (void*)(sLV.pUchRV+j);
   1432          		unnV1.uchAr[0] = *((char*)pv);
   1433          		((LDCIDsc*)pLpuCnl)-> uchTR_C = unnV1.uchAr[0];
   1434          		sLV.ushSzCurrLDC = unnV1.uchAr[0];//
   1435          		
   1436          		j = (SIZE_WLDC_FLD) + sLV.IdxLpuBuf;
   1437          		pv = (void*)(sLV.pUchRV + j);
   1438          		unnV1.uchAr[2] = (unsigned char) *((char*)pv);
   1439          		unnV1.uchAr[3] = (unsigned char) *((char*)pv+1);
   1440          		i = unnV1.ushAr[1];
   1441          		((LDCIDsc*)pLpuCnl)->uchConMode = i&1;
   1442          		((LDCIDsc*)pLpuCnl)->IdConObj   = i>>1;
   1443          		if( ((LDCIDsc*)pLpuCnl)->uchConMode == 0)
   1444          		{
   1445          			((LDCIDsc*)pLpuCnl)-> uchTR_C = sLV.ushSzCurrLDC - ((SIZE_ID_COM_SES));
   1446          			j = (SIZE_WLDC_FLD) + sLV.IdxLpuBuf+(SIZE_ID_COM_SES);
   1447          			((LDCIDsc*)pLpuCnl)->pSrc = (char*)(sLV.pUchRV + j);
   1448          			((LDCIDsc*)pLpuCnl)->pDst = (char*)0;
   1449          			ExtractLdc((void*)&hldLDCI);
   1450          			sLV.IdxLpuBuf += sLV.ushSzCurrLDC+(SIZE_WLDC_FLD);
   1451          		}
   1452          		else
   1453          		{
   1454          			j = (SIZE_WLDC_FLD) + sLV.IdxLpuBuf+(SIZE_ID_COM_SES);
   1455          			pv = (void*)(sLV.pUchRV+j);
   1456          			unnV1.uchAr[0] = *((char*)pv);
   1457          			i = unnV1.uchAr[0];
   1458          			((LDCIDsc*)pLpuCnl)-> NumComSes = i;
   1459          			if ( i & (1<<START_SES_FLD_ONB))
   1460          			{
   1461          				((LDCIDsc*)pLpuCnl)-> uchStartSesion = i & (1<<START_SES_FLD_ONB);
   1462          			}
   1463          			else
   1464          			((LDCIDsc*)pLpuCnl)-> uchStartSesion = 0;
   1465          			((LDCIDsc*)pLpuCnl)-> uchTR_C = sLV.ushSzCurrLDC - ((SIZE_NUM_COM_SES)+(SIZE_ID_COM_SES));
   1466          			j = (SIZE_WLDC_FLD) + sLV.IdxLpuBuf+(SIZE_ID_COM_SES)+(SIZE_NUM_COM_SES);
   1467          			((LDCIDsc*)pLpuCnl)->pSrc = (char*)(sLV.pUchRV + j);
   1468          			((LDCIDsc*)pLpuCnl)->pDst = (char*)0;
   1469          			ExtractLdc((void*)&hldLDCI);
   1470          			sLV.IdxLpuBuf += sLV.ushSzCurrLDC+(SIZE_WLDC_FLD);
   1471          		
   1472          		}	
   1473          
   1474          	}
   1475          	unnV1.uchAr[0] = sLV.ushSizeLDC;
   1476          	
   1477          	
   1478          return unnV1.uchAr[0];
   1479          }
   1480          #include    "tpuRT.c"
   1481          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ActivateServTrApCnSamplesCTpuUnit
       0   ActivateServTrApCnSamplesCTpuUnitHSU2
      16   ActivateServiceTrApCn
        16   -> ActivateServTrApCnSamplesCTpuUnit
      20   AsemblyLDC
       0   CutCnlCapicity
      32   ExtractLdc
        32   -- Indirect call
        32   -> GetAddrPFL_VL
       0   GetAddrObj
       0   GetAddrPFL_VL
       0   GetFld_TpState_CNL
       0   GetLpduAddr
       0   GetRVStateLpuCnl
       0   GetStateCnlTpCn
      56   ScanCn1
        56   -> ExtractLdc
      80   ScanCnl
        80   -> ExtractLdc
        80   -> GetLpduAddr
        80   -> GetRVStateLpuCnl
      80   ScanCnlSpi
        80   -> ExtractLdc
        80   -> GetLpduAddr
        80   -> GetRVStateLpuCnl
       0   ServiceTRApCn
      88   ServiceTRApCn2
        88   -> AsemblyLDC
        88   -> GetFld_TpState_CNL
        88   -> GetStateCnlTpCn
        88   -> SetFld_TpState_CNL
        88   -> SetStateCnlTpCn
       0   SetCnlStatetoRun
       0   SetFld_TpState_CNL
       0   SetStateCnlTpCn
       0   TerminateServiceTrApCn
      12   UpdateRVSrcSamplesCTpuUnit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
     124  ActivateServTrApCnSamplesCTpuUnit
     124  ActivateServTrApCnSamplesCTpuUnitHSU2
      32  ActivateServiceTrApCn
     328  AsemblyLDC
      12  CutCnlCapicity
     112  ExtractLdc
     100  GetAddrObj
     220  GetAddrPFL_VL
     120  GetFld_TpState_CNL
     108  GetLpduAddr
     272  GetRVStateLpuCnl
     256  GetStateCnlTpCn
     428  ScanCn1
     636  ScanCnl
     604  ScanCnlSpi
       4  ServiceTRApCn
    1484  ServiceTRApCn2
      12  SetCnlStatetoRun
      84  SetFld_TpState_CNL
     216  SetStateCnlTpCn
      16  TerminateServiceTrApCn
     192  UpdateRVSrcSamplesCTpuUnit
      24  hldrRVPrtTblPrMngCTpuUnit
     256  hldrRVPrtTblTransportCTpuUnit
      96  hldrRVTpCnState
      28  hldrTRPrtTblPrMngCTpuUnit
     260  hldrTRPrtTblTransportCTpuUnit
      96  hldrTpCnState
      72  holderRV10PeriodCTpuUnit
      28  holderRVAbsNumeratorUnnSOCTpuUnit
     232  holderRVApcsSOCTpuUnit
      52  holderRVAtrCmdSOCTpuUnit
      36  holderRVDateTimeSOCTpuUnit
      32  holderRVDiagnBrBmSOCTpuUnit
      32  holderRVDiagnBrBsSOCTpuUnit
      36  holderRVFCoilSOCTpuUnit
     232  holderRVGoosASOCTpuUnit
     232  holderRVGoosBSOCTpuUnit
      64  holderRVSrcSamplesCTpuUnit
      64  holderRVTotMeasCTpuUnit
     132  holderRVTotMeasRSOCTpuUnit
      76  holderTR10PeriodCTpuUnit
     236  holderTRApcsSOCTpuUnit
      28  holderTRAuxStngSOCTpuUnit
      36  holderTRDiagnBrBmSOCTpuUnit
      36  holderTRDiagnBrBsSOCTpuUnit
     236  holderTRGoosASOCTpuUnit
     236  holderTRGoosBSOCTpuUnit
      68  holderTRSrcSamplesCTpuUnit
      40  holderTRTeleMechsSOCTpuUnit
      68  holderTRTotMeasCTpuUnit
     136  holderTRTotMeasRSOCTpuUnit
     120  holderTRTotVerInfoBrBsSOCTpuUnit
     148  holderTRUN_ArecSOCTpuUnit

 
 1 732 bytes in section .bss
 1 736 bytes in section .data
   640 bytes in section .text
 4 936 bytes in section Fast_function
 
 5 576 bytes of CODE memory
 3 468 bytes of DATA memory

Errors: none
Warnings: 2
