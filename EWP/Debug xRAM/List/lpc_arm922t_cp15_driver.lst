###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Oct/2015  12:11:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        projects\HR1_0100_00_I720_new2\LIB\source\lpc_arm922t_cp15_driver.c
#    Command line =  
#        "D:\IAR
#        projects\HR1_0100_00_I720_new2\LIB\source\lpc_arm922t_cp15_driver.c"
#        -lcN "D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\List\" -o
#        "D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xRAM\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --interwork --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\List\lpc_arm922t_cp15_driver.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xRAM\Obj\lpc_arm922t_cp15_driver.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\LIB\source\lpc_arm922t_cp15_driver.c
      1          /***********************************************************************
      2           * $Id: lpc_arm922t_cp15_driver.c 35145 2010-03-19 18:10:17Z anderslu $
      3           *
      4           * Project: ARM922T Coprocessor 15 driver
      5           *
      6           * Description:
      7           *     This file contains driver support for the MMU and cache
      8           *     coprocessor (15) of the ARM922T.
      9           *
     10           ***********************************************************************
     11           * Software that is described herein is for illustrative purposes only
     12           * which provides customers with programming information regarding the
     13           * products. This software is supplied "AS IS" without any warranties.
     14           * NXP Semiconductors assumes no responsibility or liability for the
     15           * use of the software, conveys no license or title under any patent,
     16           * copyright, or mask work right to the product. NXP Semiconductors
     17           * reserves the right to make changes in the software without
     18           * notification. NXP Semiconductors also make no representation or
     19           * warranty that such application will be suitable for the specified
     20           * use without further testing or modification.
     21           **********************************************************************/
     22          
     23          #include "lpc_arm922t_cp15_driver.h"
     24          
     25          #ifdef __ICCARM__
     26          #include "intrinsics.h"
     27          #endif
     28          
     29          /***********************************************************************
     30           * CP15 driver private data
     31           **********************************************************************/
     32          
     33          /* The address translation functions of this driver require a saved
     34             pointer to the virtual base address of the MMU table. */
     35          UNS_32 *virtual_tlb_addr;
     36          
     37          /***********************************************************************
     38           * CP15 driver private functions and macros
     39           **********************************************************************/
     40          
     41          #ifdef __ghs__
     42          /* Simple GHS function returning the TTB register */
     43          asm UNS_32 getttb(void)
     44          {
     45            % reg ttb
     46            MRC     p15, 0, r0, c2, c0, 0
     47          }
     48          
     49          /* Simple GHS function returning the MMU control register */
     50          asm UNS_32 getstatus(void)
     51          {
     52            % reg status
     53            MRC     p15, 0, r0, c1, c0, 0
     54          }
     55          
     56          /* Simple GHS function used to support cache invalidation */
     57          asm void invalcache(UNS_32 *adr)
     58          {
     59            % reg adr
     60            MCR     p15, 0, adr, c7, c14, 1
     61            MCR     p15, 0, adr, c7, c5, 1
     62            % con adr
     63            MOV     r0, adr
     64            MCR     p15, 0, r0, c7, c14, 1
     65            MCR     p15, 0, r0, c7, c5, 1
     66          }
     67          
     68          /* Simple GHS function used to support cache invalidation */
     69          asm void inval_all_cache(void)
     70          {
     71            MOV     r0, 0
     72            MCR     p15, 0, r0, c7, c7, 0
     73          }
     74          
     75          /* Simple GHS function used to support translation table base
     76             register invalidation */
     77          asm void invaltlb(UNS_32 *adr)
     78          {
     79            % reg adr
     80            MCR     p15, 0, adr, c8, c5, 1
     81            NOP
     82            NOP
     83            % con adr
     84            MOV     r0, adr
     85            MCR     p15, 0, r0, c8, c5, 1
     86            NOP
     87            NOP
     88          }
     89          
     90          /* Simple GHS function used to invalidate all TLB entries */
     91          asm void inval_all_tlb(void)
     92          {
     93            MOV     r0, 0
     94            MCR     p15, 0, r0, c8, c7, 0
     95          }
     96          
     97          /* Simple GHS function used to enable/disable MMU */
     98          asm void set_mmu(UNS_32 val)
     99          {
    100            % reg val
    101            MCR     p15, 0, val, c1, c0, 0
    102          }
    103          
    104          /* Simple GHS function used to set TTB address */
    105          asm void set_ttb(UNS_32 addr)
    106          {
    107            % reg addr
    108            MCR     p15, 0, addr, c2, c0, 0
    109          }
    110          
    111          /* Simple GHS function used to set domain access control */
    112          asm void set_dac(UNS_32 reg_val)
    113          {
    114            % reg reg_val
    115            MCR     p15, 0, reg_val, c3, c0, 0
    116          }
    117          #endif
    118          
    119          /***********************************************************************
    120           * CP15 driver public functions
    121           **********************************************************************/
    122          
    123          /***********************************************************************
    124           *
    125           * Function: cp15_decode_level2
    126           *
    127           * Purpose:
    128           *     Given a level2 descriptor and a physical address, return
    129           *     the virtual address if the level2 descriptor can map the
    130           *     physical address.
    131           *
    132           * Processing:
    133           *     Translate and return the level 2 virtual address for
    134           *     the given physical address.
    135           *
    136           * Parameters:
    137           *     level2: MMU level 2 table value
    138           *     addr:   Physical address to be converted
    139           *
    140           * Outputs: None
    141           *
    142           * Returns:
    143           *      The virtual address or 0 if the address does not translate.
    144           *
    145           * Notes: None
    146           *
    147           **********************************************************************/
    148          static UNS_32 cp15_decode_level2(UNS_32 level2,
    149                                           UNS_32 addr)
    150          {
    151            UNS_32 dcd = 0;
    152          
    153            switch (level2 & ARM922T_L2D_TYPE_PAGE_MASK)
    154            {
    155              case ARM922T_L2D_TYPE_LARGE_PAGE:
    156                /* Large page table */
    157                if ((level2 & ARM922T_L2D_LPAGE_MASK) ==
    158                    (addr & ARM922T_L2D_LPAGE_MASK))
    159                {
    160                  dcd = (level2 & ARM922T_L2D_LPAGE_MASK) |
    161                        (addr & (~ARM922T_L2D_LPAGE_MASK));
    162                }
    163                break;
    164          
    165              case ARM922T_L2D_TYPE_SMALL_PAGE:
    166                /* Small page table */
    167                if ((level2 & ARM922T_L2D_SPAGE_MASK) ==
    168                    (addr & ARM922T_L2D_SPAGE_MASK))
    169                {
    170                  dcd = (level2 & ARM922T_L2D_SPAGE_MASK) |
    171                        (addr & (~ARM922T_L2D_SPAGE_MASK));
    172                }
    173                break;
    174          
    175              case ARM922T_L2D_TYPE_TINY_PAGE:
    176                /* Tiny page table */
    177                if ((level2 & ARM922T_L2D_TPAGE_MASK) ==
    178                    (addr & ARM922T_L2D_TPAGE_MASK))
    179                {
    180                  dcd = (level2 & ARM922T_L2D_TPAGE_MASK) |
    181                        (addr & (~ARM922T_L2D_TPAGE_MASK));
    182                }
    183          
    184              default:
    185                break;
    186            }
    187          
    188            return dcd;
    189          }
    190          
    191          /***********************************************************************
    192           * CP15 driver public functions
    193           **********************************************************************/
    194          
    195          /***********************************************************************
    196           *
    197           * Function: cp15_map_virtual_to_physical
    198           *
    199           * Purpose: Return a physical address for a passed virtual address
    200           *
    201           * Processing:
    202           *      Return (UNS_32)addr if MMU is turned off. Otherwise, read the
    203           *      address of the translation table from the translation table base
    204           *      address register. Use the upper 12 bits of the addr to index the
    205           *      translation table and read out the descriptor. If the descriptor
    206           *      is invalid, return 0. If the descriptor is for a 1 Meg section,
    207           *      read back the upper 12 bits of the physical address. The lower
    208           *      20 bits of the physical address is the lower 20 bits of the
    209           *      virtual address. If the descriptor is for a coarse page table,
    210           *      read the coarse page table descriptor and use the most
    211           *      significant 22 bits as the base address of the page table. If
    212           *      the descriptor is for a fine page table, read the fine page
    213           *      table descriptor and use the most significant 20 bits as the
    214           *      base address of the page table.
    215           *
    216           *      If not a section base, read the level 2 page descriptor from the
    217           *      page table.  If bits 1..0 of the level2 descriptor are 01, then
    218           *      it is a large page table descriptor. The most significant 16
    219           *      bits of the descriptor are the most significant 16 bits of the
    220           *      physical address; the least significant 16-bits of the virtual
    221           *      address are the least significant 16-bits of the address. If
    222           *      bits 1..0 of the level2 descriptor are 10, then it is a small
    223           *      page table descriptor. The most significant 20 bits of the
    224           *      level2 descriptor are the most significant 20 bits of the
    225           *      physical address; the least significant 12 bits are the least
    226           *      significant 12 bits of the physical address. If bits 1..0 of
    227           *      the level2 descriptor are 11, then it is a tiny page table
    228           *      descriptor.  The most significant 22 bits of the level2
    229           *      descriptor are the most significant 22 bits of the physical
    230           *      address; the least significant 10 bits are the least
    231           *      significant 10 bits of the physical address.  If bits 1..0
    232           *      of the level2 descriptor are 0, return 0 (invalid).
    233           *
    234           * Parameters:
    235           *     addr: The virtual address to be converted
    236           *
    237           * Outputs: None
    238           *
    239           * Returns:
    240           *      The physical address or 0 if the address does not translate.
    241           *
    242           * Notes: None
    243           *
    244           **********************************************************************/
    245          UNS_32 cp15_map_virtual_to_physical(void *addr)
    246          {
    247            register UNS_32 status;
    248            UNS_32 *tlb, tlb_entry, index, virtual_addr;
    249            UNS_32 *page_table, level2;
    250          
    251            virtual_addr = (UNS_32) addr;
    252          
    253            /* Read the MMU control register */
    254          #ifdef __GNUC__
    255          __asm__ volatile("MRC p15, 0, %0, c1, c0, 0" : "=r"(status));
    256          #endif
    257          #ifdef __ghs__
    258            status = getstatus();
    259          #endif
    260          #ifdef __arm
    261            __asm
    262            {
    263              MRC p15, 0, status, c1, c0, 0;
    264            }
    265          #endif
    266          #ifdef __ICCARM__
    267            /* IAR CC includes some "intrinsic" functions to access ARM CP regs */
    268            status = __MRC(15, 0, 1, 0, 0);
    269          #endif
    270          
    271            /* Is MMU enabled? */
    272            if ((status & ARM922T_MMU_CONTROL_M) == 0)
    273            {
    274              /* MMU is off; virtual address is physical address */
    275              return virtual_addr;
    276            }
    277          
    278            /* Get TLB base address */
    279            tlb = virtual_tlb_addr;
    280          
    281            /*******************************************************************
    282             * Get the level 1 translation table entry
    283             * indexed by bits 31:20 of the address
    284             ******************************************************************/
    285            index = virtual_addr;
    286            index >>= 20;
    287            tlb_entry = tlb[index];
    288            /* Perform function based on level 1 page type or section */
    289            switch (tlb_entry & ARM922T_L1D_TYPE_PG_SN_MASK)
    290            {
    291              case ARM922T_L1D_TYPE_FAULT:
    292                /* Invalid section or page, fault */
    293                return 0;
    294          
    295              case ARM922T_L1D_TYPE_CPAGE:
    296                /* Coarse page tables */
    297                index = (virtual_addr >> 12) & ARM922T_CPT_INDEX_MASK;
    298                page_table = (UNS_32 *)(tlb_entry &
    299                                        ARM922T_L2D_CP_BASE_MASK);
    300                level2 = page_table[index];
    301                break;
    302          
    303              case ARM922T_L1D_TYPE_SECTION:
    304                /* Section type */
    305                /***********************************************************
    306                 * Section base -- upper 12 bits of entry is physical
    307                 * memory base lower 20 bits of virtual address is offset
    308                 * rom that base
    309                 **********************************************************/
    310                return ((tlb_entry & ARM922T_L2D_SN_BASE_MASK) |
    311                        (virtual_addr & ~(ARM922T_L2D_SN_BASE_MASK)));
    312          
    313              case ARM922T_L1D_TYPE_FPAGE:
    314                /* Fine page tables */
    315                index = (virtual_addr >> 10) & ARM922T_FPT_INDEX_MASK;
    316                page_table = (UNS_32 *)(tlb_entry &
    317                                        ARM922T_L2D_FP_BASE_MASK);
    318                level2 = page_table[index];
    319                break;
    320          
    321              default:
    322                /* This should never happen */
    323                return 0;
    324            }
    325          
    326            switch (level2 & ARM922T_L2D_TYPE_PAGE_MASK)
    327            {
    328              case ARM922T_L2D_TYPE_LARGE_PAGE:
    329                /* Large page table */
    330                return ((level2 & ARM922T_L2D_LPAGE_MASK) |
    331                        (virtual_addr & ~(ARM922T_L2D_LPAGE_MASK)));
    332          
    333              case ARM922T_L2D_TYPE_SMALL_PAGE:
    334                /* Small page table */
    335                return ((level2 & ARM922T_L2D_SPAGE_MASK) |
    336                        (virtual_addr & ~(ARM922T_L2D_SPAGE_MASK)));
    337          
    338              case ARM922T_L2D_TYPE_TINY_PAGE:
    339                /* Tiny page table */
    340                return ((level2 & ARM922T_L2D_TPAGE_MASK) |
    341                        (virtual_addr & ~(ARM922T_L2D_TPAGE_MASK)));
    342          
    343              default:
    344                break;
    345            }
    346          
    347            return 0;
    348          }
    349          
    350          /***********************************************************************
    351           *
    352           * Function: cp15_map_physical_to_virtual
    353           *
    354           * Purpose: Return a virtual address for a passed physical address
    355           *
    356           * Processing:
    357           *     Test if MMU is on, return if not.  Search for the virtual
    358           *     address of the provided physical address. If found, return a
    359           *     void pointer to virtual address.
    360           *
    361           * Parameters:
    362           *     addr: The physical address to be converted
    363           *
    364           * Outputs: None
    365           *
    366           * Returns:
    367           *      The virtual address or 0 if the address does not translate.
    368           *
    369           * Notes: None
    370           *
    371           **********************************************************************/
    372          void * cp15_map_physical_to_virtual(UNS_32 addr)
    373          {
    374            register UNS_32 status;
    375            UNS_32 *tlb, tlb_entry, index;
    376            UNS_32 *page_table, level2, index2;
    377            void *virtual_addr;
    378          
    379            /*******************************************************************
    380             * Do a linear search of the translation table until the level 1
    381             * descriptor corresponding to the physical address is found
    382             ******************************************************************/
    383          
    384            /* Read the control register */
    385          #ifdef __GNUC__
    386          __asm__ volatile("MRC p15, 0, %0, c1, c0, 0" : "=r"(status));
    387          #endif
    388          #ifdef __ghs__
    389            status = getstatus();
    390          #endif
    391          #ifdef __arm
    392            __asm
    393            {
    394              MRC p15, 0, status, c1, c0, 0;
    395            }
    396          #endif
    397          #ifdef __ICCARM__
    398            /* IAR CC includes some "intrinsic" functions to access ARM CP regs */
    399            status = __MRC(15, 0, 1, 0, 0);
    400          #endif
    401          
    402            /* Is MMU enabled? */
    403            if ((status & ARM922T_MMU_CONTROL_M) == 0)
    404            {
    405              /* MMU is off; physical address is virtual address */
    406              return (void *)addr;
    407            }
    408          
    409            /* Get TLB base address */
    410            tlb = virtual_tlb_addr;
    411          
    412            /*******************************************************************
    413             * Search until found or all 4096 translation
    414             * table entries are examined.
    415             ******************************************************************/
    416            for (index = 0; index < ARM922T_TT_ENTRIES; index ++)
    417            {
    418              tlb_entry = tlb[index];
    419              switch (tlb_entry & ARM922T_L1D_TYPE_PG_SN_MASK)
    420              {
    421                case ARM922T_L1D_TYPE_FAULT:
    422                  /* Invalid section or page, fault */
    423                  break;
    424          
    425                case ARM922T_L1D_TYPE_CPAGE:
    426                  /* Course page tables, loop through all entries */
    427                  page_table = (UNS_32 *)(tlb_entry &
    428                                          ARM922T_L2D_CP_BASE_MASK);
    429                  for (index2 = 0; index2 < ARM922T_CPT_ENTRIES; index2++)
    430                  {
    431                    level2 = page_table[index2];
    432                    if (level2)
    433                    {
    434                      virtual_addr = (void *)
    435                                     cp15_decode_level2(level2, addr);
    436          
    437                      if (virtual_addr)
    438                      {
    439                        return virtual_addr;
    440                      }
    441                    }
    442                    break;
    443                  }
    444                  break;
    445          
    446                case ARM922T_L1D_TYPE_SECTION:
    447                  /* Section type */
    448                  /*******************************************************
    449                   * Section base -- upper 12 bits of entry is physical
    450                   * memory base lower 20 bits of virtual address is
    451                   * offset from that base
    452                   ******************************************************/
    453                  if ((tlb_entry & ARM922T_L2D_SN_BASE_MASK)
    454                      == (addr & ARM922T_L2D_SN_BASE_MASK))
    455                  {
    456                    return (void *)((index << 20) |
    457                                    (addr & ~(ARM922T_L2D_SN_BASE_MASK)));
    458                  }
    459                  break;
    460          
    461                case ARM922T_L1D_TYPE_FPAGE:
    462                  /* Fine page tables, loop through entries */
    463                  page_table = (UNS_32 *)(tlb_entry &
    464                                          ARM922T_L2D_FP_BASE_MASK);
    465                  for (index2 = 0; index2 < ARM922T_FPT_ENTRIES; index2++)
    466                  {
    467                    level2 = page_table[index2];
    468                    if (level2)
    469                    {
    470                      virtual_addr = (void *)
    471                                     cp15_decode_level2(level2, addr);
    472          
    473                      if (virtual_addr)
    474                      {
    475                        return virtual_addr;
    476                      }
    477                    }
    478                  }
    479                  break;
    480          
    481                default:
    482                  break;
    483              }
    484            }
    485          
    486            return 0;
    487          }
    488          
    489          /***********************************************************************
    490           *
    491           * Function: cp15_force_cache_coherence
    492           *
    493           * Purpose:
    494           *     Force the CPU to recognize the block of code that was just
    495           *     written to memory between start_adr and end_adr even if caching
    496           *     and write buffering is on.
    497           *
    498           * Processing:
    499           *     Cache lines are 32-bytes (8 words); clean and invalidate each
    500           *     line of D-cache and invalidate each line of I-cache within the
    501           *     address range.
    502           *
    503           *     Invalidate the I-TLB within the the address range. The I-TLB has
    504           *     256 word granularity.
    505           *
    506           * Parameters:
    507           *     start_adr:  The first address in the code block
    508           *     end_adr:    The last address in the code block
    509           *
    510           * Outputs: None
    511           *
    512           * Returns: Nothing
    513           *
    514           * Notes: None
    515           *
    516           **********************************************************************/
    517          void cp15_force_cache_coherence(UNS_32 *start_adr,
    518                                          UNS_32 *end_adr)
    519          {
    520            register UNS_32 * addr;
    521          
    522            /*******************************************************************
    523             * Cache lines are 32-bytes (8 words); clean and invalidate each
    524             * line of D-cache and invalidate each line of I-cache within the
    525             * address range. Make sure addresses are 32-bit aligned.
    526             ******************************************************************/
    527            for (addr = (UNS_32 *)((UNS_32)start_adr & 0xFFFFFFE0);
    528                 addr < end_adr;
    529                 addr += 8)
    530            {
    531              /* p15 is MMU coprocessor, Cache OPS is c7, TLB OPS is c8 */
    532          #ifdef __GNUC__
    533          __asm__ volatile("MOV r0, %0" : : "r"(addr));
    534              /* Clean and Invalidate D-Cache single entry using MVA format */
    535              asm("MCR p15, 0, r0, c7, c14, 1");
    536              /* Invalidate I-Cache single entry using MVA format */
    537              asm("MCR p15, 0, r0, c7, c5, 1");
    538          #endif
    539          #ifdef __ghs__
    540              invalcache(addr);
    541          #endif
    542          #ifdef __arm
    543              UNS_32 trx;
    544              __asm
    545              {
    546                MOV     trx, addr
    547                /* Clean and Invalidate D-Cache single entry using MVA
    548                   format */
    549                MCR     p15, 0, trx, c7, c14, 1
    550                /* Invalidate I-Cache single entry using MVA format */
    551                MCR     p15, 0, trx, c7, c5, 1
    552              }
    553          #endif
    554          #ifdef __ICCARM__
    555          
    556              /* Use IAR intrinsic functions */
    557              __MCR(15, 0, (UNS_32)addr, 7, 14, 1);
    558              __MCR(15, 0, (UNS_32)addr, 7, 5, 1);
    559          #endif
    560          
    561            }
    562            /*******************************************************************
    563             * Invalidate the I-TLB within the the address range. The I-TLB has
    564             * 256 word granularity. Make sure addresses are '256 word' aligned.
    565             ******************************************************************/
    566            for (addr = (UNS_32 *)((UNS_32)start_adr & 0xFFFFFC00);
    567                 addr < end_adr;
    568                 addr += 256)
    569            {
    570          #ifdef __GNUC__
    571          __asm__ volatile("MOV r0, %0" : : "r"(addr));
    572              /* Invalidate I-TLB using MVA format */
    573              asm("MCR p15, 0, r0, c8, c5, 1");
    574              asm("NOP");
    575              asm("NOP");
    576          #endif
    577          #ifdef __ghs__
    578              invaltlb(addr);
    579          #endif
    580          #ifdef __arm
    581              UNS_32 trx;
    582              __asm
    583              {
    584                MOV     trx, addr
    585                /* Invalidate I-TLB using MVA format */
    586                MCR      p15, 0, trx, c8, c5, 1
    587                NOP
    588                NOP
    589              }
    590          #endif
    591          #ifdef __ICCARM__
    592          
    593              /* Invalidate I-TLB using MVA format */
    594              /* Use IAR intrinsic functions */
    595              __MCR(15, 0, (UNS_32)addr, 8, 5, 1);
    596              __no_operation();
    597              __no_operation();
    598          #endif
    599            }
    600          }
    601          
    602          /***********************************************************************
    603           *
    604           * Function: cp15_init_mmu_trans_table
    605           *
    606           * Purpose: Initializes the MMU page table
    607           *
    608           * Processing:
    609           *     Return error if MMU is enabled. Return error if target
    610           *     Translation Table address is not 16K aligned. Clear the
    611           *     Translation Table area. Build the Translation Table from the
    612           *     initialization data in the Section Block array. Return no error.
    613           *
    614           * Parameters:
    615           *      tt:    address of Translation Table in RAM.
    616           *      ttsbp: address of the beginning of the initialization array
    617           *
    618           * Outputs: None.
    619           *
    620           * Returns:
    621           *     This function returns _ERROR when the MMU is enabled, or the
    622           *     target address is not 16K aligned. Otherwise, it returns
    623           *     _NO_ERROR.
    624           *
    625           * Notes:
    626           *     This function is not intended to be used when the MMU is
    627           *     enabled.
    628           *
    629           **********************************************************************/
    630          BOOL_32 cp15_init_mmu_trans_table(TRANSTABLE_T *tt,
    631                                            TT_SECTION_BLOCK_T *ttsbp)
    632          {
    633            register UNS_32 control;
    634            UNS_32 idx;
    635            UNS_32 va_idx;
    636            UNS_32 pa_addr;
    637            UNS_32 *uiptr;
    638            UNS_32 ret = _NO_ERROR;
    639          
    640            /*******************************************************************
    641             * The following check returns an error if the MMU is enabled.
    642             * This condition is not necessarily an error, but an existing
    643             * Translation Table for an enabled MMU should not be overwritten
    644             * while the MMU is enabled.
    645             ******************************************************************/
    646          
    647            /* Read the control register */
    648          #ifdef __GNUC__
    649          __asm__ volatile("MRC p15, 0, %0, c1, c0, 0" : "=r"(control));
    650          #endif
    651          #ifdef __ghs__
    652            control = getstatus();
    653          #endif
    654          #ifdef __arm
    655            __asm
    656            {
    657              MRC p15, 0, control, c1, c0, 0;
    658            }
    659          #endif
    660          #ifdef __ICCARM__
    661            /* Use IAR intrinsic functions */
    662            control = __MRC(15, 0, 1, 0, 0);
    663          #endif
    664          
    665            /* Exit if MMU is already enabeld */
    666            if ((control & ARM922T_MMU_CONTROL_M) != 0)
    667            {
    668              return (_ERROR);
    669            }
    670          
    671            /* Make sure table address is on a 16K boundary */
    672            if (((INT_32) tt & ~(ARM922T_TT_ADDR_MASK)) != 0)
    673            {
    674              return (_ERROR);
    675            }
    676          
    677            /*******************************************************************
    678             * Clear the entire Translation Table.
    679             * This results in L1D_TYPE_FAULT being the default for any
    680             * uninitialized entries.
    681             ******************************************************************/
    682            uiptr = (UNS_32 *) tt;
    683            for (idx = 0; idx < ARM922T_TT_ENTRIES; idx++)
    684              *uiptr++ = ARM922T_L1D_TYPE_FAULT;
    685          
    686            /* Build the translation table from user provided
    687               TT_SECTION_BLOCK_TYPE array */
    688            while (ttsbp->num_sections != 0)
    689            {
    690              switch ((ttsbp->entry) & ARM922T_L1D_TYPE_PG_SN_MASK)
    691              {
    692                case ARM922T_L1D_TYPE_SECTION:
    693                  va_idx = ttsbp->virt_addr >> 20;
    694                  pa_addr = ttsbp->phys_addr & ARM922T_L2D_SN_BASE_MASK;
    695                  for (idx = 0; idx < ttsbp->num_sections; idx++)
    696                  {
    697                    tt->vidx[va_idx] = (pa_addr | ttsbp->entry | 0x10);
    698                    va_idx++;
    699                    pa_addr += 0x100000;
    700                  }
    701                  break;
    702          
    703                case(ARM922T_L1D_TYPE_CPAGE):
    704                  va_idx = ttsbp->virt_addr >> 20;
    705                  pa_addr = ttsbp->phys_addr & ARM922T_L2D_CP_BASE_MASK;
    706                  for (idx = 0; idx < ttsbp->num_sections; idx++)
    707                  {
    708                    tt->vidx[va_idx] = pa_addr | ttsbp->entry;
    709                    va_idx++;
    710                    pa_addr += 0x100000;
    711                  }
    712                  break;
    713          
    714                case ARM922T_L1D_TYPE_FAULT:
    715                default:
    716                  break;
    717              }
    718          
    719              ttsbp++;
    720            }
    721          
    722            return ret;
    723          }
    724          
    725          /***********************************************************************
    726           *
    727           * Function: cp15_set_vmmu_addr
    728           *
    729           * Purpose: Set the virtual address of the MMU table
    730           *
    731           * Processing:
    732           *     Set the saved virtual MMU table address to the passed value.
    733           *
    734           * Parameters:
    735           *      addr: Virtual address of start of MMU table
    736           *
    737           * Outputs: None.
    738           *
    739           * Returns: Nothing
    740           *
    741           * Notes:
    742           *     This function must be called if the driver MMU functions are
    743           *     being used. This should be set after the call to the
    744           *     cp15_init_mmu_trans_table() function.
    745           *
    746           **********************************************************************/
    747          void cp15_set_vmmu_addr(UNS_32 *addr)
    748          {
    749            virtual_tlb_addr = addr;
    750          }
    751          
    752          /***********************************************************************
    753           *
    754           * Function: cp15_get_ttb
    755           *
    756           * Purpose: Return the physical address of the MMU translation table
    757           *
    758           * Processing:
    759           *     Read the TTB register from coprocessor 15 and return it to the
    760           *     caller.
    761           *
    762           * Parameters: None
    763           *
    764           * Outputs: None.
    765           *
    766           * Returns: The base address of the MMU translation table
    767           *
    768           * Notes: None
    769           *
    770           **********************************************************************/
    771          UNS_32 *cp15_get_ttb(void)
    772          {
    773            register UNS_32 ttb;
    774          
    775          #ifdef __GNUC__
    776          __asm__ volatile("MRC p15, 0, %0, c2, c0, 0" : "=r"(ttb));
    777          #endif
    778          #ifdef __ghs__
    779            ttb = getttb();
    780          #endif
    781          #ifdef __arm
    782            __asm
    783            {
    784              MRC p15, 0, ttb, c2, c0, 0;
    785            }
    786          #endif
    787          #ifdef __ICCARM__
    788            /* use IAR CC intrinsic function to read CP15 reg */
    789            ttb = __MRC(15, 0, 2, 0, 0);
    790          #endif
    791          
    792            return (UNS_32 *) ttb;
    793          }
    794          
    795          /***********************************************************************
    796           *
    797           * Function: cp15_dcache_flush
    798           *
    799           * Purpose: Force an data cache flush
    800           *
    801           * Processing:
    802           *     Flush each data cache entry using the segment/index method.
    803           *
    804           * Parameters: None
    805           *
    806           * Outputs: None
    807           *
    808           * Returns: Nothing
    809           *
    810           * Notes: None
    811           *
    812           **********************************************************************/
    813          void cp15_dcache_flush(void)
    814          {
    815          #ifdef __GNUC__
    816          
    817          #endif
    818          #ifdef __ghs__
    819          
    820          #endif
    821          #ifdef __arm
    822            INT_32 segment, index, comp, cache_sz, total_seg;
    823          
    824            __asm
    825            {
    826              MRC p15, 0, cache_sz, c0, c0, 1
    827            }
    828          
    829            /* For 8KB cache the size field is 4 and for 16 it is 5.
    830            */
    831            total_seg = (1 << (ARM922T_MMU_DC_SIZE(cache_sz) - 2));
    832          
    833            for (segment = 0; segment < total_seg; segment++)
    834            {
    835              for (index = 0; index < 64; index++)
    836              {
    837                /* For each segment and index, flush the data cache */
    838                comp = (segment << 5) | (index << 26);
    839                __asm
    840                {
    841                  MCR p15, 0, comp, c8, c5, 1
    842                }
    843              }
    844            }
    845          #endif
    846          #ifdef __ICCARM__
    847          
    848          #endif
    849          }
    850          
    851          /***********************************************************************
    852           *
    853           * Function: cp15_write_buffer_flush
    854           *
    855           * Purpose: Force an write buffer flush
    856           *
    857           * Processing:
    858           *     Flush the write buffer and wait for completion of the flush.
    859           *
    860           * Parameters: None
    861           *
    862           * Outputs: None
    863           *
    864           * Returns: Nothing
    865           *
    866           * Notes: None
    867           *
    868           **********************************************************************/
    869          void cp15_write_buffer_flush(void)
    870          {
    871          #ifdef __GNUC__
    872          
    873          #endif
    874          #ifdef __ghs__
    875          
    876          #endif
    877          #ifdef __arm
    878            UNS_32 trx;
    879            __asm
    880            {
    881              MOV trx, #0
    882              MCR p15, 0, trx, c7, c10, 4
    883            }
    884          #endif
    885          #ifdef __ICCARM__
    886          
    887          #endif
    888          }
    889          
    890          /***********************************************************************
    891           *
    892           * Function: cp15_mmu_enabled
    893           *
    894           * Purpose:
    895           *  Checks to see if the MMU is enabled
    896           *
    897           * Processing:
    898           *  Read the MMU control register and check if the MMU enable bit
    899           *  (bit 0) is set.
    900           *
    901           * Parameters: None
    902           *
    903           * Outputs: None
    904           *
    905           * Returns:
    906           *  TRUE if the MMU is enabled
    907           *  FALSE if the MMU is disabled
    908           *
    909           * Notes: None
    910           *
    911           **********************************************************************/
    912          BOOL_32 cp15_mmu_enabled(void)
    913          {
    914            UNS_32 mmu_reg;
    915          
    916          #ifdef __GNUC__
    917          __asm__ volatile("MRC p15, 0, %0, c1, c0, 0" : "=r"(mmu_reg));
    918          #endif
    919          
    920          #ifdef __ghs__
    921            mmu_reg = getstatus();
    922          #endif
    923          
    924          #ifdef __arm
    925            __asm
    926            {
    927              MRC     p15, 0, mmu_reg, ARM922T_MMU_REG_CONTROL, c0, 0;
    928            }
    929          #endif
    930          
    931          #ifdef __ICCARM__
    932            /* use IAR CC intrinsic function to read CP15 reg */
    933            mmu_reg = __MRC(15, 0, 1, 0, 0);
    934          #endif
    935          
    936          
    937            return ((mmu_reg & _BIT(0)) == _BIT(0));
    938          }
    939          
    940          /***********************************************************************
    941           *
    942           * Function: cp15_get_mmu_control_reg
    943           *
    944           * Purpose:
    945           *  To return the current value of  the MMU Coprocessor (CP15) Control
    946           *  register.
    947           *
    948           * Processing:
    949           *  Fetch the MMU control register to a variable and return it
    950           *
    951           * Parameters: None
    952           *
    953           * Outputs: None
    954           *
    955           * Returns:
    956           *  The current value of the MMU Control register (cp15) as an UNS_32
    957           *
    958           * Notes: None
    959           *
    960           **********************************************************************/
    961          UNS_32 cp15_get_mmu_control_reg(void)
    962          {
    963            register UNS_32 mmu_reg;
    964          
    965          #ifdef __GNUC__
    966          __asm__ volatile("MRC p15, 0, %0, c1, c0, 0" : "=r"(mmu_reg));
    967          #endif
    968          
    969          #ifdef __ghs__
    970            mmu_reg = getstatus();
    971          
    972          #endif
    973          #ifdef __arm
    974            __asm
    975            {
    976              MRC     p15, 0, mmu_reg, ARM922T_MMU_REG_CONTROL, c0, 0;
    977            }
    978          #endif
    979          #ifdef __ICCARM__
    980            /* use IAR CC intrinsic function to read CP15 reg */
    981            mmu_reg = __MRC(15, 0, 1, 0, 0);
    982          #endif
    983          
    984            return (mmu_reg);
    985          }
    986          
    987          /***********************************************************************
    988           *
    989           * Function: cp15_set_mmu_control_reg
    990           *
    991           * Purpose:
    992           *  To set MMU Coprocessor (CP15) Control register.
    993           *
    994           * Processing:
    995           *  Set the MMU control register to a value passed as parameter.
    996           *
    997           * Parameters:
    998           *  mmu_reg - The value to be set in the MMU Control register (cp15).
    999           *
   1000           * Outputs: None
   1001           *
   1002           * Returns: None
   1003           *
   1004           * Notes: None
   1005           *
   1006           **********************************************************************/
   1007          void cp15_set_mmu_control_reg(UNS_32 mmu_reg)
   1008          {
   1009          #ifdef __GNUC__
   1010          __asm__ volatile("MCR p15, 0, %0, c1, c0, 0" : "=r"(mmu_reg));
   1011          #endif
   1012          
   1013          #ifdef __ghs__
   1014            set_mmu(mmu_reg);
   1015          #endif
   1016          
   1017          #ifdef __arm
   1018            __asm
   1019            {
   1020              MCR     p15, 0, mmu_reg, ARM922T_MMU_REG_CONTROL, c0, 0
   1021            }
   1022          #endif
   1023          #ifdef __ICCARM__
   1024          
   1025            /* Use IAR intrinsic functions */
   1026            __MCR(15, 0, (UNS_32)mmu_reg, 1, 0, 0);
   1027          #endif
   1028          }
   1029          
   1030          /***********************************************************************
   1031           *
   1032           * Function: cp15_set_mmu
   1033           *
   1034           * Purpose:
   1035           *  To enable or disable the MMU as specified.
   1036           *
   1037           * Processing:
   1038           *  Fetch the MMU control register to a variable. If the argument passed
   1039           *  is true, set the MMU enable bit, otherwise, clear it. Write the
   1040           *  resultant value back to the control register.
   1041           *
   1042           * Parameters:
   1043           *  enable - TRUE if the MMU must be enabled
   1044           *           FALSE if the MMU must be disabled
   1045           *
   1046           * Outputs: None
   1047           *
   1048           * Returns: Nothing
   1049           *
   1050           * Notes: None
   1051           *
   1052           **********************************************************************/
   1053          void cp15_set_mmu(BOOL_32 enable)
   1054          {
   1055            register UNS_32 mmu_reg;
   1056          
   1057            /* Read-Modify-Write the MMU register */
   1058            mmu_reg = cp15_get_mmu_control_reg();
   1059          
   1060            if (enable)
   1061            {
   1062              mmu_reg |= ARM922T_MMU_CONTROL_M;
   1063            }
   1064            else
   1065            {
   1066              mmu_reg &= ~ARM922T_MMU_CONTROL_M;
   1067            }
   1068          
   1069          #ifdef __GNUC__
   1070          __asm__ volatile("MCR p15, 0, %0, c1, c0, 0" : "=r"(mmu_reg));
   1071          #endif
   1072          
   1073          #ifdef __ghs__
   1074            set_mmu(mmu_reg);
   1075          #endif
   1076          
   1077          #ifdef __arm
   1078            __asm
   1079            {
   1080              MCR     p15, 0, mmu_reg, ARM922T_MMU_REG_CONTROL, c0, 0
   1081            }
   1082          #endif
   1083          #ifdef __ICCARM__
   1084          
   1085            /* Use IAR intrinsic functions */
   1086            __MCR(15, 0, (UNS_32)mmu_reg, 1, 0, 0);
   1087          #endif
   1088          
   1089          }
   1090          
   1091          /***********************************************************************
   1092           *
   1093           * Function: cp15_invalidate_cache
   1094           *
   1095           * Purpose:
   1096           *  Invalidates the Instruction and Data caches
   1097           *
   1098           * Processing:
   1099           *  Use the ARM instruction to unconditionally invalidate the entire
   1100           *  cache.
   1101           *
   1102           * Parameters: None
   1103           *
   1104           * Outputs: None
   1105           *
   1106           * Returns: Nothing
   1107           *
   1108           * Notes:
   1109           *  This function invalidates all cache data including dirty data (data
   1110           *  that has been modified in cache but not yet written to main memory).
   1111           *  Use with caution. See ARM922T TRM.
   1112           *
   1113           **********************************************************************/
   1114          void cp15_invalidate_cache(void)
   1115          {
   1116          #ifdef __GNUC__
   1117            // Invalidate both I- and D-cache completely
   1118            __asm__ volatile("MOV r0, #0");
   1119            __asm__ volatile("MCR p15, 0, r0, c7, c7, 0");
   1120          #endif
   1121          #ifdef __ghs__
   1122            inval_all_cache();
   1123          #endif
   1124          
   1125          #ifdef __arm
   1126            UNS_32 trx;
   1127            __asm
   1128            {
   1129              MOV     trx, 0
   1130              MCR     p15, 0, trx, c7, c7, 0
   1131            }
   1132          #endif
   1133          #ifdef __ICCARM__
   1134            {
   1135              register UNS_32 temp = 0;
   1136          
   1137              /* Use IAR intrinsic functions */
   1138              __MCR(15, 0, (UNS_32)temp, 7, 7, 0);
   1139            }
   1140          #endif
   1141          }
   1142          
   1143          /***********************************************************************
   1144           *
   1145           * Function: cp15_invalidate_tlb
   1146           *
   1147           * Purpose:
   1148           *  Invalidates the Translation Lookaside Buffers
   1149           *
   1150           * Processing:
   1151           *  Use the ARM instruction to unconditionally invalidate the I- and D-
   1152           *  TLBs.
   1153           *
   1154           * Parameters: None
   1155           *
   1156           * Outputs: None
   1157           *
   1158           * Returns: Nothing
   1159           *
   1160           * Notes:
   1161           *  See the ARM922T TRM.
   1162           *
   1163           **********************************************************************/
   1164          void cp15_invalidate_tlb(void)
   1165          {
   1166          #ifdef __GNUC__
   1167            __asm__ volatile
   1168              (
   1169                "MOV r0, #0" "\n\t"
   1170                "MCR p15, 0, r0, c8, c7, 0" "\n\t"
   1171                "NOP" "\n\t"
   1172                "NOP" "\n\t"
   1173                "NOP" "\n\t"
   1174              );
   1175          #endif
   1176          #ifdef __ghs__
   1177            inval_all_tlb();
   1178          #endif
   1179          
   1180          #ifdef __arm
   1181            UNS_32 trx;
   1182            __asm
   1183            {
   1184              MOV     trx, 0
   1185              // Invalidate TLBs
   1186              MCR      p15, 0, trx, ARM922T_MMU_REG_TLB_OPS, c7, 0
   1187              NOP
   1188              NOP
   1189              NOP
   1190            }
   1191          #endif
   1192          #ifdef __ICCARM__
   1193            {
   1194              register UNS_32 temp = 0;
   1195          
   1196              /* Use IAR intrinsic functions */
   1197              __MCR(15, 0, (UNS_32)temp, 8, 7, 0);
   1198              __no_operation();
   1199              __no_operation();
   1200              __no_operation();
   1201            }
   1202          #endif
   1203          }
   1204          
   1205          /***********************************************************************
   1206           *
   1207           * Function: cp15_set_transtable_base
   1208           *
   1209           * Purpose:
   1210           *  Sets the first-level translation table base address
   1211           *
   1212           * Processing:
   1213           *  Masks out the lower 12 bits of the address passed. Writes register
   1214           *  2 of CP15 with the base address passed as parameter.
   1215           *
   1216           * Parameters:
   1217           *  addr - Translation table base address
   1218           *
   1219           * Outputs: None
   1220           *
   1221           * Returns: Nothing
   1222           *
   1223           * Notes:
   1224           *  The address must be aligned on a 16K boundary. See ARM922T TRM.
   1225           *
   1226           **********************************************************************/
   1227          void cp15_set_transtable_base(UNS_32 addr)
   1228          {
   1229            addr &= 0xFFFFC000;
   1230          
   1231          #ifdef __GNUC__
   1232          __asm__ volatile("MCR p15, 0, %0, c2, c0, 0": "=r"(addr));
   1233          #endif
   1234          
   1235          #ifdef __ghs__
   1236            set_ttb(addr);
   1237          #endif
   1238          
   1239          #ifdef __arm
   1240            __asm
   1241            {
   1242              MCR     p15, 0, addr, ARM922T_MMU_REG_TTB, c0, 0
   1243            }
   1244          #endif
   1245          
   1246          #ifdef __ICCARM__
   1247            /* Use IAR intrinsic functions */
   1248            __MCR(15, 0, (UNS_32)addr, 2, 0, 0);
   1249          #endif
   1250          }
   1251          
   1252          /***********************************************************************
   1253           *
   1254           * Function: cp15_set_icache
   1255           *
   1256           * Purpose:
   1257           *  Enables or disables the instruction cache
   1258           *
   1259           * Processing:
   1260           *  Fetch the MMU control register to a variable. If the argument passed
   1261           *  is true, set the I-cache enable bit, otherwise, clear it. Write the
   1262           *  resultant value back to the control register.
   1263           *
   1264           * Parameters:
   1265           *  enable - TRUE if the I-cache must be enabled
   1266           *           FALSE if the I-cache must be disabled
   1267           *
   1268           * Outputs: None
   1269           *
   1270           * Returns: Nothing
   1271           *
   1272           * Notes: None
   1273           *
   1274           **********************************************************************/
   1275          void cp15_set_icache(BOOL_32 enable)
   1276          {
   1277            UNS_32 mmu_reg;
   1278          
   1279            mmu_reg = cp15_get_mmu_control_reg();
   1280          
   1281            if (enable)
   1282              mmu_reg |= ARM922T_MMU_CONTROL_I;
   1283            else
   1284              mmu_reg &= ~ARM922T_MMU_CONTROL_I;
   1285          
   1286          #ifdef __GNUC__
   1287          __asm__ volatile("MCR p15, 0, %0, c1, c0, 0" : "=r"(mmu_reg));
   1288          #endif
   1289          
   1290          #ifdef __ghs__
   1291            set_mmu(mmu_reg);
   1292          #endif
   1293          
   1294          #ifdef __arm
   1295            __asm
   1296            {
   1297              MCR     p15, 0, mmu_reg, ARM922T_MMU_REG_CONTROL, c0, 0
   1298            }
   1299          #endif
   1300          #ifdef __ICCARM__
   1301            /* Use IAR intrinsic functions */
   1302            __MCR(15, 0, (UNS_32)mmu_reg, 1, 0, 0);
   1303          #endif
   1304          }
   1305          
   1306          /***********************************************************************
   1307           *
   1308           * Function: cp15_set_dcache
   1309           *
   1310           * Purpose:
   1311           *  Enables or disables the data cache
   1312           *
   1313           * Processing:
   1314           *  Fetch the MMU control register to a variable. If the argument passed
   1315           *  is true, set the D-cache enable bit, otherwise, clear it. Write the
   1316           *  resultant value back to the control register.
   1317           *
   1318           * Parameters:
   1319           *  enable - TRUE if the D-cache must be enabled
   1320           *           FALSE if the D-cache must be disabled
   1321           *
   1322           * Outputs: None
   1323           *
   1324           * Returns: Nothing
   1325           *
   1326           * Notes: None
   1327           *
   1328           **********************************************************************/
   1329          void cp15_set_dcache(BOOL_32 enable)
   1330          {
   1331            UNS_32 mmu_reg;
   1332          
   1333            mmu_reg = cp15_get_mmu_control_reg();
   1334          
   1335            if (enable)
   1336              mmu_reg |= ARM922T_MMU_CONTROL_C;
   1337            else
   1338              mmu_reg &= ~ARM922T_MMU_CONTROL_C;
   1339          
   1340          #ifdef __GNUC__
   1341          __asm__ volatile("MCR p15, 0, %0, c1, c0, 0" : "=r"(mmu_reg));
   1342          #endif
   1343          
   1344          #ifdef __ghs__
   1345            set_mmu(mmu_reg);
   1346          #endif
   1347          
   1348          #ifdef __arm
   1349            __asm
   1350            {
   1351              MCR     p15, 0, mmu_reg, ARM922T_MMU_REG_CONTROL, c0, 0
   1352            }
   1353          #endif
   1354          #ifdef __ICCARM__
   1355            /* Use IAR intrinsic functions */
   1356            __MCR(15, 0, (UNS_32)mmu_reg, 1, 0, 0);
   1357          #endif
   1358          }
   1359          
   1360          /***********************************************************************
   1361           *
   1362           * Function: cp15_set_domain_access
   1363           *
   1364           * Purpose:
   1365           *  Define the access permissions for the 16 MMU domains.
   1366           *
   1367           * Processing:
   1368           *  Use the ARM instruction to write the value passed as argument to
   1369           *  the domain access control regsiter.
   1370           *
   1371           * Parameters:
   1372           *  dac - 32-bit value encoded as follows:
   1373           *
   1374           *   31  29  27  25  23  21  19  17  15  13  11  9 8 7 6 5 4 3 2 1 0
   1375           *   ---------------------------------------------------------------
   1376           *  |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
   1377           *   ---------------------------------------------------------------
   1378           *   For each domain (2 bits),
   1379           *     00 - No access
   1380           *     01 - Client
   1381           *     10 - Reserved (same as no access)
   1382           *     11 - Manager
   1383           *
   1384           * Outputs: None
   1385           *
   1386           * Returns: Nothing
   1387           *
   1388           * Notes:
   1389           *  See the ARM922T TRM.
   1390           *
   1391           **********************************************************************/
   1392          void cp15_set_domain_access(UNS_32 dac)
   1393          {
   1394          #ifdef __GNUC__
   1395          __asm__ volatile("MCR p15, 0, %0, c3, c0, 0" : "=r"(dac));
   1396          #endif
   1397          #ifdef __ghs__
   1398            set_dac(dac);
   1399          #endif
   1400          
   1401          #ifdef __arm
   1402            __asm
   1403            {
   1404              MCR     p15, 0, dac, ARM922T_MMU_REG_DAC, c0, 0
   1405            }
   1406          #endif
   1407          #ifdef __ICCARM__
   1408            /* Use IAR intrinsic functions */
   1409            __MCR(15, 0, (UNS_32)dac, 3, 0, 0);
   1410          #endif
   1411          }
   1412          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   cp15_dcache_flush
       0   cp15_decode_level2
       0   cp15_force_cache_coherence
       0   cp15_get_mmu_control_reg
       0   cp15_get_ttb
      20   cp15_init_mmu_trans_table
       0   cp15_invalidate_cache
       0   cp15_invalidate_tlb
      40   cp15_map_physical_to_virtual
        40   -> cp15_decode_level2
      20   cp15_map_virtual_to_physical
       0   cp15_mmu_enabled
      16   cp15_set_dcache
        16   -> cp15_get_mmu_control_reg
       0   cp15_set_domain_access
      16   cp15_set_icache
        16   -> cp15_get_mmu_control_reg
      16   cp15_set_mmu
        16   -> cp15_get_mmu_control_reg
       0   cp15_set_mmu_control_reg
       0   cp15_set_transtable_base
       0   cp15_set_vmmu_addr
       0   cp15_write_buffer_flush


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  cp15_dcache_flush
     172  cp15_decode_level2
      76  cp15_force_cache_coherence
      12  cp15_get_mmu_control_reg
      12  cp15_get_ttb
     328  cp15_init_mmu_trans_table
      12  cp15_invalidate_cache
      24  cp15_invalidate_tlb
     336  cp15_map_physical_to_virtual
     308  cp15_map_virtual_to_physical
      16  cp15_mmu_enabled
      44  cp15_set_dcache
       8  cp15_set_domain_access
      44  cp15_set_icache
      44  cp15_set_mmu
       8  cp15_set_mmu_control_reg
      16  cp15_set_transtable_base
      12  cp15_set_vmmu_addr
       4  cp15_write_buffer_flush
       4  virtual_tlb_addr

 
     4 bytes in section .bss
 1 484 bytes in section .text
 
 1 484 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none
