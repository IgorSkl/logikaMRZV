###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        12/Oct/2015  11:05:08
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  D:\IAR projects\HR1_0100_00_I720_new2\ici\ssp1L.c
#    Command line =  
#        "D:\IAR projects\HR1_0100_00_I720_new2\ici\ssp1L.c" -D
#        _STATIC_MEMORY_BOOT -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\List\ssp1L.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\Obj\ssp1L.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\ici\ssp1L.c
      1          /*------------------------------------------------------------------------------
      2          * Copyright (c) 2013 - Factory “KyivPrylad”
      3          * 
      4          * Permission to use, copy, modify, and distribute this software for any
      5          * purpose with or without fee is hereby granted, provided that the above
      6          * copyright notice and this permission notice appear in all copies.
      7          * 
      8          * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
      9          * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
     10          * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
     11          * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
     12          * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
     13          * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
     14          * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
     15          * 
     16          *------------------------------------------------------------------------------
     17          *
     18          * Processor       : Lpc_3240
     19          * File Name       : ssp1L.c
     20          * Description     : Functions and Data for Low Level Communication,
     21                              BO BR
     22          
     23          *  Version        : 1.00
     24          *
     25          *       +----- (NEW | MODify | ADD | DELete)
     26          *       |
     27          *  No   |   When       Who                What
     28          *-----+---+----------+------------------+--------------------------------------
     29          * 000  NEW  02/09/13   Markovsky A       Creation
     30          *----------------------------------------------------------------------------*/
     31          
     32          
     33          #include <string.h>
     34          #include <intrinsics.h>
     35          #include "../LIB/CDL_AV0/lpc/include/lpc_types.h"
     36          #include "../LIB/CDL_AV0/lpc/include/lpc_irq_fiq.h"
     37          #include "../LIB/CDL_AV0/lpc/include/lpc_arm922t_cp15_driver.h"
     38          #include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_dma_driver.h"
     39          //#include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_uart_driver.h"
     40          #include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_ssp_driver.h"
     41          #include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_intc_driver.h"
     42          #include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_timer_driver.h"
     43          #define SIZE_SPI_BUF 800
     44          #include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_clkpwr_driver.h"
     45          #include "../LIB/CDL_AV0/csps/lpc32xx/include/lpc32xx_gpio_driver.h"
     46          
     47          static long lS = 0; 
     48           INT_32 sspdev0 = 0;
     49          static UNS_8 spi1_txbuff [SIZE_SPI_BUF]  @ "DMA_BUFFERS", spi1_rxbuff [SIZE_SPI_BUF] @ "DMA_BUFFERS";
     50          volatile  int spi1_txsize, spi1_rxsize;
     51          int spi1_txfill = 0;
     52          int spi1_rxget  = 0;
     53          int spi1_txget  = 0;
     54          int spi1_rxfill = 0;
     55          //.void foo(void)
     56          //.{
     57          //.	txfill = txget = rxfill = rxget = txsize = rxsize = 0;
     58          //.
     59          //.}
     60          extern unsigned char chEntry_Ssp0,chNeedLookStatusSsp0;
     61          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
     62          //---   
     63          void recv_cb_spi1(void)   @ "Fast_function";
     64          //..................................................................................
     65          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
     66          //~~~ Purpose: Read some data from the terminal interface                        ~~~
     67          //~~~ Processing: Move data from the ring buffer to the passed buffer            ~~~
     68          //~~~        ~~~
     69          //~~~        ~~~
     70          //~~~        ~~~
     71          //``````````````````````````````````````````````````````````````````````````````````
     72          //~~~ Returns: Number of bytes actually read                                      ~~
     73          //~~~                                                                             ~~ 
     74          //~~~                                                                             ~~
     75          //~~~          ~~
     76          //~~~          ~~
     77          //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
     78          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
     79          //=================================================================================
     80          //Body func                                                                  
     81          //=================================================================================
     82          void recv_cb_spi1(void)   @ "Fast_function"
     83          {
     84          INT_32 bread, toreadmax = SIZE_SPI_BUF - spi1_rxfill;
     85            SSP_REGS_T *psspregs = (SSP_REGS_T *) SSP0;
     86            //-* Read data *-/
     87            if ((psspregs->mis & SSP_MIS_RORMIS)!= 0) 
     88            {
     89          	toreadmax++;
     90            }
     91            //bread = Uart_read(uartdev, &rxbuff[rxfill], toreadmax);
     92            bread = Ssp_read(sspdev0,&spi1_rxbuff[spi1_rxfill], toreadmax);
     93            bread <<= 1;
     94            spi1_rxsize = spi1_rxsize + bread;
     95            spi1_rxfill = spi1_rxfill + bread;
     96            if (spi1_rxfill >= SIZE_SPI_BUF)
     97            {
     98              spi1_rxfill = 0;
     99            }
    100            
    101             if ((spi1_rxsize == 512) &&(spi1_rxfill==spi1_rxsize) )//SIZE_LPDU_CNL_SPI
    102             chEntry_Ssp0++;
    103            if(lS)lS--;
    104            else lS = 0;
    105            
    106          }
    107          
    108          //---------------------------------------------------------------------------------
    109          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    110          //---   
    111          void send_cb_spi1(void)   @ "Fast_function";
    112          //..................................................................................
    113          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    114          //~~~ Purpose: Read some data from the terminal interface                        ~~~
    115          //~~~ Processing: Move data from the ring buffer to the passed buffer            ~~~
    116          //~~~        ~~~
    117          //~~~        ~~~
    118          //~~~        ~~~
    119          //``````````````````````````````````````````````````````````````````````````````````
    120          //~~~ Returns: Number of bytes actually read                                      ~~
    121          //~~~                                                                             ~~ 
    122          //~~~                                                                             ~~
    123          //~~~          ~~
    124          //~~~          ~~
    125          //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
    126          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    127          //=================================================================================
    128          //Body func                                                                  
    129          //=================================================================================
    130          
    131          void send_cb_spi1(void)   @ "Fast_function"
    132          {
    133            INT_32 bwrite, tosend = SIZE_SPI_BUF - spi1_txget;
    134            //SSP_DRVDAT_T *psspdrvdat = sspdev0;
    135            SSP_REGS_T *psspregs = (SSP_REGS_T *) SSP0;
    136            if (tosend > spi1_txsize)
    137            {
    138              tosend = spi1_txsize;
    139            }
    140            else         //Debug Code
    141             tosend = 0;
    142            if (spi1_txsize == 0)//(tosend == 0)
    143            {
    144          	psspregs->imsc &= ~SSP_IMSC_TXIM;//regptr->ctrl &= ~ _TX_INT_EN;
    145          	chEntry_Ssp0++;//chNeedLookStatusSsp0++;
    146            }
    147            else
    148            {
    149          	//regptr->ctrl |= _TX_INT_EN;
    150            }
    151            if(lS==0)lS++;
    152            else
    153            {
    154              //lS = 0;
    155              return;
    156          	}
    157          
    158            //-* Write data *-/
    159            //bwrite = Uart_write(uartdev, &txbuff[txget], tosend);
    160            bwrite = Ssp_write(sspdev0, &spi1_txbuff[spi1_txget], tosend);
    161            bwrite <<= 1;
    162            spi1_txsize = spi1_txsize - bwrite;
    163            
    164            spi1_txget = spi1_txget + bwrite;
    165            
    166            if (spi1_txget >= SIZE_SPI_BUF)
    167            {
    168              spi1_txget = 0;
    169            }
    170            
    171          }
    172          //---------------------------------------------------------------------------------
    173          
    174          //Transmit 60 Byte
    175          //Receve 60 Biytea
    176          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    177          //---   
    178          long outSPI1(UNS_8 *dat, int bytes)   @ "Fast_function";
    179          //..................................................................................
    180          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    181          //~~~ Purpose:  Send some data on the terminal interface                         ~~~
    182          //~~~ Processing: Place data into the TX ring buffer and start UART transmission ~~~
    183          //~~~        ~~~
    184          //~~~  dat   : Data to send                                                      ~~~
    185          //~~~  bytes : Number of bytes to send                                           ~~~
    186          //``````````````````````````````````````````````````````````````````````````````````
    187          //~~~ Notes: Will block until all bytes are sent                                  ~~
    188          //~~~                                                                             ~~ 
    189          //~~~                                                                             ~~
    190          //~~~          ~~
    191          //~~~          ~~
    192          //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
    193          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    194          //=================================================================================
    195          //Body func                                                                  
    196          //=================================================================================
    197          
    198          long outSPI1(UNS_8 *dat, int bytes)   @ "Fast_function"
    199          {
    200           
    201            disable_irq();//int_disable(IRQ_UART_IIR2);
    202            if ((spi1_txfill == spi1_txget)&&(spi1_txsize==0))
    203            spi1_txget = spi1_txfill = 0;//.!!!
    204             enable_irq();//int_enable(IRQ_UART_IIR2);
    205             
    206           while (bytes > 0)
    207            {
    208              while ((bytes > 0) && (spi1_txsize < SIZE_SPI_BUF))
    209              {
    210                spi1_txbuff[spi1_txfill] = *dat;
    211                spi1_txfill++;
    212                if (spi1_txfill >= SIZE_SPI_BUF)
    213                {
    214                  spi1_txfill = 0;
    215                }
    216                dat++;
    217                bytes--;
    218                disable_irq();//.int_disable(IRQ_UART_IIR3);
    219                spi1_txsize++;
    220                enable_irq();//.int_enable(IRQ_UART_IIR3);
    221              }
    222          
    223              disable_irq();//.int_disable(IRQ_UART_IIR3);
    224              //.
    225          	send_cb_spi1();
    226              enable_irq();//.int_enable(IRQ_UART_IIR3);
    227            }
    228            
    229            return 0;
    230          }
    231          //---------------------------------------------------------------------------------
    232          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    233          //---   
    234          long inSPI1(UNS_8 *buff, int bytes)   @ "Fast_function";
    235          //..................................................................................
    236          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    237          //~~~ Purpose: Read some data from the terminal interface                        ~~~
    238          //~~~ Processing: Move data from the ring buffer to the passed buffer            ~~~
    239          //~~~        ~~~
    240          //~~~        ~~~
    241          //~~~        ~~~
    242          //``````````````````````````````````````````````````````````````````````````````````
    243          //~~~ Returns: Number of bytes actually read                                      ~~
    244          //~~~                                                                             ~~ 
    245          //~~~                                                                             ~~
    246          //~~~          ~~
    247          //~~~          ~~
    248          //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
    249          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    250          //=================================================================================
    251          //Body func                                                                  
    252          //=================================================================================
    253          long inSPI1(UNS_8 *buff, int bytes)   @ "Fast_function"
    254          {
    255          
    256          int bread = 0;
    257          
    258            while ((bytes > 0) && (spi1_rxsize > 0))
    259            {
    260              *buff = spi1_rxbuff[spi1_rxget+2];
    261              buff++;
    262              spi1_rxget++;
    263              if (spi1_rxget >= SIZE_SPI_BUF)
    264              {
    265                spi1_rxget = 0;
    266              }
    267              bytes--;
    268              bread++;
    269              disable_irq();//.int_disable(IRQ_UART_IIR3);
    270              spi1_rxsize--;
    271              enable_irq();//.int_enable(IRQ_UART_IIR3);
    272            }
    273            if (spi1_rxfill == spi1_rxget)
    274            {
    275          	disable_irq();//int_disable(IRQ_UART_IIR2);
    276          	spi1_rxfill = spi1_rxget = 0;
    277          	enable_irq();//int_enable(IRQ_UART_IIR2);
    278            }
    279          
    280            return bread;
    281          	
    282          	
    283          }
    284          //---------------------------------------------------------------------------------
    285          long Ssp_Syncro(void)
    286          {
    287          long count = 0;
    288          SSP_REGS_T *psspregs = (SSP_REGS_T *) SSP0;
    289          
    290           volatile unsigned short connect_RV = 0;// 0x9483;
    291           volatile unsigned short connect_TR = 0x2875;
    292             volatile unsigned short tmp1 = 0;
    293             
    294          while ((connect_RV != 0x9483) )//&&
    295                     //((sspcfgptr->regptr->sr & SSP_SR_RNE) != 0))
    296              {
    297          		if ((psspregs->sr & SSP_SR_TFE) != 0)
    298          		{
    299          			psspregs->data =(UNS_32) connect_TR;
    300          		}
    301          		
    302          		if (((psspregs->sr & SSP_SR_RNE) != 0))
    303          		{
    304          			tmp1 = psspregs->data;
    305          			connect_RV = (UNS_16) tmp1;
    306          		}
    307          	}
    308          }
    309          long lSsp0HdwState = 0;
    310          long Ssp_Syncro1(void)
    311          {
    312          register long i;
    313          long count = 3;
    314          SSP_REGS_T *psspregs = (SSP_REGS_T *) SSP0;
    315          i = 0;
    316           volatile unsigned short connect_RV = 0;// 0x9483;
    317           volatile unsigned short connect_TR = 0x2875;
    318           volatile unsigned short tmp1 = 0;
    319           volatile unsigned short ushSucses = 0;
    320          while ( count--)//&&(connect_RV != 0x9483)&&
    321                     //((sspcfgptr->regptr->sr & SSP_SR_RNE) != 0))
    322              {
    323          		while ( ((psspregs->sr & SSP_SR_BSY) != 0) )
    324          					{
    325          						;
    326          					}
    327          		if ((psspregs->sr & SSP_SR_TFE) != 0)
    328          		{
    329          			psspregs->data =(UNS_32) (connect_TR+i);
    330          		}
    331          		while ( ((psspregs->sr & SSP_SR_BSY) != 0) )
    332          					{
    333          						;
    334          					}
    335          		//while(((psspregs->sr & SSP_SR_RNE) != 0));//
    336          		if (((psspregs->sr & SSP_SR_RNE) != 0))
    337          		{
    338          			
    339          			tmp1 = psspregs->data;
    340          			if(tmp1==(0x9483+i))
    341          			{
    342          				connect_RV = (UNS_16) tmp1;
    343          				ushSucses++;
    344          				if((ushSucses==2))
    345          				{
    346          					if(i != 1)return 1;
    347          				}
    348          				if(ushSucses==3)
    349          				{
    350          					
    351          					if ((psspregs->sr & SSP_SR_TFE) != 0)
    352          					{
    353          						psspregs->data =(UNS_32) (connect_TR+i);
    354          					}
    355          					while ( ((psspregs->sr & SSP_SR_RNE) != 0) )
    356          					{
    357          						tmp1 = psspregs->data;
    358          						connect_RV = (UNS_16) tmp1;;
    359          					}
    360          					while ( ((psspregs->sr & SSP_SR_BSY) != 0) )
    361          					{
    362          						;
    363          					}
    364          					 tmp1 = 0xf000;
    365          
    366          					while(tmp1)
    367          					tmp1--;
    368          					while ( ((psspregs->sr & SSP_SR_RNE) != 0) )
    369          					{
    370          						tmp1 = psspregs->data;
    371          						connect_RV = (UNS_16) tmp1;;
    372          					}
    373          					lSsp0HdwState |= 4;//Spi Ready for Packet Exchange
    374          					//Init Hdr + Buff
    375          					Int_enable1(IRQ_SSP0);
    376          				}	
    377          			}
    378          			else
    379          			{
    380          				return 1;
    381          			}
    382          			
    383          		}
    384          		i++;
    385          	}
    386          	return 0;
    387          }
    388          static long  lInitStateCnl = 0;
    389          long Ssp_Syncro2(void)
    390          {
    391          register long i;
    392          long count = 3;
    393              union 
    394          	    {
    395          	    	unsigned char   uchAr [4];
    396          	    	unsigned short  ushAr [2];
    397                      unsigned long   ulVal;
    398          	    }unnV1;
    399          struct 
    400          	{
    401          		unsigned char uchError;
    402          		unsigned char uchHdwrError;
    403          		//unsigned char uChIdxByte ;
    404          		unsigned short ushReceiveCmd;
    405          		unsigned short ushSendAnswerCmd;
    406          		//unsigned char *pUchRV;
    407          		
    408          		
    409          	} sLV;
    410          SSP_REGS_T *psspregs = (SSP_REGS_T *) SSP0;
    411          i = 0;
    412           volatile unsigned short connect_RV = 0;// 0x9483;
    413           volatile unsigned short connect_TR = 0x2875;
    414           volatile unsigned short tmp1 = 0;
    415           volatile unsigned short ushSucses = 0;
    416           
    417          i = 0;sLV.uchHdwrError =  sLV.uchError = sLV.ushReceiveCmd = sLV.ushSendAnswerCmd =0;
    418          switch (lInitStateCnl )
    419          	{
    420          		case 0:
    421          			sLV.ushSendAnswerCmd = 0x2875;
    422          		break;
    423          		case 1:
    424          			sLV.ushSendAnswerCmd = 0x2875;
    425          		break;
    426          		case 2://
    427          			sLV.ushSendAnswerCmd = 0x2876;
    428          		break;
    429          		case 4: case 3://
    430          			sLV.ushSendAnswerCmd = 0x2877;
    431          		break;
    432          		//case 4://
    433          		//	sLV.ushSendAnswerCmd = 0x2877;
    434          		//break;
    435          		
    436          	 default:
    437          		sLV.ushSendAnswerCmd = 0x2875;
    438          	}
    439          
    440          //Write Cmd 
    441          while ( ((psspregs->sr & SSP_SR_BSY) != 0) )
    442          {
    443          	;
    444          }
    445          if ((psspregs->sr & SSP_SR_TFE) != 0)
    446          {
    447          	psspregs->data =(UNS_32) sLV.ushSendAnswerCmd;//(connect_TR+i);
    448          }
    449          while ( ((psspregs->sr & SSP_SR_BSY) != 0) )
    450          {
    451          	;
    452          }	
    453          	if (((psspregs->sr & SSP_SR_RNE) != 0))//Answer Present
    454          	{
    455          		
    456          		tmp1 = psspregs->data;
    457          		if((tmp1>>4)!= 0x948)
    458          		{
    459          			//Error Syncro
    460          			lInitStateCnl = 0;
    461          			return 1;
    462          		}
    463          		else
    464          		{
    465          			//Decode Answer
    466          			sLV.ushReceiveCmd = tmp1;
    467          			switch(sLV.ushReceiveCmd )
    468          			{
    469          				case 0x9483:
    470          				//Look Curr state
    471          				if (lInitStateCnl <= 2)
    472          				{
    473          					sLV.ushSendAnswerCmd = 0x2876;//0x9483;//State 2
    474          					lInitStateCnl = 2;
    475          				}
    476          				else 
    477          				{
    478          					//~if(lInitStateCnl == 3)
    479          					//~sLV.ushSendAnswerCmd = //0x9484;//Send Current State
    480          					//~if(lInitStateCnl == 4)
    481          					//~sLV.ushSendAnswerCmd = //0x9485;//Send Current State
    482          					
    483          				}
    484          				//unnV1. uchAr [3] = lInitStateCnl;
    485          				break;
    486          				case 0x9484:
    487          				if ((lInitStateCnl <= 3)&&(lInitStateCnl>0))
    488          				{
    489          					sLV.ushSendAnswerCmd = 0x2877;//0x9484;//State 2
    490          					lInitStateCnl = 3;
    491          				}
    492          				else 
    493          				{
    494          					//May Be Reset syncro?
    495          					//~if(lInitStateCnl == 2)
    496          					//~sLV.ushSendAnswerCmd = //0x9484;//Send Current State
    497          					//~if(lInitStateCnl == 4)
    498          					//~sLV.ushSendAnswerCmd = //0x9485;//Send Current State
    499          					//~if (lInitStateCnl <= 1)
    500          					//~sLV.ushSendAnswerCmd = //0x9483;
    501          				}
    502          				//unnV1. uchAr [3] = lInitStateCnl;
    503          				break;
    504          				case 0x9485:
    505          				if ((lInitStateCnl <= 4)&&(lInitStateCnl>1))
    506          				{
    507          					if(lInitStateCnl == 4)
    508          					{
    509          						//unnV1.ushAr [0] = SPI_Read(AT91C_BASE_SPI0);
    510          						//End  of Syncro
    511          						lSsp0HdwState |= 4;
    512          						//Init Hdr + Buff
    513          						Int_enable1(IRQ_SSP0);
    514          						//ReInit for Use PDC
    515          						//StartSetPDC();
    516          						return 0;
    517          					}	
    518          					//sLV.ushSendAnswerCmd = //0x9485;//State 2
    519          					lInitStateCnl = 4;
    520          					lSsp0HdwState |= 4;
    521          					Int_enable1(IRQ_SSP0);
    522          				}
    523          				else
    524          				{
    525          					//sLV.uchError++;//Not Adecvate Sequence Cmd
    526          					//~if (lInitStateCnl <= 1)
    527          					//~sLV.ushSendAnswerCmd = //0x9483;
    528          					//~if(lInitStateCnl == 2)
    529          					//~sLV.ushSendAnswerCmd = //0x9484;//Send Current State
    530          				
    531          				}
    532          				//unnV1. uchAr [3] = lInitStateCnl;
    533          				break;
    534          				
    535          				default: 
    536          				//~sLV.ushSendAnswerCmd = 0x2875;//0x9484;//Reset State
    537          				//unnV1. uchAr [3] = 1;//Error state start Init
    538          			}	
    539          		}
    540          		
    541          	}
    542          	
    543          	
    544          	
    545          	
    546          	return 0;
    547          }
    548          char chCounterCurState2 = 0; 
    549          char chCounterCurState3 = 0; 
    550          char chCounterCurState4 = 0; 
    551          long lSpiAccessCtrl = 1;//Ogranichitel dostupa
    552          long Ssp_Syncro3(void) @ "Fast_function_no_cache"
    553          {
    554          register long i;
    555          long count = 3;
    556              union 
    557          	    {
    558          	    	unsigned char   uchAr [4];
    559          	    	unsigned short  ushAr [2];
    560                      unsigned long   ulVal;
    561          	    }unnV1;
    562          struct 
    563          	{
    564          		unsigned char uchError;
    565          		unsigned char uchHdwrError;
    566          		//unsigned char uChIdxByte ;
    567          		unsigned short ushReceiveCmd;
    568          		unsigned short ushSendAnswerCmd;
    569          		//unsigned char *pUchRV;
    570          		
    571          		
    572          	} sLV;
    573          SSP_REGS_T *psspregs = (SSP_REGS_T *) SSP0;
    574          i = 0;
    575           volatile unsigned short connect_RV = 0;// 0x9483;
    576           volatile unsigned short connect_TR = 0x2875;
    577           volatile unsigned short tmp1 = 0;
    578           volatile unsigned short ushSucses = 0;
    579           
    580          i = 0;sLV.uchHdwrError =  sLV.uchError = sLV.ushReceiveCmd = sLV.ushSendAnswerCmd =0;
    581          switch (lInitStateCnl )
    582          	{
    583          		case 0:
    584          			sLV.ushSendAnswerCmd = 0x2875;
    585          		break;
    586          		case 1:
    587          			sLV.ushSendAnswerCmd = 0x2875;
    588          		break;
    589          		case 2://
    590          			sLV.ushSendAnswerCmd = 0x2876;
    591          		break;
    592          		case 3:case 4://
    593          			sLV.ushSendAnswerCmd = 0x2877;
    594          		break;
    595          		//case 4://
    596          		//	sLV.ushSendAnswerCmd = 0x2877;
    597          		//break;
    598          		
    599          	 default:
    600          		sLV.ushSendAnswerCmd = 0x2875;
    601          	}
    602          if (lSpiAccessCtrl>0 && (lSpiAccessCtrl<0x40000000)) {lSpiAccessCtrl--;return 0; }
    603          //Write Cmd 
    604          while ( ((psspregs->sr & SSP_SR_BSY) != 0) )
    605          {
    606          	;
    607          }
    608          if ((psspregs->sr & SSP_SR_TFE) != 0)
    609          {
    610          	psspregs->data =(UNS_32) sLV.ushSendAnswerCmd;//(connect_TR+i);
    611          }
    612          while ( ((psspregs->sr & SSP_SR_BSY) != 0) )
    613          {
    614          	;
    615          }	
    616          	if (((psspregs->sr & SSP_SR_RNE) != 0))//Answer Present
    617          	{
    618          		
    619          		tmp1 = psspregs->data;
    620          		if((tmp1>>4)!= 0x948)
    621          		{
    622          			//Error Syncro
    623          			lInitStateCnl = 0;
    624          			return 1;
    625          		}
    626          		else
    627          		{
    628          			//Decode Answer
    629          			sLV.ushReceiveCmd = tmp1;
    630          			switch(sLV.ushReceiveCmd )
    631          			{
    632          				case 0x9483:
    633          				//Look Curr state
    634          				if (lInitStateCnl <= 2)
    635          				{
    636          					sLV.ushSendAnswerCmd = 0x2876;//0x9483;//State 2
    637          					lInitStateCnl = 2;
    638          					chCounterCurState2++;lSpiAccessCtrl = 100;
    639          					if(chCounterCurState2>5)
    640          					{
    641          					chCounterCurState2 = 0;
    642          					lInitStateCnl = 1;
    643          					}
    644          				}
    645          				else 
    646          				{
    647          					//~if(lInitStateCnl == 3)
    648          					//~sLV.ushSendAnswerCmd = //0x9484;//Send Current State
    649          					//~if(lInitStateCnl == 4)
    650          					//~sLV.ushSendAnswerCmd = //0x9485;//Send Current State
    651          					
    652          				}
    653          				//unnV1. uchAr [3] = lInitStateCnl;
    654          				break;
    655          				case 0x9484:
    656          				if ((lInitStateCnl <= 3)&&(lInitStateCnl>1))
    657          				{
    658          					sLV.ushSendAnswerCmd = 0x2877;//0x9484;//State 2
    659          					lInitStateCnl = 3;lSpiAccessCtrl = 9500;
    660          				}
    661          				else 
    662          				{
    663          					//May Be Reset syncro?
    664          					 sLV.uchError++; if(lInitStateCnl>0) lInitStateCnl--;//~if(lInitStateCnl == 2)
    665          					for(;;);//~sLV.ushSendAnswerCmd = //0x9484;//Send Current State
    666          					//~if(lInitStateCnl == 4)
    667          					//~sLV.ushSendAnswerCmd = //0x9485;//Send Current State
    668          					//~if (lInitStateCnl <= 1)
    669          					//~sLV.ushSendAnswerCmd = //0x9483;
    670          				}
    671          				//unnV1. uchAr [3] = lInitStateCnl;
    672          				break;
    673          				case 0x9485:case 0x9486:
    674          				if ((lInitStateCnl <= 4)&&(lInitStateCnl>2))
    675          				{
    676          					if((lInitStateCnl == 4)&&(sLV.ushReceiveCmd==0x9486))
    677          					{
    678          						//unnV1.ushAr [0] = SPI_Read(AT91C_BASE_SPI0);
    679          						//End  of Syncro
    680          						lSsp0HdwState |= 4;
    681          						//Init Hdr + Buff
    682          						Int_enable1(IRQ_SSP0);//for(;;);
    683          						//ReInit for Use PDC
    684          						//StartSetPDC();
    685          						return 0;
    686          					}	
    687          					//sLV.ushSendAnswerCmd = //0x9485;//State 2
    688          					lInitStateCnl = 4;//psspregs->data =(UNS_32) 0x2877;
    689          					lSpiAccessCtrl = 4;//lSsp0HdwState |= 4;
    690          					//for(;;);//Int_enable1(IRQ_SSP0);
    691          				}
    692          				else
    693          				{
    694          					//sLV.uchError++;//Not Adecvate Sequence Cmd
    695          					//~if (lInitStateCnl <= 1)
    696          					//~sLV.ushSendAnswerCmd = //0x9483;
    697          					//~if(lInitStateCnl == 2)
    698          					//~sLV.ushSendAnswerCmd = //0x9484;//Send Current State
    699          				sLV.uchError++; if(lInitStateCnl>0) lInitStateCnl = 0;for(;;);
    700          				}
    701          				//unnV1. uchAr [3] = lInitStateCnl;
    702          				break;
    703          				case 0x9487:case 0x9489:sLV.ushSendAnswerCmd = 0x2877;lInitStateCnl = 3;break;
    704          				default: 
    705          				//~sLV.ushSendAnswerCmd = 0x2875;//0x9484;//Reset State
    706          				//unnV1. uchAr [3] = 1;//Error state start Init
    707          			}	
    708          		}
    709          		
    710          	}
    711          	
    712          	
    713          	
    714          	
    715          	return 0;
    716          }
    717          void Spi0_Rst(void) @ "Fast_function"
    718          {
    719          lInitStateCnl = 0;
    720          lSsp0HdwState = 0;
    721          Int_disable1(IRQ_SSP0);//Int_enable1(IRQ_SSP0);
    722          
    723          }
    724          long outSPIDma(UNS_8 *dat, int bytes)   @ "Fast_function"
    725          {
    726          register long i;
    727          register void *pv;
    728          register long IdxChnl;
    729          unsigned short usTransferSize = 0x100;//256;
    730            disable_irq();//int_disable(IRQ_UART_IIR2);
    731            if ((spi1_txfill == spi1_txget)&&(spi1_txsize==0))
    732            spi1_txget = spi1_txfill = 0;//.!!!
    733             enable_irq();//int_enable(IRQ_UART_IIR2);
    734             pv = (void*)Dma_get_base();
    735             IdxChnl = 7;
    736             i= *((long*)0x20084008);
    737             //Clear any pending Interrupts on the channel
    738             ((DMAC_REGS_T*)pv)->int_tc_clear  = (1<<IdxChnl);//Must Later Selector allocate channel
    739             ((DMAC_REGS_T*)pv)->int_err_clear = (1<<IdxChnl);
    740             ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].src_addr  = 0x20084008;//Now SSP Reg for Down Load Data
    741             ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].dest_addr = (unsigned long)&spi1_rxbuff[0];
    742             ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].lli       = 0;
    743             
    744          	i = (DMAC_CHAN_INT_TC_EN 
    745          	| DMAC_CHAN_DEST_AUTOINC //|
    746                | DMAC_CHAN_DEST_AHB1  // | DMAC_CHAN_SRC_AUTOINC 
    747                  | DMAC_CHAN_SRC_AHB1 |DMAC_CHAN_DEST_WIDTH_16 //DMAC_CHAN_DEST_WIDTH_32 |
    748                  | DMAC_CHAN_SRC_WIDTH_16 | DMAC_CHAN_DEST_BURST_4 //|DMAC_CHAN_SRC_WIDTH_32  
    749                  | DMAC_CHAN_SRC_BURST_4 //|
    750                  | (DMAC_CHAN_TRANSFER_SIZE(usTransferSize)));   
    751             
    752             ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].control   = i;
    753             i = (
    754             DMAC_CHAN_FLOW_P_P2M //DMAC_CHAN_FLOW_D_P2M//DMAC_CHAN_FLOW_D_M2P //DMAC_CHAN_FLOW_D_M2M 
    755             | (DMAC_DEST_PERIP (0))|(DMAC_SRC_PERIP(DMA_PERID_SSP0_RX))//Memory
    756             | DMAC_CHAN_ENABLE 
    757             //| DMAC_CHAN_ITC | DMAC_CHAN_IE
    758               );
    759             
    760             
    761             ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].config_ch = i;
    762             ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].dest_addr = (unsigned long)&spi1_rxbuff[0];
    763             
    764             IdxChnl = 6;
    765             //Clear any pending Interrupts on the channel
    766             ((DMAC_REGS_T*)pv)->int_tc_clear  = (1<<IdxChnl);//Must Later Selector allocate channel
    767             ((DMAC_REGS_T*)pv)->int_err_clear = (1<<IdxChnl);
    768             ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].src_addr  = (unsigned long)&spi1_txbuff[0];
    769             ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].dest_addr = 0x20084008;//Now SSP Reg for Down Load Data
    770             ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].lli       = 0;
    771             
    772          	i = (DMAC_CHAN_INT_TC_EN 
    773          	//| DMAC_CHAN_DEST_AUTOINC |
    774                  | DMAC_CHAN_SRC_AUTOINC | DMAC_CHAN_DEST_AHB1 
    775                  | DMAC_CHAN_SRC_AHB1 |DMAC_CHAN_DEST_WIDTH_16 //DMAC_CHAN_DEST_WIDTH_32 |
    776                  | DMAC_CHAN_SRC_WIDTH_16 | DMAC_CHAN_DEST_BURST_4 //|DMAC_CHAN_SRC_WIDTH_32  
    777                  | DMAC_CHAN_SRC_BURST_4 //|
    778                  | (DMAC_CHAN_TRANSFER_SIZE(usTransferSize)));   
    779             
    780             ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].control   = i;
    781             i = (
    782             DMAC_CHAN_FLOW_D_M2P //DMAC_CHAN_FLOW_D_M2M 
    783             | (DMAC_DEST_PERIP (DMA_PERID_SSP0_TX))|(DMAC_SRC_PERIP(0))//Memory
    784             | DMAC_CHAN_ENABLE 
    785             //| DMAC_CHAN_ITC | DMAC_CHAN_IE
    786               );
    787             
    788             
    789             ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].config_ch = i;
    790             
    791             
    792             //((DMAC_REGS_T*)pv)->dma_chan[6].
    793             
    794             //DMAC_CHAN_T*
    795           //Activate Dma
    796          //Init Transmit Point
    797          
    798          
    799          	return 0;
    800          
    801          }
    802          #define IDX_DMA_SSP0_MOSI 1
    803          #define IDX_DMA_SSP0_MISO 0
    804          
    805          
    806          DMAC_CHAN_T dma_mosi = {
    807          (unsigned long)&spi1_txbuff[0],//src_addr;
    808          0x20084008                    ,//dest_addr;
    809                                       0,//lli;
    810          (DMAC_CHAN_INT_TC_EN)            //control;
    811          |( DMAC_CHAN_SRC_AUTOINC) //| DMAC_CHAN_DEST_AHB1 
    812           |(DMAC_CHAN_DEST_WIDTH_16)//| DMAC_CHAN_SRC_AHB1
    813          | (DMAC_CHAN_SRC_WIDTH_16) | (DMAC_CHAN_DEST_BURST_1)		
    814          | (DMAC_CHAN_SRC_BURST_1)	
    815          | (DMAC_CHAN_TRANSFER_SIZE(0x20)),//usTransferSize
    816          
    817          DMAC_CHAN_ITC				   
    818          |DMAC_CHAN_FLOW_D_M2P               //config_ch;
    819          | (DMAC_DEST_PERIP (DMA_PERID_SSP0_TX))
    820          |(DMAC_SRC_PERIP(0))//Memory							   
    821          | DMAC_CHAN_ENABLE	,						   
    822          0,0,0 //reserved [3];
    823          };
    824          
    825          DMAC_CHAN_T dma_miso = {
    826          0x20084008                    ,//src_addr;
    827          (unsigned long)&spi1_rxbuff[0],//dest_addr;
    828                                       0,//lli;
    829          							 
    830          DMAC_CHAN_INT_TC_EN            //control;
    831          | (DMAC_CHAN_DEST_AUTOINC)
    832          // | DMAC_CHAN_DEST_AHB1
    833           |(DMAC_CHAN_DEST_WIDTH_16)//| DMAC_CHAN_SRC_AHB1
    834          | (DMAC_CHAN_SRC_WIDTH_16) | (DMAC_CHAN_DEST_BURST_1)
    835          | (DMAC_CHAN_SRC_BURST_1)
    836          | (DMAC_CHAN_TRANSFER_SIZE(0x20)), //usTransferSize
    837          
    838          DMAC_CHAN_ITC | DMAC_CHAN_FLOW_D_P2M//DMAC_CHAN_FLOW_P_P2M 
    839          | (DMAC_DEST_PERIP (0))|(DMAC_SRC_PERIP(DMA_PERID_SSP0_RX))//Memory
    840          //|DMAC_CHAN_HALT//| DMAC_CHAN_ENABLE
    841          //|DMAC_CHAN_LOCK 
    842          //0,0,0 //reserved [3];
    843          };
    844          DMAC_CHAN_T dma_clr = {
    845          0,
    846          0,
    847          0,
    848          0,
    849          0
    850          
    851          
    852          };
    853          /*
    854          DMAC_CHAN_T dma_mosi = {
    855          (unsigned long)&spi1_txbuff[0],//src_addr;
    856          0x20084008                    ,//dest_addr;
    857                                       0,//lli;
    858          //DMAC_CHAN_INT_TC_EN            //control;
    859          | DMAC_CHAN_SRC_AUTOINC //| DMAC_CHAN_DEST_AHB1 
    860           |DMAC_CHAN_DEST_WIDTH_16//| DMAC_CHAN_SRC_AHB1
    861          | DMAC_CHAN_SRC_WIDTH_16 | DMAC_CHAN_DEST_BURST_1		
    862          | DMAC_CHAN_SRC_BURST_1	
    863          | (DMAC_CHAN_TRANSFER_SIZE(0x100)),//usTransferSize
    864          
    865          				   
    866          DMAC_CHAN_FLOW_D_M2P               //config_ch;
    867          | (DMAC_DEST_PERIP (DMA_PERID_SSP0_TX))
    868          |(DMAC_SRC_PERIP(0))//Memory							   
    869          | DMAC_CHAN_ENABLE	,						   
    870          0,0,0 //reserved [3];
    871          };
    872          
    873          DMAC_CHAN_T dma_miso = {
    874          0x20084008                    ,//src_addr;
    875          (unsigned long)&spi1_rxbuff[0],//dest_addr;
    876                                       0,//lli;
    877          							 
    878          0//DMAC_CHAN_INT_TC_EN            //control;
    879          | DMAC_CHAN_DEST_AUTOINC
    880          // | DMAC_CHAN_DEST_AHB1
    881           |DMAC_CHAN_DEST_WIDTH_16//| DMAC_CHAN_SRC_AHB1
    882          | DMAC_CHAN_SRC_WIDTH_16 | DMAC_CHAN_DEST_BURST_1
    883          | DMAC_CHAN_SRC_BURST_1
    884          | (DMAC_CHAN_TRANSFER_SIZE(0x100)), //usTransferSize
    885          
    886           DMAC_CHAN_FLOW_D_P2M//DMAC_CHAN_FLOW_P_P2M 
    887          | (DMAC_DEST_PERIP (0))|(DMAC_SRC_PERIP(DMA_PERID_SSP0_RX))//Memory
    888          |DMAC_CHAN_HALT//| DMAC_CHAN_ENABLE
    889          |DMAC_CHAN_LOCK 
    890          };
    891          */
    892          //@ "Fast_function_no_cache"
    893          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    894          //---   
    895          long SetUp_Dma_Chanel(long IdxChnl,void *pInitData )   @ "Fast_function_no_cache";
    896          //..................................................................................
    897          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    898          //~~~ Purpose: Read some data from the terminal interface                        ~~~
    899          //~~~ Processing: Move data from the ring buffer to the passed buffer            ~~~
    900          //~~~        ~~~
    901          //~~~        ~~~
    902          //~~~        ~~~
    903          //``````````````````````````````````````````````````````````````````````````````````
    904          //~~~ Returns: Number of bytes actually read                                      ~~
    905          //~~~                                                                             ~~ 
    906          //~~~                                                                             ~~
    907          //~~~          ~~
    908          //~~~          ~~
    909          //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
    910          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    911          //=================================================================================
    912          //Body func                                                                  
    913          //=================================================================================
    914          
    915          long SetUp_Dma_Chanel(long IdxChnl, void *pInitData )   @ "Fast_function_no_cache"
    916          {
    917          //register long i;
    918          register void *pv;
    919          //Detect Source
    920          pv = (void*)Dma_get_base();
    921          //Clear any pending Interrupts on the channel
    922          ((DMAC_REGS_T*)pv)->int_tc_clear  = (1<<IdxChnl);//Must Later Selector allocate channel
    923          ((DMAC_REGS_T*)pv)->int_err_clear = (1<<IdxChnl);
    924          
    925          ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].src_addr  =
    926          ((DMAC_CHAN_T*)pInitData)-> src_addr;
    927          ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].dest_addr =
    928          ((DMAC_CHAN_T*)pInitData)-> dest_addr;
    929          ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].lli       =
    930          ((DMAC_CHAN_T*)pInitData)-> lli;
    931          ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].control   = 
    932          ((DMAC_CHAN_T*)pInitData)-> control;
    933          ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].config_ch = 
    934          ((DMAC_CHAN_T*)pInitData)-> config_ch;
    935          
    936          return ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].config_ch;
    937          }
    938          //---------------------------------------------------------------------------------
    939          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    940          //---   
    941          void Dma_Int_cb_ssp0(void)   @ "Fast_function";
    942          //..................................................................................
    943          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    944          //~~~ Purpose: Read some data from the terminal interface                        ~~~
    945          //~~~ Processing: Move data from the ring buffer to the passed buffer            ~~~
    946          //~~~        ~~~
    947          //~~~        ~~~
    948          //~~~        ~~~
    949          //``````````````````````````````````````````````````````````````````````````````````
    950          //~~~ Returns: Number of bytes actually read                                      ~~
    951          //~~~                                                                             ~~ 
    952          //~~~                                                                             ~~
    953          //~~~          ~~
    954          //~~~          ~~
    955          //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
    956          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    957          //=================================================================================
    958          //Body func                                                                  
    959          //=================================================================================
    960          
    961          void Dma_Int_cb_ssp0(void)   @ "Fast_function"
    962          {
    963          //Detect Source
    964          
    965          
    966          }
    967          //---------------------------------------------------------------------------------
    968          
    969          
    970          
    971          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    972          //---   
    973          void Tci_recv_cb_ssp0(void)   @ "Fast_function_no_cache";
    974          //..................................................................................
    975          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    976          //~~~ Purpose: Read some data from the terminal interface                        ~~~
    977          //~~~ Processing: Move data from the ring buffer to the passed buffer            ~~~
    978          //~~~        ~~~
    979          //~~~        ~~~
    980          //~~~        ~~~
    981          //``````````````````````````````````````````````````````````````````````````````````
    982          //~~~ Returns: Number of bytes actually read                                      ~~
    983          //~~~                                                                             ~~ 
    984          //~~~                                                                             ~~
    985          //~~~          ~~
    986          //~~~          ~~
    987          //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
    988          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    989          //=================================================================================
    990          //Body func                                                                  
    991          //=================================================================================
    992          
    993          void Tci_recv_cb_ssp0(void)   @ "Fast_function_no_cache"
    994          {
    995          long bread;
    996          register void *pv;
    997          
    998             pv = (void*)Dma_get_base();
    999          if( (((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].dest_addr == 0)
   1000          && (((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].src_addr == 0)
   1001            )
   1002            return;
   1003            bread = ((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].dest_addr
   1004            - dma_miso.dest_addr;
   1005             bread += 2;
   1006            if (bread>= 0x200)
   1007           {
   1008          	 bread = 0x200;//?? Error control
   1009          	 //chEntry_Ssp0++;
   1010           }
   1011            spi1_rxsize = spi1_rxsize + bread;
   1012            spi1_rxfill = spi1_rxfill + bread;
   1013            if (spi1_rxfill >= SIZE_SPI_BUF)
   1014            {
   1015              //spi1_rxfill = 0;//Error ??? <- This code won`t be properly worked 
   1016          	//as we don`t control Each word for reception
   1017          	spi1_rxfill -= SIZE_SPI_BUF;//Only for general methodics/.
   1018            }
   1019            
   1020             if ((spi1_rxsize == 512) &&(spi1_rxfill==spi1_rxsize) )//SIZE_LPDU_CNL_SPI
   1021             {
   1022          	chEntry_Ssp0++;if(chEntry_Ssp0>2) for(;;);
   1023          	//Try Reinit Dma chanell?
   1024          	
   1025          	}
   1026          	SetUp_Dma_Chanel(IDX_DMA_SSP0_MISO,(void*)&dma_clr);
   1027            //Disable Channel
   1028            //(((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].config_ch) = 0;//???
   1029            *((long*)0x20084024)  &= 2;
   1030            GPIO->p3_outp_clr = (1<<23);// GPIO->p3_outp_set  = (1<<23);
   1031            GPIO->p3_outp_set = ((1<<7));
   1032          }
   1033          //---------------------------------------------------------------------------------
   1034          
   1035          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1036          //---   
   1037          void Tci_send_cb_ssp0(void)   @ "Fast_function_no_cache";
   1038          //..................................................................................
   1039          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1040          //~~~ Purpose: Read some data from the terminal interface                        ~~~
   1041          //~~~ Processing: Move data from the ring buffer to the passed buffer            ~~~
   1042          //~~~        ~~~
   1043          //~~~        ~~~
   1044          //~~~        ~~~
   1045          //``````````````````````````````````````````````````````````````````````````````````
   1046          //~~~ Returns: Number of bytes actually read                                      ~~
   1047          //~~~                                                                             ~~ 
   1048          //~~~                                                                             ~~
   1049          //~~~          ~~
   1050          //~~~          ~~
   1051          //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
   1052          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1053          //=================================================================================
   1054          //Body func                                                                  
   1055          //=================================================================================
   1056          
   1057          void Tci_send_cb_ssp0(void)   @ "Fast_function_no_cache"
   1058          {
   1059           register long bwrite; 
   1060           register void *pv;
   1061          //Detect Source
   1062          pv = (void*)Dma_get_base();
   1063           bwrite = (((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MOSI].src_addr);
   1064           if ((bwrite==0)&&((((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MOSI].dest_addr)==0) )
   1065           return;
   1066           bwrite -= dma_mosi.src_addr;
   1067           bwrite += 2;//Additiona Stop addr
   1068           if (bwrite>= 0x200)
   1069           {
   1070          	 bwrite = 0x200;//?? Error control
   1071          	 chEntry_Ssp0++;if(chEntry_Ssp0>2) for(;;);
   1072           }
   1073            //Data already moved
   1074            spi1_txsize = spi1_txsize - bwrite;
   1075            
   1076            spi1_txget = spi1_txget + bwrite;
   1077            
   1078            if (spi1_txget >= SIZE_SPI_BUF)
   1079            {
   1080              spi1_txget = 0;
   1081            }
   1082            SetUp_Dma_Chanel(IDX_DMA_SSP0_MOSI,(void*)&dma_clr);
   1083            //Disable Channel
   1084            //(((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MOSI].config_ch) = 0;
   1085            ////Clear Int
   1086            //((DMAC_REGS_T*)pv)->int_tc_clear  = (1<<IDX_DMA_SSP0_MOSI);
   1087            //((DMAC_REGS_T*)pv)->int_err_clear = (1<<IDX_DMA_SSP0_MOSI);
   1088          //  chEntry_Ssp0++;
   1089            *((long*)0x20084024)  &= 1;
   1090          }
   1091          //---------------------------------------------------------------------------------
   1092          extern unsigned long ulCtrTrLpduSpi ;
   1093          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1094          //---   
   1095          __arm long OutSPIDma(UNS_8 *dat, int bytes)   @ "Fast_function_no_cache";
   1096          //..................................................................................
   1097          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1098          //~~~ Purpose: Read some data from the terminal interface                        ~~~
   1099          //~~~ Processing: Move data from the ring buffer to the passed buffer            ~~~
   1100          //~~~        ~~~
   1101          //~~~        ~~~
   1102          //~~~        ~~~
   1103          //``````````````````````````````````````````````````````````````````````````````````
   1104          //~~~ Returns: Number of bytes actually read                                      ~~
   1105          //~~~                                                                             ~~ 
   1106          //~~~                                                                             ~~
   1107          //~~~          ~~
   1108          //~~~          ~~
   1109          //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
   1110          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1111          //=================================================================================
   1112          //Body func                                                                  
   1113          //=================================================================================
   1114          #include    "lpu.h"
   1115          __arm long OutSPIDma(UNS_8 *dat, int bytes)   @ "Fast_function_no_cache"
   1116          {
   1117          
   1118          register long bsend; 
   1119          register void *pv;
   1120          
   1121          //Detect If Bs Rdy
   1122          	if( (GPIO->p3_inp_state) & (1<<16)) 
   1123          	;
   1124          	else
   1125          #ifdef _STATIC_MEMORY_BOOT 	
   1126          	;//
   1127          #else
   1128          	//return 0;//<-Debug Code for control busy state If Pio Hdw Interface Worked
   1129          #endif
   1130          	 GPIO->p3_outp_set  = (1<<23);
   1131          
   1132          ProcessLLEvt();//Process Urgent Data
   1133          //Detect Source
   1134          pv = (void*)Dma_get_base();if(chEntry_Ssp0>0) for(;;);
   1135            disable_irq();
   1136            if ((spi1_txfill == spi1_txget)&&(spi1_txsize == 0))
   1137            spi1_txget = spi1_txfill = 0;//.!!!
   1138            if (bytes>SIZE_SPI_BUF)
   1139            bytes = SIZE_SPI_BUF;//correctness Control
   1140          //__disable_interrupt();
   1141          ulCtrTrLpduSpi++;
   1142          	 
   1143          
   1144          
   1145          	if (bytes+spi1_txfill>SIZE_SPI_BUF)
   1146          	bytes = SIZE_SPI_BUF- spi1_txfill;
   1147          	else
   1148          	bsend = bytes;
   1149          	
   1150          	//i = spi0_txsize + bytes;
   1151          	//if (i>= (SIZE_SPI_BUF))
   1152          	if ((spi1_txsize + bytes)>= (SIZE_SPI_BUF))
   1153          	bsend = SIZE_SPI_BUF - spi1_txsize;
   1154          	else
   1155          	bsend = bytes;
   1156          	
   1157          	memcpy(spi1_txbuff+spi1_txfill,dat,bsend);
   1158          //Data In Buf	
   1159          
   1160          	spi1_txsize += bsend; 
   1161          	//if (bsend)
   1162          
   1163          	spi1_txfill+= bsend;
   1164              if (spi1_txfill >= (SIZE_SPI_BUF))
   1165              {
   1166                spi1_txfill -= SIZE_SPI_BUF;
   1167              }
   1168          	//Detect If BS Ready Else Out
   1169          	
   1170          	
   1171          //	__enable_interrupt();
   1172          //clkpwr_clk_en_dis(CLKPWR_DMA_CLK, 1);
   1173             enable_irq();//int_enable(IRQ_UART_IIR2);
   1174             bsend >>= 1;//((DMAC_REGS_T*)pv)->config = 1;
   1175             	;//Set MISO dma chanell
   1176          	if( (((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].config_ch)&( DMAC_CHAN_ENABLE))
   1177          	{
   1178          		;//additional SetUP
   1179          	}	
   1180          	else
   1181          		bytes = SetUp_Dma_Chanel(IDX_DMA_SSP0_MISO,(void*)&dma_miso);//Initial PreInit
   1182          		
   1183          	(((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].config_ch) &= ~( DMAC_CHAN_ENABLE);
   1184          	((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].control &= ~0xfff;
   1185          	((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].control   |= 
   1186          	DMAC_CHAN_DEST_AHB1 |	DMAC_CHAN_TRANSFER_SIZE(bsend);
   1187          	
   1188          	(((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].config_ch) |= ( DMAC_CHAN_ENABLE);
   1189          	//((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].dest_addr = dma_miso.dest_addr;//Additional Change Pointer
   1190          	 
   1191          	;//Set MOSI dma chanell
   1192          	bytes = DMAC_CHAN_TRANSFER_SIZE(dma_mosi.control);
   1193          	dma_mosi.control  &= ~0xfff;
   1194          	dma_mosi.control |=  DMAC_CHAN_TRANSFER_SIZE(bsend);
   1195          	bsend = SetUp_Dma_Chanel(IDX_DMA_SSP0_MOSI,(void*)&dma_mosi); //Wait Interrupt 
   1196          	// GPIO->p3_outp_set  = (1<<23);// GPIO->p3_outp_clr = (1<<23);
   1197          	//GPIO->p3_outp_set  = ((1<<7));
   1198          	//Check If Message Receive
   1199          	//if( (GPIO->p3_inp_state) & (1<<16)  == 0) 
   1200          	//;//Ok State
   1201          	//else//Fix Error Syncro
   1202          	
   1203          	*((long*)0x20084024)  = 3;
   1204          	dma_mosi.control  &= ~0xfff;
   1205          	dma_mosi.control |=  DMAC_CHAN_TRANSFER_SIZE(bytes);
   1206          	
   1207           
   1208           
   1209           
   1210           
   1211           
   1212           
   1213           
   1214           
   1215           
   1216          return 	bsend;
   1217           
   1218           
   1219           
   1220           
   1221           
   1222           
   1223           
   1224           
   1225           
   1226           
   1227           
   1228          //,*((long*)0x20084024)  = 0;
   1229          //.(((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].config_ch) &= ~( DMAC_CHAN_ENABLE);
   1230          //,Tci_send_cb_ssp0();
   1231          //,Tci_recv_cb_ssp0();
   1232          //((DMAC_REGS_T*)pv)->config = 0; // clkpwr_clk_en_dis(CLKPWR_DMA_CLK, 0);
   1233           
   1234           
   1235           
   1236           
   1237           
   1238            
   1239          }
   1240          //---------------------------------------------------------------------------------
   1241          
   1242          
   1243          __arm long InSPIDma(UNS_8 *dat, int bytes)   @ "Fast_function"
   1244          {
   1245          int bread = 0;
   1246          register long i;
   1247          register void *pv;
   1248             
   1249             pv = (void*)Dma_get_base();
   1250             
   1251             if (bytes>spi1_rxsize)
   1252          	   bread = spi1_rxsize;
   1253          	else 
   1254          	bread = bytes;
   1255          	//spi1_rxget += 2;//For skip 1-st word in bug only
   1256            disable_irq();//	
   1257            memcpy(dat,spi1_rxbuff+spi1_rxget+0,bread);
   1258            	spi1_rxget += bytes;
   1259          	if (spi1_rxget >= (SIZE_SPI_BUF))
   1260              {
   1261                spi1_rxget -= SIZE_SPI_BUF;
   1262              }
   1263          	spi1_rxsize -= bread; 
   1264             enable_irq();//
   1265           if (spi1_rxfill == spi1_rxget)
   1266            {
   1267          
   1268          	 disable_irq();//__disable_interrupt();//..
   1269          	spi1_rxfill = spi1_rxget = 0;
   1270          
   1271          	enable_irq();//__enable_interrupt();
   1272            }
   1273          
   1274          	return 0;
   1275          
   1276          }
   1277          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1278          long DetectEndOfTransmitDmaSsp0(void)   @ "Fast_function";
   1279          //..................................................................................
   1280          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1281          //~~~ Purpose: Read some data from the terminal interface                        ~~~
   1282          //~~~ Processing: Move data from the ring buffer to the passed buffer            ~~~
   1283          //~~~        ~~~
   1284          //~~~        ~~~
   1285          //~~~        ~~~
   1286          //``````````````````````````````````````````````````````````````````````````````````
   1287          //~~~ Returns: Number of bytes actually read                                      ~~
   1288          //~~~                                                                             ~~ 
   1289          //~~~                                                                             ~~
   1290          //~~~          ~~
   1291          //~~~          ~~
   1292          //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
   1293          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1294          //=================================================================================
   1295          //Body func                                                                  
   1296          //=================================================================================
   1297          
   1298          long DetectEndOfTransmitDmaSsp0(void)   @ "Fast_function"
   1299          {
   1300           register long i;
   1301           register long IdxChnl;
   1302           register void *pv;
   1303           register long AmtSucces;   
   1304              IdxChnl = 6;AmtSucces = 0;
   1305           pv = (void*)Dma_get_base();
   1306           //Detect State Transmit Channel 
   1307           i = ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].config_ch;
   1308           if (i&DMAC_CHAN_ACTIVE )
   1309           {
   1310           	i = 0;
   1311           	return i ;
   1312           }
   1313           //Detect Size of Transmittion
   1314           i = ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].src_addr;
   1315           i -=(unsigned long)&spi1_txbuff[0];
   1316           //Detect Amount transfer Byte
   1317           if (i>= 0x1fe)
   1318           {
   1319           	AmtSucces++;
   1320          	//Stop Channel
   1321          	((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].config_ch = 0;
   1322           }
   1323           IdxChnl = 7;
   1324           //Detect State Receive Channel
   1325           i = ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].config_ch;
   1326           
   1327           //Detect Amount Recive Byte
   1328           i = ((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].dest_addr;
   1329           i -=(unsigned long)&spi1_rxbuff[0];
   1330           //Detect Amount transfer Byte
   1331           if (i>= 0x1fe)
   1332           {
   1333              AmtSucces++;
   1334          	//Stop Channel
   1335          	((DMAC_REGS_T*)pv)->dma_chan[IdxChnl].config_ch = 0;
   1336           }
   1337           	if(AmtSucces>=2)
   1338           	{
   1339           		chEntry_Ssp0 = 2;//++;
   1340           		return AmtSucces;
   1341           	}
   1342           return AmtSucces;
   1343          }
   1344          //---------------------------------------------------------------------------------
   1345          
   1346          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1347          //---   
   1348          void Dma_recv_stub_ssp0(void)   @ "Fast_function";
   1349          //..................................................................................
   1350          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1351          //~~~ Purpose: Read some data from the terminal interface                        ~~~
   1352          //~~~ Processing: Move data from the ring buffer to the passed buffer            ~~~
   1353          //~~~        ~~~
   1354          //~~~        ~~~
   1355          //~~~        ~~~
   1356          //``````````````````````````````````````````````````````````````````````````````````
   1357          //~~~ Returns: Number of bytes actually read                                      ~~
   1358          //~~~                                                                             ~~ 
   1359          //~~~                                                                             ~~
   1360          //~~~          ~~
   1361          //~~~          ~~
   1362          //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
   1363          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1364          //=================================================================================
   1365          //Body func                                                                  
   1366          //=================================================================================
   1367          
   1368          void Dma_recv_stub_ssp0(void)   @ "Fast_function"
   1369          {
   1370          long bread;
   1371          register void *pv;
   1372            //SSP_REGS_T *psspregs = (SSP_REGS_T *) SSP0;
   1373             pv = (void*)Dma_get_base();
   1374            //.bread = Ssp_read(sspdev0,&spi1_rxbuff[spi1_rxfill], toreadmax);
   1375            //.bread <<= 1;
   1376            
   1377            bread = ((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].dest_addr
   1378            - dma_miso.dest_addr;
   1379             bread += 2;
   1380            if (bread>= 0x200)
   1381           {
   1382          	 bread = 0x200;//?? Error control
   1383          	 //chEntry_Ssp0++;
   1384           }
   1385            spi1_rxsize = spi1_rxsize + bread;
   1386            spi1_rxfill = spi1_rxfill + bread;
   1387            if (spi1_rxfill >= SIZE_SPI_BUF)
   1388            {
   1389              //spi1_rxfill = 0;//Error ??? <- This code won`t be properly worked 
   1390          	//as we don`t control Each word for reception
   1391          	spi1_rxfill -= SIZE_SPI_BUF;//Only for general methodics/.
   1392            }
   1393            
   1394             if ((spi1_rxsize == 512) &&(spi1_rxfill==spi1_rxsize) )//SIZE_LPDU_CNL_SPI
   1395             {
   1396          	chEntry_Ssp0++;
   1397          	//Try Reinit Dma chanell?
   1398          	
   1399          	}
   1400          	SetUp_Dma_Chanel(IDX_DMA_SSP0_MISO,(void*)&dma_clr);
   1401            //Disable Channel
   1402            //(((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].config_ch) = 0;//???
   1403          
   1404          }
   1405          //---------------------------------------------------------------------------------
   1406          
   1407          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1408          //---   
   1409          void Dma_send_stub_ssp0(void)   @ "Fast_function";
   1410          //..................................................................................
   1411          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1412          //~~~ Purpose: Read some data from the terminal interface                        ~~~
   1413          //~~~ Processing: Move data from the ring buffer to the passed buffer            ~~~
   1414          //~~~        ~~~
   1415          //~~~        ~~~
   1416          //~~~        ~~~
   1417          //``````````````````````````````````````````````````````````````````````````````````
   1418          //~~~ Returns: Number of bytes actually read                                      ~~
   1419          //~~~                                                                             ~~ 
   1420          //~~~                                                                             ~~
   1421          //~~~          ~~
   1422          //~~~          ~~
   1423          //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
   1424          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1425          //=================================================================================
   1426          //Body func                                                                  
   1427          //=================================================================================
   1428          
   1429          void Dma_send_stub_ssp0(void)   @ "Fast_function"
   1430          {
   1431           register long bwrite; 
   1432           register void *pv;
   1433          //Detect Source
   1434          pv = (void*)Dma_get_base();
   1435           bwrite = (((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MOSI].src_addr);
   1436           bwrite -= dma_mosi.src_addr;
   1437           bwrite += 2;//Additiona Stop addr
   1438           if (bwrite>= 0x200)
   1439           {
   1440          	 bwrite = 0x200;//?? Error control
   1441          	 chEntry_Ssp0++;
   1442           }
   1443            //Data already moved
   1444            spi1_txsize = spi1_txsize - bwrite;
   1445            
   1446            spi1_txget = spi1_txget + bwrite;
   1447            
   1448            if (spi1_txget >= SIZE_SPI_BUF)
   1449            {
   1450              spi1_txget = 0;
   1451            }
   1452            SetUp_Dma_Chanel(IDX_DMA_SSP0_MOSI,(void*)&dma_clr);
   1453            //Disable Channel
   1454            //(((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MOSI].config_ch) = 0;
   1455            ////Clear Int
   1456            //((DMAC_REGS_T*)pv)->int_tc_clear  = (1<<IDX_DMA_SSP0_MOSI);
   1457            //((DMAC_REGS_T*)pv)->int_err_clear = (1<<IDX_DMA_SSP0_MOSI);
   1458          //  chEntry_Ssp0++;
   1459            
   1460          }
   1461          //---------------------------------------------------------------------------------
   1462          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1463          //---   
   1464          __arm long OutSPIDmaDbg(UNS_8 *dat, int bytes)   @ "Fast_function";
   1465          //..................................................................................
   1466          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1467          //~~~ Purpose: Read some data from the terminal interface                        ~~~
   1468          //~~~ Processing: Move data from the ring buffer to the passed buffer            ~~~
   1469          //~~~        ~~~
   1470          //~~~        ~~~
   1471          //~~~        ~~~
   1472          //``````````````````````````````````````````````````````````````````````````````````
   1473          //~~~ Returns: Number of bytes actually read                                      ~~
   1474          //~~~                                                                             ~~ 
   1475          //~~~                                                                             ~~
   1476          //~~~          ~~
   1477          //~~~          ~~
   1478          //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
   1479          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1480          //=================================================================================
   1481          //Body func                                                                  
   1482          //=================================================================================
   1483          #include    "lpu.h"
   1484          __arm long OutSPIDmaDbg(UNS_8 *dat, int bytes)   @ "Fast_function"
   1485          {
   1486          
   1487          register long bsend; 
   1488          register void *pv;
   1489          //Detect Source
   1490          pv = (void*)Dma_get_base();
   1491            disable_irq();
   1492            if ((spi1_txfill == spi1_txget)&&(spi1_txsize == 0))
   1493            spi1_txget = spi1_txfill = 0;//.!!!
   1494            if (bytes>SIZE_SPI_BUF)
   1495            bytes = SIZE_SPI_BUF;//correctness Control
   1496          //__disable_interrupt();
   1497          
   1498          	if (bytes+spi1_txfill>SIZE_SPI_BUF)
   1499          	bytes = SIZE_SPI_BUF- spi1_txfill;
   1500          	else
   1501          	bsend = bytes;
   1502          	
   1503          	//i = spi0_txsize + bytes;
   1504          	//if (i>= (SIZE_SPI_BUF))
   1505          	if ((spi1_txsize + bytes)>= (SIZE_SPI_BUF))
   1506          	bsend = SIZE_SPI_BUF - spi1_txsize;
   1507          	else
   1508          	bsend = bytes;
   1509          	
   1510          	memcpy(spi1_txbuff+spi1_txfill,dat,bsend);
   1511          //Data In Buf	
   1512          
   1513          	spi1_txsize += bsend; 
   1514          	//if (bsend)
   1515          
   1516          	spi1_txfill+= bsend;
   1517              if (spi1_txfill >= (SIZE_SPI_BUF))
   1518              {
   1519                spi1_txfill -= SIZE_SPI_BUF;
   1520              }
   1521          //	__enable_interrupt();
   1522          clkpwr_clk_en_dis(CLKPWR_DMA_CLK, 1);
   1523             enable_irq();//int_enable(IRQ_UART_IIR2);
   1524             bsend >>= 1;((DMAC_REGS_T*)pv)->config = 1;
   1525             	;//Set MISO dma chanell
   1526          	if( (((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].config_ch)&( DMAC_CHAN_ENABLE))
   1527          	{
   1528          		;//additional SetUP
   1529          	}	
   1530          	else
   1531          		bytes = SetUp_Dma_Chanel(IDX_DMA_SSP0_MISO,(void*)&dma_miso);//Initial PreInit
   1532          		
   1533          	(((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].config_ch) &= ~( DMAC_CHAN_ENABLE);
   1534          	((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].control &= ~0xfff;
   1535          	((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].control   |= 
   1536          	DMAC_CHAN_DEST_AHB1 |	DMAC_CHAN_TRANSFER_SIZE(bsend);
   1537          	
   1538          	(((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].config_ch) |= ( DMAC_CHAN_ENABLE);
   1539          	//((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].dest_addr = dma_miso.dest_addr;//Additional Change Pointer
   1540          	 
   1541          	;//Set MOSI dma chanell
   1542          	bytes = DMAC_CHAN_TRANSFER_SIZE(dma_mosi.control);
   1543          	dma_mosi.control  &= ~0xfff;
   1544          	dma_mosi.control |=  DMAC_CHAN_TRANSFER_SIZE(bsend);
   1545          	bsend = SetUp_Dma_Chanel(IDX_DMA_SSP0_MOSI,(void*)&dma_mosi); //Wait Interrupt 
   1546          	*((long*)0x20084024)  = 3;
   1547          	dma_mosi.control  &= ~0xfff;
   1548          	dma_mosi.control |=  DMAC_CHAN_TRANSFER_SIZE(bytes);
   1549          //	while(
   1550          //	(((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].config_ch)&(DMAC_CHAN_ACTIVE)
   1551          //	);
   1552          	/*
   1553          	bytes = SetUp_Dma_Chanel(IDX_DMA_SSP0_MOSI,(void*)&dma_mosi); //Wait Interrupt  
   1554          	((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].dest_addr = dma_miso.dest_addr;
   1555          	bytes = SetUp_Dma_Chanel(IDX_DMA_SSP0_MOSI,(void*)&dma_mosi); //Wait Interrupt 
   1556          ((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].dest_addr = dma_miso.dest_addr;	
   1557          	bytes = SetUp_Dma_Chanel(IDX_DMA_SSP0_MOSI,(void*)&dma_mosi); //Wait Interrupt  
   1558          	((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].dest_addr = dma_miso.dest_addr;
   1559          	bytes = SetUp_Dma_Chanel(IDX_DMA_SSP0_MOSI,(void*)&dma_mosi); //Wait Interrupt  
   1560          	((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].dest_addr = dma_miso.dest_addr;
   1561          	*/
   1562          	//Wait&Clear Bits
   1563          	//(((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].config_ch) &= ~( DMAC_CHAN_ENABLE);
   1564          //    spi1_txsize -= bsend;//spi0_txsize = spi0_txsize - bwrite;
   1565          //    spi1_txget  +=  bsend;//spi0_txget  =  spi0_txget + bwrite;
   1566          //  if ( spi1_txget >= (SIZE_SPI_BUF)) DMA
   1567          //  {
   1568          //     spi1_txget = 0;
   1569          //  }
   1570          *((long*)0x20084024)  = 0;
   1571          (((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].config_ch) &= ~( DMAC_CHAN_ENABLE);
   1572          Dma_send_stub_ssp0();
   1573          Dma_recv_stub_ssp0();
   1574          ((DMAC_REGS_T*)pv)->config = 0;  clkpwr_clk_en_dis(CLKPWR_DMA_CLK, 0);
   1575          //(((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].config_ch) = 0;
   1576          //((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MISO].control     = 0;
   1577          //(((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MOSI].config_ch) = 0;
   1578          //((DMAC_REGS_T*)pv)->dma_chan[IDX_DMA_SSP0_MOSI].control     = 0;
   1579          //inSPI1((unsigned char*)&hldrSpiLpduUnit.arUch[0],1);
   1580            
   1581          }
   1582          //---------------------------------------------------------------------------------
   1583          long Ssp_Syncro4(void) @ "Fast_function_no_cache"
   1584          {
   1585          	lInitStateCnl = 4;//
   1586          	lSpiAccessCtrl = 4;
   1587          	lSsp0HdwState |= 4;
   1588          	
   1589          	Int_enable1(IRQ_SSP0);//for(;;);
   1590          	
   1591          	return 0;
   1592          
   1593          }
   1594          /*
   1595          1 ,51 ,101,151 ,201 ,251,301 ,351 ,401 ,451 501
   1596          2 ,52 ,102,152 ,202 ,252,302 ,352 ,402 ,452 502
   1597          3 ,53 ,103,153 ,203 ,253,303 ,353 ,403 ,453 503
   1598          4 ,54 ,104,154 ,204 ,254,304 ,354 ,404 ,454 504
   1599          5 ,55 ,105,155 ,205 ,255,305 ,355 ,405 ,455 505
   1600          6 ,56 ,106,156 ,206 ,256,306 ,356 ,406 ,456 506
   1601          7 ,57 ,107,157 ,207 ,257,307 ,357 ,407 ,457 507
   1602          8 ,58 ,108,158 ,208 ,258,308 ,358 ,408 ,458 508
   1603          9 ,59 ,109,159 ,209 ,259,309 ,359 ,409 ,459 509
   1604          10,60 ,110,160 ,210 ,260,310 ,360 ,410 ,460 510
   1605          11,61 ,111,161 ,211 ,261,311 ,361 ,411 ,461 511
   1606          12,62 ,112,162 ,212 ,262,312 ,362 ,412 ,462 512
   1607          13,63 ,113,163 ,213 ,263,313 ,363 ,413 ,463 513
   1608          14,64 ,114,164 ,214 ,264,314 ,364 ,414 ,464 514
   1609          15,65 ,115,165 ,215 ,265,315 ,365 ,415 ,465 515
   1610          16,66 ,116,166 ,216 ,266,316 ,366 ,416 ,466 516
   1611          17,67 ,117,167 ,217 ,267,317 ,367 ,417 ,467 517
   1612          18,68 ,118,168 ,218 ,268,318 ,368 ,418 ,468 518
   1613          19,69 ,119,169 ,219 ,269,319 ,369 ,419 ,469 519
   1614          20,70 ,120,170 ,220 ,270,320 ,370 ,420 ,470 520
   1615          21,71 ,121,171 ,221 ,271,321 ,371 ,421 ,471 521
   1616          22,72 ,122,172 ,222 ,272,322 ,372 ,422 ,472 522
   1617          23,73 ,123,173 ,223 ,273,323 ,373 ,423 ,473 523
   1618          24,74 ,124,174 ,224 ,274,324 ,374 ,424 ,474 524
   1619          25,75 ,125,175 ,225 ,275,325 ,375 ,425 ,475 525
   1620          26,76 ,126,176 ,226 ,276,326 ,376 ,426 ,476 526
   1621          27,77 ,127,177 ,227 ,277,327 ,377 ,427 ,477 527
   1622          28,78 ,128,178 ,228 ,278,328 ,378 ,428 ,478 528
   1623          29,79 ,129,179 ,229 ,279,329 ,379 ,429 ,479 529
   1624          30,80 ,130,180 ,230 ,280,330 ,380 ,430 ,480 530
   1625          31,81 ,131,181 ,231 ,281,331 ,381 ,431 ,481 531
   1626          32,82 ,132,182 ,232 ,282,332 ,382 ,432 ,482 532
   1627          33,83 ,133,183 ,233 ,283,333 ,383 ,433 ,483 533
   1628          34,84 ,134,184 ,234 ,284,334 ,384 ,434 ,484 534
   1629          35,85 ,135,185 ,235 ,285,335 ,385 ,435 ,485 535
   1630          36,86 ,136,186 ,236 ,286,336 ,386 ,436 ,486 536
   1631          37,87 ,137,187 ,237 ,287,337 ,387 ,437 ,487 537
   1632          38,88 ,138,188 ,238 ,288,338 ,388 ,438 ,488 538
   1633          39,89 ,139,189 ,239 ,289,339 ,389 ,439 ,489 539
   1634          40,90 ,140,190 ,240 ,290,340 ,390 ,440 ,490 540
   1635          41,91 ,141,191 ,241 ,291,341 ,391 ,441 ,491 541
   1636          42,92 ,142,192 ,242 ,292,342 ,392 ,442 ,492 542
   1637          43,93 ,143,193 ,243 ,293,343 ,393 ,443 ,493 543
   1638          44,94 ,144,194 ,244 ,294,344 ,394 ,444 ,494 544
   1639          45,95 ,145,195 ,245 ,295,345 ,395 ,445 ,495 545
   1640          46,96 ,146,196 ,246 ,296,346 ,396 ,446 ,496 546
   1641          47,97 ,147,197 ,247 ,297,347 ,397 ,447 ,497 547
   1642          48,98 ,148,198 ,248 ,298,348 ,398 ,448 ,498 548
   1643          49,99 ,149,199 ,249 ,299,349 ,399 ,449 ,499 549
   1644          50,100,150,200 ,250 ,300,350 ,400 ,450 ,500 550
   1645          								  
   1646          
   1647          */
   1648          
   1649          
   1650          
   1651          /* EOF */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   DetectEndOfTransmitDmaSsp0
        24   -> Dma_get_base
       0   Dma_Int_cb_ssp0
      16   Dma_recv_stub_ssp0
        16   -> Dma_get_base
        16   -> SetUp_Dma_Chanel
      16   Dma_send_stub_ssp0
        16   -> Dma_get_base
        16   -> SetUp_Dma_Chanel
      24   InSPIDma
        24   -> Dma_get_base
        24   -> __aeabi_memcpy
        24   -> disable_irq
        24   -> enable_irq
      24   OutSPIDma
        24   -> Dma_get_base
        24   -> ProcessLLEvt
        24   -> SetUp_Dma_Chanel
        24   -> __aeabi_memcpy
        24   -> disable_irq
        24   -> enable_irq
      24   OutSPIDmaDbg
        24   -> Dma_get_base
        24   -> Dma_recv_stub_ssp0
        24   -> Dma_send_stub_ssp0
        24   -> SetUp_Dma_Chanel
        24   -> __aeabi_memcpy
        24   -> clkpwr_clk_en_dis
        24   -> disable_irq
        24   -> enable_irq
      16   SetUp_Dma_Chanel
        16   -> Dma_get_base
       8   Spi0_Rst
         8   -> Int_disable1
       8   Ssp_Syncro
      24   Ssp_Syncro1
        24   -> Int_enable1
      32   Ssp_Syncro2
        32   -> Int_enable1
      32   Ssp_Syncro3
        32   -> Int_enable1
       8   Ssp_Syncro4
         8   -> Int_enable1
      16   Tci_recv_cb_ssp0
        16   -> Dma_get_base
        16   -> SetUp_Dma_Chanel
      16   Tci_send_cb_ssp0
        16   -> Dma_get_base
        16   -> SetUp_Dma_Chanel
       0   disable_irq
       0   enable_irq
      16   inSPI1
        16   -> disable_irq
        16   -> enable_irq
      16   outSPI1
        16   -> disable_irq
        16   -> enable_irq
        16   -> send_cb_spi1
      32   outSPIDma
        32   -> Dma_get_base
        32   -> disable_irq
        32   -> enable_irq
      16   recv_cb_spi1
        16   -> Ssp_read
      16   send_cb_spi1
        16   -> Ssp_write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_18
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       4  ??DataTable1_1
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable36_10
       4  ??DataTable36_11
       4  ??DataTable36_12
       4  ??DataTable36_13
       4  ??DataTable36_14
       4  ??DataTable36_15
       4  ??DataTable36_2
       4  ??DataTable36_3
       4  ??DataTable36_4
       4  ??DataTable36_5
       4  ??DataTable36_6
       4  ??DataTable36_7
       4  ??DataTable36_8
       4  ??DataTable36_9
     248  DetectEndOfTransmitDmaSsp0
       4  Dma_Int_cb_ssp0
     212  Dma_recv_stub_ssp0
     156  Dma_send_stub_ssp0
     252  InSPIDma
     652  OutSPIDma
     648  OutSPIDmaDbg
     140  SetUp_Dma_Chanel
      40  Spi0_Rst
     124  Ssp_Syncro
     420  Ssp_Syncro1
     628  Ssp_Syncro2
     884  Ssp_Syncro3
      64  Ssp_Syncro4
     308  Tci_recv_cb_ssp0
     216  Tci_send_cb_ssp0
       1  chCounterCurState2
       1  chCounterCurState3
       1  chCounterCurState4
      20  disable_irq
      32  dma_clr
      32  dma_miso
      32  dma_mosi
      20  enable_irq
     224  inSPI1
       4  lInitStateCnl
       4  lS
       4  lSpiAccessCtrl
       4  lSsp0HdwState
     252  outSPI1
     436  outSPIDma
     264  recv_cb_spi1
     268  send_cb_spi1
     800  spi1_rxbuff
       4  spi1_rxfill
       4  spi1_rxget
       4  spi1_rxsize
     800  spi1_txbuff
       4  spi1_txfill
       4  spi1_txget
       4  spi1_txsize
       4  sspdev0

 
    75 bytes in section .bss
    68 bytes in section .data
 1 220 bytes in section .text
 1 600 bytes in section DMA_BUFFERS
 3 080 bytes in section Fast_function
 2 328 bytes in section Fast_function_no_cache
 
 6 628 bytes of CODE memory
 1 743 bytes of DATA memory

Errors: none
Warnings: 40
