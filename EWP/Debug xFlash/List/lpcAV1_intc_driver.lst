###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Oct/2015  12:49:39
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        projects\HR1_0100_00_I720_new2\LIB\CDL_AV0\csps\lpc32xx\source\lpcAV1_intc_driver.c
#    Command line =  
#        "D:\IAR
#        projects\HR1_0100_00_I720_new2\LIB\CDL_AV0\csps\lpc32xx\source\lpcAV1_intc_driver.c"
#        -D _STATIC_MEMORY_BOOT -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\List\lpcAV1_intc_driver.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\Obj\lpcAV1_intc_driver.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\LIB\CDL_AV0\csps\lpc32xx\source\lpcAV1_intc_driver.c
      1          /***********************************************************************
      2           * $Id: lpc32xx_intc_driver.c 30870 2009-07-05 10:16:16Z anderslu $
      3           *
      4           * Project: LPC32XX interrupt driver
      5           *
      6           * Description:
      7           *     This file contains driver support for the LPC32xx
      8           *     interrupt driver.
      9           *
     10           * Notes:
     11           *     This driver requires that the CP15 MMU driver is correctly
     12           *     working.
     13           *
     14           ***********************************************************************
     15           * Software that is described herein is for illustrative purposes only
     16           * which provides customers with programming information regarding the
     17           * products. This software is supplied "AS IS" without any warranties.
     18           * NXP Semiconductors assumes no responsibility or liability for the
     19           * use of the software, conveys no license or title under any patent,
     20           * copyright, or mask work right to the product. NXP Semiconductors
     21           * reserves the right to make changes in the software without
     22           * notification. NXP Semiconductors also make no representation or
     23           * warranty that such application will be suitable for the specified
     24           * use without further testing or modification.
     25          ***********************************************************************/
     26          
     27          #include "../../../lpc/include/lpc_arm_arch.h"
     28          #include "../../../lpc/include/lpc_arm922t_cp15_driver.h"
     29          #include "../include/lpc32xx_intc_driver.h"
     30          #include "lpc_irq_fiq.h"
     31          /***********************************************************************
     32           * Interrupt driver package data
     33          ***********************************************************************/
     34          
     35          /* External vector jump addresses - setting one of these addresses with
     36             a new address of a function will cause the new function to be called
     37             when the interrupt or exception occurs */
     38          //.#ifdef __ICCARM__
     39          
     40          extern UNS_32 lpc32xx_reset_vector;
     41          extern UNS_32 vec_reset_handler;
     42          extern UNS_32 vec_undefined_handler;
     43          extern UNS_32 vec_swi_handler;
     44          extern UNS_32 vec_prefetch_handler;
     45          extern UNS_32 vec_abort_handler;
     46          extern UNS_32 vec_irq_handler;
     47          extern UNS_32 vec_fiq_handler;
     48          #ifndef __ICCARM__
     49          rrrr
     50          
     51          #define lpc32xx_reset_vector  __vector   //;
     52          #define vec_reset_handler     __vector   //;
     53          #define vec_undefined_handler __vector   //;
     54          #define vec_swi_handler       __vector   //;
     55          #define vec_prefetch_handler  __vector   //;
     56          #define vec_abort_handler     __vector   //;
     57          #define vec_irq_handler       irq_handler//;
     58          #define vec_fiq_handler       fiq_handler//;
     59          
     60             
     61          #endif
     62          
     63          
     64          
     65          
     66          /* Array of Interrupt handlers */
     67          extern PFV irq_func_ptrs[IRQ_END_OF_INTERRUPTS];
     68          
     69          /* Pointer to logical interrupt vector area (writable) */
     70          extern UNS_32 *vecarea;
     71          
     72          /***********************************************************************
     73           * Vectored Interrupt driver private functions
     74          ***********************************************************************/
     75          
     76          
     77          /***********************************************************************
     78           *
     79           * Function: int_write_arm_vec_table
     80           *
     81           * Purpose: Writes the vector table and jump addresses to vector area
     82           *
     83           * Processing:
     84           *     Copy the shadowed image of the interrupt and exception vector
     85           *     table from memory to the vector jump area (usually at location
     86           *     0x00000000). Force out any cached values to external memory.
     87           *
     88           * Parameters: None
     89           *
     90           * Outputs: None
     91           *
     92           * Returns: Nothing
     93           *
     94           * Notes:
     95           *     Ideally, we would check the state of the V bit in the CP15
     96           *     coprocessor register 1 to determine the address of the where
     97           *     the vector area is located. If that bit was set, the vectors
     98           *     would be located at address 0xFFFF0000 instead of 0x00000000.
     99           *     This function assumes that the vector area is at 0x00000000.
    100           *
    101           **********************************************************************/
    102          static void Int_write_arm_vec_table(void)
    103          {
    104            UNS_32 *dst, *dstsave, *src;
    105            INT_32 vecsize;
    106            UNS_32 high_vector;
    107          
    108            /* If vector address is automatic address, compute address */
    109            dst = vecarea;
    110            if ((UNS_32) dst == 0xFFFFFFFF)
    111            {
    112              /* Assume that vector table is located at low vector
    113                 (0x00000000) address */
    114              dst = (UNS_32 *) ARM_RESET_VEC;
    115          
    116              /* Check status of high vector bit in MMU control register and
    117                 set destination address of vector table to high vector
    118                 address if bit is set */
    119              high_vector = cp15_get_mmu_control_reg();
    120          
    121              /* If high bit is set, use high vector addresses instead */
    122              if ((high_vector & ARM922T_MMU_CONTROL_V) != 0)
    123              {
    124                dst = (UNS_32 *) 0xFFFF0000;
    125              }
    126            }
    127          
    128            /* Copy vector block to interrupt vector area */
    129            dstsave = dst;
    130            for (src = (UNS_32 *) & lpc32xx_reset_vector;
    131                 src <= (UNS_32 *) &vec_fiq_handler; src++)
    132            {
    133              *dst = *src;
    134              dst++;
    135            }
    136          
    137            /* Write out cached vector table to memory */
    138            vecsize = ((INT_32) & vec_fiq_handler -
    139                       (INT_32) & lpc32xx_reset_vector) / 4;
    140            cp15_force_cache_coherence(dstsave, (dstsave + vecsize));
    141          }
    142          
    143          /***********************************************************************
    144           *
    145           * Function: int_get_controller
    146           *
    147           * Purpose: Determines the interrupt controller based on interrupt
    148           *   source
    149           *
    150           * Processing:
    151           *     If the interrupt source is in the range of the MIC controller
    152           *	   then return MIC controller base or else if interrupt source is
    153           *	   in the range of the SIC1 controller return MIC controller base
    154           *	   or else if interrupt source is in the range of the SIC2
    155           *	   controller return SIC2 controller base.
    156           *
    157           * Parameters:
    158           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    159           *
    160           * Outputs:
    161           *	   pIntc_base: Contains the base address of controller
    162           *	   pBit_pos  : Contains the bit position of interrpt source within
    163           *                 controller regs
    164           *
    165           * Returns:
    166           *	  Interrupt controller base.
    167           *
    168           *
    169           **********************************************************************/
    170          static BOOL_32 Int_get_controller(INTERRUPT_SOURCE_T source,
    171                                            INTC_REGS_T** pIntc_base,
    172                                            UNS_32* pBit_pos)
    173          {
    174            BOOL_32 ret_value = TRUE;
    175          
    176            /* Determine the interrupt controller */
    177            if (source < IRQ_SIC1_BASE)
    178            {
    179              *pIntc_base = MIC;
    180              *pBit_pos = (UNS_32)source;
    181            }
    182            else if ((source >= IRQ_SIC1_BASE) && (source < IRQ_SIC2_BASE))
    183            {
    184              *pIntc_base = SIC1;
    185              *pBit_pos = ((UNS_32)source - IRQ_SIC1_BASE);
    186            }
    187            else if (source <= IRQ_END_OF_INTERRUPTS)
    188            {
    189              *pIntc_base = SIC2;
    190              *pBit_pos = ((UNS_32)source - IRQ_SIC2_BASE);
    191            }
    192            else
    193            {
    194              *pIntc_base = 0;
    195              *pBit_pos = 0;
    196              ret_value = FALSE;
    197            }
    198            return ret_value;
    199          }
    200          
    201          
    202          /***********************************************************************
    203           * Interrupt driver public functions
    204          ***********************************************************************/
    205          
    206          /***********************************************************************
    207           *
    208           * Function: int_initialize
    209           *
    210           * Purpose: Initialize the interrupt controller
    211           *
    212           * Processing:
    213           *     For all IRQ interrupt sources, clear the dispatcher jump address
    214           *     and disable the interrupt in the interrupt controller. Copy the
    215           *     vector table and vector branch instructions to the interrupt
    216           *     and exception area with a call to int_write_table.
    217           *
    218           * Parameters:
    219           *     vectbladdr: Pointer to interrupt vector area, or 0xFFFFFFFF to
    220           *                 have driver determine address
    221           *
    222           * Outputs: None
    223           *
    224           * Returns: Nothing
    225           *
    226           * Notes: None
    227           *
    228           **********************************************************************/
    229          void Int_initialize(UNS_32 vectbladdr)
    230          {
    231            UNS_32 source;
    232          
    233            /* Initialize main interrupt controller*/
    234            MIC->er = 0x00000000; /*disable all interrupt sources*/
    235            MIC->rsr = 0xFFFFFFFF;/*clear all edge triggered interrupts*/
    236            MIC->apr = MIC_APR_DEFAULT;/*set polarity for all internal irqs*/
    237            MIC->atr = MIC_ATR_DEFAULT;/*set act. types for all internal irqs*/
    238            MIC->itr = (_BIT(IRQ_SUB1FIQ) | _BIT(IRQ_SUB2FIQ));
    239          
    240            /* Initialize sub interrupt controller 1 */
    241            SIC1->er = 0x00000000; /*disable all interrupt sources*/
    242            SIC1->rsr = 0xFFFFFFFF;/*clear all edge triggered interrupts*/
    243            SIC1->apr = SIC1_APR_DEFAULT;/*set polarity for internal irqs*/
    244            SIC1->atr = SIC1_ATR_DEFAULT;/*set act-types for internal irqs*/
    245            SIC1->itr = 0x00000000;/*set all interrupts as irqs*/
    246          
    247            /* Initialize sub interrupt controller 2 */
    248            SIC2->er = 0x00000000; /*disable all interrupt sources*/
    249            SIC2->rsr = 0xFFFFFFFF;/*clear all edge triggered interrupts*/
    250            SIC2->apr = SIC2_APR_DEFAULT;/*set polarity for internal irqs*/
    251            SIC2->atr = SIC2_ATR_DEFAULT;/*set act. types for internal irqs*/
    252            SIC2->itr = 0x00000000;/*set all interrupts as irqs*/
    253          
    254            /* Enable sub-IRQ/FIQ handlers on main interrupt controller */
    255            MIC->er = (_BIT(IRQ_SUB1IRQ) | _BIT(IRQ_SUB2IRQ) |
    256                       _BIT(IRQ_SUB1FIQ) | _BIT(IRQ_SUB2FIQ));
    257          
    258            /* Clear the IRQ vector table and disable all interrupts */
    259            for (source = 0; source <= IRQ_END_OF_INTERRUPTS; source++)
    260            {
    261              irq_func_ptrs[source] = (PFV) NULL;
    262            }
    263          
    264            /* Save user passed vector area pointer */
    265            vecarea = (UNS_32 *) vectbladdr;
    266          
    267            /* write ARM vector table */
    268            Int_write_arm_vec_table();
    269          }
    270          
    271          /***********************************************************************
    272           *
    273           * Function: int_install_arm_vec_handler
    274           *
    275           * Purpose: Install an new ARM exception vector handler
    276           *
    277           * Processing:
    278           *     If the passed fiq_handler_ptr pointer is not NULL, then
    279           *     set the handler jump address for the specific interrupt or
    280           *     exception to handler_ptr.  Recopy the vector table and vector
    281           *     branch instructions to the interrupt and exception area with a
    282           *     call to int_write_table.
    283           *
    284           * Parameters:
    285           *     handler_id  : Must be an enumeration of type VECTOR_T
    286           *     handler_ptr : Pointer to new interrupt or exception handler
    287           *
    288           * Outputs: None
    289           *
    290           * Returns: Nothing
    291           *
    292           * Notes: None
    293           *
    294           **********************************************************************/
    295          void Int_install_arm_vec_handler(VECTOR_T handler_id,
    296                                           PFV handler_ptr)
    297          {
    298            /* Update address only if it is not NULL */
    299            if (handler_ptr != (PFV) NULL)
    300            {
    301              switch (handler_id)
    302              {
    303                case RESET_VEC:
    304                  vec_reset_handler = (UNS_32) handler_ptr;
    305                  cp15_force_cache_coherence(
    306                    (UNS_32 *) &vec_reset_handler,
    307                    (UNS_32 *) &vec_reset_handler);
    308                  break;
    309          
    310                case UNDEFINED_INST_VEC:
    311                  vec_undefined_handler = (UNS_32) handler_ptr;
    312                  cp15_force_cache_coherence(
    313                    (UNS_32 *) &vec_undefined_handler,
    314                    (UNS_32 *) &vec_undefined_handler);
    315                  break;
    316          
    317                case SWI_VEC:
    318                  vec_swi_handler = (UNS_32) handler_ptr;
    319                  cp15_force_cache_coherence(
    320                    (UNS_32 *) &vec_swi_handler,
    321                    (UNS_32 *) &vec_swi_handler);
    322                  break;
    323          
    324                case PREFETCH_ABORT_VEC:
    325                  vec_prefetch_handler = (UNS_32) handler_ptr;
    326                  cp15_force_cache_coherence(
    327                    (UNS_32 *) &vec_prefetch_handler,
    328                    (UNS_32 *) &vec_prefetch_handler);
    329                  break;
    330          
    331                case DATA_ABORT_VEC:
    332                  vec_abort_handler = (UNS_32) handler_ptr;
    333                  cp15_force_cache_coherence(
    334                    (UNS_32 *) &vec_abort_handler,
    335                    (UNS_32 *) &vec_abort_handler);
    336                  break;
    337          
    338                case IRQ_VEC:
    339                  vec_irq_handler = (UNS_32) handler_ptr;
    340                  cp15_force_cache_coherence(
    341                    (UNS_32 *) &vec_irq_handler,
    342                    (UNS_32 *) &vec_irq_handler);
    343                  break;
    344          
    345                case FIQ_VEC:
    346                  vec_fiq_handler = (UNS_32) handler_ptr;
    347                  cp15_force_cache_coherence(
    348                    (UNS_32 *) &vec_fiq_handler,
    349                    (UNS_32 *) &vec_fiq_handler);
    350                  break;
    351          
    352                default:
    353                  break;
    354              }
    355          
    356              /* Update ARM vector table */
    357              Int_write_arm_vec_table();
    358            }
    359          }
    360          
    361          /***********************************************************************
    362           *
    363           * Function: int_install_irq_handler
    364           *
    365           * Purpose: Install an IRQ interrupt handler for an internal interrupt
    366           *
    367           * Processing:
    368           *     For the selected interrupt, sets the function called as the
    369           *     passed value.
    370           *
    371           * Parameters:
    372           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    373           *     func_ptr : Pointer to a void function
    374           *
    375           * Outputs: None
    376           *
    377           * Returns: Returns TRUE or FALSE.
    378           *
    379           * Notes: None
    380           *
    381           **********************************************************************/
    382          BOOL_32 Int_install_irq_handler(INTERRUPT_SOURCE_T source,
    383                                          PFV func_ptr)
    384          {
    385            BOOL_32 ret_value = FALSE;
    386          
    387            if (source < IRQ_END_OF_INTERRUPTS)
    388            {
    389              irq_func_ptrs[source] = func_ptr;
    390              ret_value = TRUE;
    391            }
    392            return ret_value;
    393          }
    394          
    395          /***********************************************************************
    396           *
    397           * Function: int_install_ext_irq_handler
    398           *
    399           * Purpose: Install an IRQ interrupt handler for an external interrupt
    400           *
    401           * Processing:
    402           *     For the selected interrupt, sets the function called as the
    403           *     passed value.
    404           *
    405           * Parameters:
    406           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    407           *     func_ptr : Pointer to a void function
    408           *     type	    : Interrupt activation type (INTERRUPT_TYPE_T)
    409           *     high     : Interrupt on high level or edge
    410           *
    411           * Outputs: None
    412           *
    413           * Returns: Returns TRUE or FALSE.
    414           *
    415           * Notes: None
    416           *
    417           **********************************************************************/
    418          BOOL_32 Int_install_ext_irq_handler(INTERRUPT_SOURCE_T source,
    419                                              PFV func_ptr,
    420                                              INTERRUPT_TYPE_T type,
    421                                              int high)
    422          {
    423            BOOL_32 ret_value = TRUE;
    424            INTC_REGS_T *pIntc;
    425            UNS_32 bit_pos = 0;
    426          
    427            /* get the interrupt controller for the give interrupt source */
    428            ret_value = Int_get_controller(source, &pIntc, &bit_pos);
    429            if (TRUE == ret_value)
    430            {
    431              switch (type)
    432              {
    433                case ACTIVE_LOW:
    434                  pIntc->apr &= ~_BIT(bit_pos);
    435                  pIntc->atr &= ~_BIT(bit_pos);
    436                  break;
    437                case ACTIVE_HIGH:
    438                  pIntc->apr |= _BIT(bit_pos);
    439                  pIntc->atr &= ~_BIT(bit_pos);
    440                  break;
    441                case FALLING_EDGE:
    442                  pIntc->apr &= ~_BIT(bit_pos);
    443                  pIntc->atr |= _BIT(bit_pos);
    444                  break;
    445                case RISING_EDGE:
    446                  pIntc->apr |= _BIT(bit_pos);
    447                  pIntc->atr |= _BIT(bit_pos);
    448                  break;
    449                default:
    450                  ret_value = FALSE;
    451                  break;
    452              }
    453              if (TRUE == ret_value)
    454                irq_func_ptrs[source] = func_ptr;
    455            }
    456          
    457            return ret_value;
    458          }
    459          static long IntFuncUseCounter = 0; 
    460          /***********************************************************************
    461           *
    462           * Function: int_enable
    463           *
    464           * Purpose: Enable an interrupt
    465           *
    466           * Processing:
    467           *     Enables the interrupt in the controller for the selected source.
    468           *
    469           * Parameters:
    470           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    471           *
    472           * Outputs: None
    473           *
    474           * Returns: Nothing
    475           *
    476           * Notes: None
    477           *
    478           **********************************************************************/
    479          void Int_enable(INTERRUPT_SOURCE_T source)
    480          {
    481            BOOL_32 ret_value = FALSE;
    482            INTC_REGS_T *pIntc;
    483            UNS_32 bit_pos;
    484          disable_fiq();
    485           //MIC->er|= 0x
    486            /* get the interrupt controller for the give interrupt source */
    487            bit_pos = 0;
    488            ret_value = Int_get_controller(source, &pIntc, &bit_pos);
    489            if (TRUE == ret_value)
    490            {
    491              /* cast the interrupt controller pointer*/
    492              pIntc->er |= _BIT(bit_pos);
    493            }
    494            enable_fiq();
    495          }
    496          void Int_enable1(INTERRUPT_SOURCE_T source)
    497          {
    498          disable_irq();
    499          MIC->er|=  _BIT(source);
    500          enable_irq();
    501          }
    502          /***********************************************************************
    503           *
    504           * Function: int_disable
    505           *
    506           * Purpose: Disable an interrupt
    507           *
    508           * Processing:
    509           *     Masks the interrupt in the controller for the selected source.
    510           *
    511           * Parameters:
    512           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    513           *
    514           * Outputs: None
    515           *
    516           * Returns: Nothing
    517           *
    518           * Notes: None
    519           *
    520           **********************************************************************/
    521          void Int_disable(INTERRUPT_SOURCE_T source)
    522          {
    523            BOOL_32 ret_value = FALSE;
    524            INTC_REGS_T *pIntc;
    525            UNS_32 bit_pos = 0;
    526          disable_fiq();
    527            /* get the interrupt controller for the give interrupt source */
    528            ret_value = Int_get_controller(source, &pIntc, &bit_pos);
    529            if (TRUE == ret_value)
    530            {
    531              /* cast the interrupt controller pointer*/
    532              pIntc->er &= ~_BIT(bit_pos);
    533            }
    534            enable_fiq();
    535          }
    536          void Int_disable1(INTERRUPT_SOURCE_T source)
    537          {
    538          disable_irq();
    539          MIC->er &= ~ _BIT(source);
    540          enable_irq();
    541          }
    542          
    543          void Int_disableGen(INTERRUPT_SOURCE_T source)
    544          {
    545          disable_irq_fiq();
    546          MIC->er &= ~ _BIT(source);
    547          enable_irq_fiq();
    548          }
    549          void Int_enableGen(INTERRUPT_SOURCE_T source)
    550          {
    551          disable_irq_fiq();
    552          MIC->er|=  _BIT(source);
    553          //enable_irq();
    554          enable_irq_fiq();
    555          }
    556          
    557          /***********************************************************************
    558           *
    559           * Function: int_pending
    560           *
    561           * Purpose: Check to see if a unmasked interrupt is pending
    562           *
    563           * Processing:
    564           *     If the status for the selected interrupt source is set,
    565           *     a TRUE is returned. Otherwise, FALSE is returned.
    566           *
    567           * Parameters:
    568           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    569           *
    570           * Outputs: None
    571           *
    572           * Returns: Returns TRUE or FALSE.
    573           *
    574           * Notes: None
    575           *
    576           **********************************************************************/
    577          BOOL_32 Int_pending(INTERRUPT_SOURCE_T source)
    578          {
    579            BOOL_32 ret_value = FALSE;
    580            INTC_REGS_T *pIntc;
    581            UNS_32 bit_pos = 0;
    582          
    583            /* get the interrupt controller for the give interrupt source */
    584            ret_value = Int_get_controller(source, &pIntc, &bit_pos);
    585            if (TRUE == ret_value)
    586            {
    587              /* cast the interrupt controller pointer*/
    588              ret_value = ((pIntc->sr & _BIT(bit_pos)) != 0);
    589            }
    590          
    591            return ret_value;
    592          }
    593          
    594          /***********************************************************************
    595           *
    596           * Function: int_raw_pending
    597           *
    598           * Purpose: Check to see if a raw interrupt is pending
    599           *
    600           * Processing:
    601           *     If the raw status for the selected interrupt source is set,
    602           *     a TRUE is returned. Otherwise, FALSE is returned.
    603           *
    604           * Parameters:
    605           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    606           *
    607           * Outputs: None
    608           *
    609           * Returns: Returns TRUE or FALSE.
    610           *
    611           * Notes: None
    612           *
    613           **********************************************************************/
    614          BOOL_32 Int_raw_pending(INTERRUPT_SOURCE_T source)
    615          {
    616            BOOL_32 ret_value = FALSE;
    617            INTC_REGS_T *pIntc;
    618            UNS_32 bit_pos = 0;
    619          
    620            /* get the interrupt controller for the give interrupt source */
    621            ret_value = Int_get_controller(source, &pIntc, &bit_pos);
    622            if (TRUE == ret_value)
    623            {
    624              /* cast the interrupt controller pointer*/
    625              ret_value = ((pIntc->rsr & _BIT(bit_pos)) != 0);
    626            }
    627          
    628            return ret_value;
    629          }
    630          
    631          /***********************************************************************
    632           *
    633           * Function: int_enabled
    634           *
    635           * Purpose: Check to see if an interrupt is enabled
    636           *
    637           * Processing:
    638           *     If the selected interrupt source is enabled, a TRUE is returned.
    639           *     Otherwise, FALSE is returned.
    640           *
    641           * Parameters:
    642           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    643           *
    644           * Outputs: None
    645           *
    646           * Returns: Returns TRUE or FALSE.
    647           *
    648           * Notes: None
    649           *
    650           **********************************************************************/
    651          BOOL_32 Int_enabled(INTERRUPT_SOURCE_T source)
    652          {
    653            BOOL_32 ret_value = FALSE;
    654            INTC_REGS_T *pIntc;
    655            UNS_32 bit_pos = 0;
    656          
    657            /* get the interrupt controller for the give interrupt source */
    658            ret_value = Int_get_controller(source, &pIntc, &bit_pos);
    659            if (TRUE == ret_value)
    660            {
    661              /* cast the interrupt controller pointer*/
    662              ret_value = ((pIntc->er & _BIT(bit_pos)) != 0);
    663            }
    664          
    665            return ret_value;
    666          }
    667          
    668          /***********************************************************************
    669           *
    670           * Function: int_clear
    671           *
    672           * Purpose: Clear a pending (latched) interrupt
    673           *
    674           * Processing:
    675           *     See function.
    676           *
    677           * Parameters:
    678           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    679           *
    680           * Outputs: None
    681           *
    682           * Returns: Returns TRUE or FALSE.
    683           *
    684           * Notes: None
    685           *
    686           **********************************************************************/
    687          BOOL_32 Int_clear(INTERRUPT_SOURCE_T source)
    688          {
    689            BOOL_32 ret_value = FALSE;
    690            INTC_REGS_T *pIntc;
    691            UNS_32 bit_pos = 0;
    692          
    693            /* get the interrupt controller for the give interrupt source */
    694            ret_value = Int_get_controller(source, &pIntc, &bit_pos);
    695            if (TRUE == ret_value)
    696            {
    697              /* Clear pending interrupt */
    698              pIntc->rsr = _BIT(bit_pos);
    699            }
    700          
    701            return ret_value;
    702          }
    703          
    704          /***********************************************************************
    705           *
    706           * Function: int_setup_irq_fiq
    707           *
    708           * Purpose: Setup an interrupt as an IRQ (FALSE) or and FIQ (TRUE)
    709           *
    710           * Processing:
    711           *     See function.
    712           *
    713           * Parameters:
    714           *     source  : Interrupt source of type INTERRUPT_SOURCE_T
    715           *     use_fiq : TRUE to use an FIQ interrupt type, FALSE for IRQ
    716           *
    717           * Outputs: None
    718           *
    719           * Returns: Returns TRUE or FALSE.
    720           *
    721           * Notes: None
    722           *
    723           **********************************************************************/
    724          BOOL_32 Int_setup_irq_fiq(INTERRUPT_SOURCE_T source,
    725                                    BOOL_32 use_fiq)
    726          {
    727            BOOL_32 ret_value = FALSE;
    728            INTC_REGS_T *pIntc;
    729            UNS_32 bit_pos = 0;
    730          
    731            /* get the interrupt controller for the give interrupt source */
    732            ret_value = Int_get_controller(source, &pIntc, &bit_pos);
    733            if (use_fiq == TRUE)
    734            {
    735              /* FIQ interrupt type */
    736              pIntc->itr |= _BIT(bit_pos);
    737            }
    738            else
    739            {
    740              /* IRQ interrupt type */
    741              pIntc->itr &= ~_BIT(bit_pos);
    742            }
    743          
    744            return ret_value;
    745          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   Int_clear
        24   -> Int_get_controller
      24   Int_disable
        24   -> Int_get_controller
        24   -> disable_fiq
        24   -> enable_fiq
       8   Int_disable1
         8   -> disable_irq
         8   -> enable_irq
       8   Int_disableGen
         8   -> disable_irq_fiq
         8   -> enable_irq_fiq
      24   Int_enable
        24   -> Int_get_controller
        24   -> disable_fiq
        24   -> enable_fiq
       8   Int_enable1
         8   -> disable_irq
         8   -> enable_irq
       8   Int_enableGen
         8   -> disable_irq_fiq
         8   -> enable_irq_fiq
      24   Int_enabled
        24   -> Int_get_controller
       0   Int_get_controller
      16   Int_initialize
        16   -> Int_write_arm_vec_table
      16   Int_install_arm_vec_handler
        16   -> Int_write_arm_vec_table
        16   -> cp15_force_cache_coherence
      32   Int_install_ext_irq_handler
        32   -> Int_get_controller
       0   Int_install_irq_handler
      24   Int_pending
        24   -> Int_get_controller
      24   Int_raw_pending
        24   -> Int_get_controller
      24   Int_setup_irq_fiq
        24   -> Int_get_controller
      24   Int_write_arm_vec_table
        24   -> cp15_force_cache_coherence
        24   -> cp15_get_mmu_control_reg
        24 __aeabi_idiv
       0   disable_fiq
       0   disable_irq
       0   disable_irq_fiq
       0   enable_fiq
       0   enable_irq
       0   enable_irq_fiq


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      84  Int_clear
     100  Int_disable
      56  Int_disable1
      56  Int_disableGen
      96  Int_enable
      52  Int_enable1
      52  Int_enableGen
      88  Int_enabled
     192  Int_get_controller
     324  Int_initialize
     228  Int_install_arm_vec_handler
     392  Int_install_ext_irq_handler
      56  Int_install_irq_handler
      88  Int_pending
      88  Int_raw_pending
     128  Int_setup_irq_fiq
     148  Int_write_arm_vec_table
      20  disable_fiq
      20  disable_irq
      20  disable_irq_fiq
      20  enable_fiq
      20  enable_irq
      20  enable_irq_fiq

 
 2 396 bytes in section .text
 
 2 396 bytes of CODE memory

Errors: none
Warnings: 1
