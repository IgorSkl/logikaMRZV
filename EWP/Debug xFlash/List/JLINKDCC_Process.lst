###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Oct/2015  12:49:37
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\DCC\JLINKDCC_Process.c
#    Command line =  
#        "D:\IAR projects\HR1_0100_00_I720_new2\DCC\JLINKDCC_Process.c" -D
#        _STATIC_MEMORY_BOOT -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\List\JLINKDCC_Process.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\Obj\JLINKDCC_Process.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\DCC\JLINKDCC_Process.c
      1          /*********************************************************************
      2          *               SEGGER MICROCONTROLLER GmbH & Co KG                  *
      3          *       Solutions for real time microcontroller applications         *
      4          **********************************************************************
      5          *                                                                    *
      6          *       (c) 1995 - 2011  SEGGER Microcontroller GmbH & Co KG         *
      7          *                                                                    *
      8          *       www.segger.com     Support: support@segger.com               *
      9          *                                                                    *
     10          **********************************************************************
     11          ----------------------------------------------------------------------
     12          File    : JLINKDCC_Process.c
     13          Purpose : Data handler for ARM J-Link type communication via DCC (IAR version, using intrinsics)
     14          Changes : 08-10-08
     15                    Support for "channels"added, where
     16                    channel 0 is reserved for terminal
     17                    channel 1 is reserved for OS communication such as embOSView
     18                    11-11-15
     19                    Cortex A/R defines modified.
     20          
     21          Notes   : (1) How to use
     22                        In order to use the DCC communication to read / write memory, the
     23                          following needs to be done:
     24                        * Add this file to the project / make-file
     25                        * Make sure this data handler is called regularly
     26                        * Add the JLINKDCC data abort handler (optional)
     27                          For details, refer to the documentation or see file JLINKDCC_HandleDataAbort.s79.
     28                    (2) Compatibility
     29                        The J-Link ARM DCC handler is compatible to the DCC communication
     30                        protocol used by IAR in the embedded workbench for ARM and allows
     31                        using the live data window in C-Spy
     32          
     33          Protocol
     34            Following response packets from target will be possible:
     35            00 00 00 XX - reading a byte XX
     36            00 00 XX XX - reading a half word XXXX
     37            XX XX XX XX - reading a word, except words starting with 93zX XXXX (10010011-1xxxxxxx-xxxxxxx-xxxxxxx)
     38          
     39            93 8z 00 XX - terminal I/O one byte XX to channel z=0-15
     40            93 9z 00 XX - terminal I/O one byte XX to channel z=16-31
     41            93 Az XX XX - terminal I/O two bytes XX XX to channel z=0-15
     42            93 Bz XX XX - terminal I/O two bytes XX XX to channel z=16-31
     43          
     44            93 C0 XX XX - escape sequence for words starting with 93XX, the lower 16-bit part is in XX XX
     45            93 C1 XX XX - escape sequence for words starting with 93XX, the upper 16-bit part is in XX XX
     46            93 C2 XX XX - data abort for reading
     47            91 CA XX XX - signature (same as before)
     48          
     49            There is a new capability flag. C-SPY will use the new protocol when this is set.
     50            #define DCC_CAP_TERM_OUT   0x80
     51          
     52          Sequence for U8 write:
     53            H->T    Addr & 0xFFFFFFFE
     54            H->T    ((Addr & 1) << 31) | (Data << 2) | 0x40000001
     55          
     56          Sequence for U16 write:
     57            H->T    Addr & 0xFFFFFFFE
     58            H->T    ((Addr & 1) << 31) | (Data << 2) | 0x20000001
     59          
     60          Sequence for U32 write:
     61            H->T    Addr & 0xFFFFFFFE
     62            H->T    (Data & 0xFFFF) << 2
     63            H->T    ((Addr & 1) << 31) | ((Data >> 14) & 0xFFFF) | 0x10000001
     64          
     65          Sequence for U8 Read:
     66            H->T    Addr & 0xFFFFFFFE
     67            H->T    ((Addr & 1) << 31) | (NumItems << 2) | 0x04000001
     68            if (Aborted) {
     69              T->H    0x93c20000
     70            } else {
     71              T->H    Data
     72            }
     73          
     74          Sequence for U16 Read:
     75            H->T    Addr & 0xFFFFFFFE
     76            H->T    ((Addr & 1) << 31) | (NumItems << 2) | 0x02000001
     77            if (Aborted) {
     78              T->H    0x93c20000
     79            } else {
     80              T->H    Data
     81            }
     82          
     83          Sequence for U32 Read:
     84            H->T    Addr & 0xFFFFFFFE
     85            H->T    ((Addr & 1) << 31) | (NumItems << 2) | 0x01000001
     86            if (Aborted) {
     87              T->H    0x93c20000
     88            } else if ((Data >> 24) != 0x93) {
     89              T->H    Data
     90            } else {
     91              T->H    0x93c0.0000 | (Data & 0xFFFF)
     92              T->H    0x93c1.0000 | (Data >> 16)
     93            }
     94          
     95          Terminal IN:  (target receives data)
     96          H->T   0x93000000 + (Channel << 19) + (Data8 << 1) + DCC_OP_COMMAND
     97          
     98          Terminal OUT: (target sends data)
     99          T->H   0x93800000 + (Channel << 16) + (Data8)
    100          
    101          ---------------------------END-OF-HEADER------------------------------
    102          */
    103          
    104          #include "JLINKDCC.h"
    105          
    106          #ifdef __ICCARM__
    107            /* With IAR workbench we use intrinsics for CP14 communication */
    108            #include <intrinsics.h>
    109          #else
    110            #define __ARM7A__ 1
    111            #define __ARM7R__ 2
    112            #define __CORE__  0    // Default is: DCC module is designed for ARM7/9. In order to support Cortex-A/R, __CORE__ has to be set to __ARM7A__ or __ARM7R__
    113            /* We use external functions from assembly module JLINKDCC_Process_ASM.s */
    114            extern unsigned long CP14_ReadDCCStat(void);
    115            extern unsigned long CP14_ReadDCC(void);
    116            extern void CP14_WriteDCC(unsigned long Data);
    117          #endif
    118          
    119          /*********************************************************************
    120          *
    121          *       Defines, configurable
    122          *
    123          **********************************************************************
    124          */
    125          
    126          #ifndef JLINKDCC_BUFFER_SIZE
    127            #define JLINKDCC_BUFFER_SIZE    1024          // Used for channel 0 (terminal out buffer)
    128          #endif
    129          
    130          #define NUM_CHANNELS              2
    131          
    132          /*********************************************************************
    133          *
    134          *       Defines, non- configurable
    135          *
    136          **********************************************************************
    137          */
    138          
    139          #define U8  unsigned char
    140          #define U16 unsigned short
    141          #define U32 unsigned long
    142          
    143          #define DCC_OP_READ_U32   0x01000000
    144          #define DCC_OP_READ_U16   0x02000000
    145          #define DCC_OP_READ_U8    0x04000000
    146          #define DCC_OP_GET_CAPS   0x08000000
    147          #define DCC_OP_WRITE_U32  0x10000000
    148          #define DCC_OP_WRITE_U16  0x20000000
    149          #define DCC_OP_WRITE_U8   0x40000000
    150          #define DCC_OP_ODD_ADDR   0x80000000
    151          #define DCC_OP_COMMAND    0x00000001
    152          
    153          #define DCC_SIGNATURE     0x91CA0000
    154          #define DCC_CONFIG        0xFF       // All features are supported
    155          
    156          #define DCC_CHANNEL_TERMINAL  0
    157          #define DCC_CHANNEL_OS        1
    158          
    159          //
    160          // The bit positions for DCC RX and TX ready are different for ARM7/9 and Cortex-A/R,
    161          // so we have to distinguish here.
    162          //
    163          #if (defined (__ARM7A__) && (__CORE__ == __ARM7A__)) || (defined (__ARM7R__) && (__CORE__ == __ARM7R__))
    164            #define RX_FULL_FLAG_SHIFT 30
    165            #define TX_FULL_FLAG_SHIFT 29
    166          #else
    167            #define RX_FULL_FLAG_SHIFT 0
    168            #define TX_FULL_FLAG_SHIFT 1
    169          #endif
    170          
    171          /*********************************************************************
    172          *
    173          *       Global data
    174          *
    175          **********************************************************************
    176          */
    177          
    178          U8 JLINKDCC_IsInHandler;
    179          U8 JLINKDCC_AbortOccurred;
    180          
    181          /*********************************************************************
    182          *
    183          *       Static data
    184          *
    185          **********************************************************************
    186          */
    187          
    188          void (* _pfOnRx[2]) (unsigned Channel, U8 Data);
    189          void (* _pfOnTx[2]) (unsigned Channel);
    190          
    191          
    192          static U16  _NumReadItems;
    193          static U32  _Command;
    194          static U32  _Addr;
    195          
    196          static char _acBuffer[JLINKDCC_BUFFER_SIZE];
    197          static U16  _RdPos;
    198          static U16  _WrPos;
    199          
    200          static U8   _ActiveChannel   = 0;
    201          
    202          static char _WritePendingNB  = 0;
    203          static U32  _PendingPacketNB = 0;
    204          
    205          static char _WritePending;
    206          static U32  _Data;
    207          
    208          /*********************************************************************
    209          *
    210          *       Static code
    211          *
    212          **********************************************************************
    213          */
    214          
    215          #ifdef __ICCARM__
    216          /****** Use intrinsics for CP14 communication ***********************/
    217          
    218          #if (defined (__ARM7A__) && (__CORE__ == __ARM7A__)) || (defined (__ARM7R__) && (__CORE__ == __ARM7R__))
    219          
    220          /*********************************************************************
    221          *
    222          *       _ReadDCCStat
    223          *
    224          *  IAR macro:     unsigned long __MRC(coproc, opcode_1, CRn, CRm, opcode_2);
    225          *  Inst:          MRC<c> <coproc>,<opc1>,<Rt>,<CRn>,<CRm>{,<opc2>}  Move from coproc to ARM reg
    226          *  ARMv4 / ARMv5: MRC p14,0,<Rt>,c0,c0,0
    227          *  ARMv7-AR:      MRC p14,0,<Rt>,c0,c1,0 DBGDSCR
    228          */
    229          static int _ReadDCCStat(void) {
    230            return __MRC(14, 0, 0, 1, 0);
    231          }
    232          
    233          /*********************************************************************
    234          *
    235          *       _ReadDCC
    236          *
    237          *  IAR macro:     unsigned long __MRC(coproc, opcode_1, CRn, CRm, opcode_2);
    238          *  Inst:          MRC<c> <coproc>,<opc1>,<Rt>,<CRn>,<CRm>{,<opc2>}  Move from coproc to ARM reg
    239          *  ARMv4 / ARMv5: MRC p14,0,<Rt>,c1,c0,0
    240          *  ARMv7-AR:      MRC p14,0,<Rt>,c0,c5,0 DTRRX
    241          */
    242          static U32 _ReadDCC(void) {
    243            return __MRC(14, 0, 0, 5, 0);
    244          }
    245          
    246          /*********************************************************************
    247          *
    248          *       _WriteDCC
    249          *
    250          *  IAR macro:     void __MCR(coproc, opcode_1, Data, CRn, CRm, opcode_2);
    251          *  Inst:          MCR<c> <coproc>,<opc1>,<Rt>,<CRn>,<CRm>{,<opc2>}  Move to coproc
    252          *  ARMv4 / ARMv5: MCR P14,0,<Rt>,C1,C0,0
    253          *  ARMv7-AR:      MCR p14,0,<Rt>,c0,c5,0 DTRTX
    254          */
    255          static void _WriteDCC(U32 Data) {
    256            __MCR(14, 0, Data, 0, 5, 0);
    257          }
    258          
    259          #else // (defined (__ARM7A__) && (__CORE__ == __ARM7A__)) || (defined (__ARM7R__) && (__CORE__ == __ARM7R__))
    260          
    261          /*********************************************************************
    262          *
    263          *       _ReadDCCStat
    264          *
    265          *  IAR macro:     unsigned long __MRC(coproc, opcode_1, CRn, CRm, opcode_2);
    266          *  Inst:          MRC<c> <coproc>,<opc1>,<Rt>,<CRn>,<CRm>{,<opc2>}  Move from coproc to ARM reg
    267          *  ARMv4 / ARMv5: MRC p14,0,<Rt>,c0,c0,0
    268          *  ARMv7-AR:      MRC p14,0,<Rt>,c0,c1,0 DBGDSCR
    269          */
    270          static __interwork __arm int _ReadDCCStat(void) {
    271            return __MRC( 14, 0, 0, 0, 0 );       // __asm("mrc P14,0,R0,C0,C0,0");
    272          }
    273          
    274          /*********************************************************************
    275          *
    276          *       _ReadDCC
    277          *
    278          *  IAR macro:     unsigned long __MRC(coproc, opcode_1, CRn, CRm, opcode_2);
    279          *  Inst:          MRC<c> <coproc>,<opc1>,<Rt>,<CRn>,<CRm>{,<opc2>}  Move from coproc to ARM reg
    280          *  ARMv4 / ARMv5: MRC p14,0,<Rt>,c1,c0,0
    281          *  ARMv7-AR:      MRC p14,0,<Rt>,c0,c5,0 DTRRX
    282          */
    283          static __interwork __arm U32 _ReadDCC(void) {
    284            return __MRC( 14, 0, 1, 0, 0 );       // __asm("mrc P14,0,R0,C1,C0,0");
    285          }
    286          
    287          /*********************************************************************
    288          *
    289          *       _WriteDCC
    290          *
    291          *  IAR macro:     void __MCR(coproc, opcode_1, Data, CRn, CRm, opcode_2);
    292          *  Inst:          MCR<c> <coproc>,<opc1>,<Rt>,<CRn>,<CRm>{,<opc2>}  Move to coproc
    293          *  ARMv4 / ARMv5: MCR P14,0,<Rt>,C1,C0,0
    294          *  ARMv7-AR:      MCR p14,0,<Rt>,c0,c5,0 DTRTX
    295          */
    296          static __interwork __arm void _WriteDCC(U32 Data) {
    297            __MCR( 14, 0, Data, 1, 0, 0 );        // __asm("mcr P14,0,R0,C1,C0,0");
    298          }
    299          
    300          #endif // (defined (__ARM7A__) && (__CORE__ == __ARM7A__)) || (defined (__ARM7R__) && (__CORE__ == __ARM7R__))
    301          #else  //__ICCARM__
    302          
    303          /****** Map externel CP14 communication routines ********************/
    304          #define _ReadDCCStat     CP14_ReadDCCStat
    305          #define _ReadDCC         CP14_ReadDCC
    306          #define _WriteDCC(Data)  CP14_WriteDCC(Data)
    307          
    308          #endif // __ICCARM__
    309          
    310          /*********************************************************************
    311          *
    312          *       _HandleRead
    313          *
    314          *  Function description
    315          *    Performs Command / data read from host
    316          */
    317          static void _HandleRead(void) {
    318            U32 Data;
    319          
    320            if (((_ReadDCCStat() >> RX_FULL_FLAG_SHIFT)  & 1) == 0) {       // Data or command received ?
    321              return;      // Nothing received
    322            }
    323          
    324            Data = _ReadDCC();
    325            //
    326            // If item received does not have the command-flag set, it is the new addr.
    327            //
    328            if ((Data & DCC_OP_COMMAND) == 0) {
    329              _Addr = Data;
    330              return;
    331            }
    332            //
    333            // If item received is a terminal out command,
    334            //
    335            if ((Data & 0xFF000000) == 0x93000000) {
    336              unsigned Channel;
    337              Channel = (Data >> 19) & 0x1F;
    338              if (_pfOnRx[Channel]) {
    339                _pfOnRx[Channel](Channel, (Data >> 1) & 0xFF);
    340              }
    341              return;
    342            }
    343            //
    344            // We received a new command.
    345            //
    346            _Command = Data;
    347            if (_Command & DCC_OP_ODD_ADDR) {
    348              _Addr |= 1;
    349            }
    350            if (_Command & (DCC_OP_READ_U32 | DCC_OP_READ_U16 | DCC_OP_READ_U8 | DCC_OP_GET_CAPS)) {
    351              _NumReadItems = (_Command >> 2) & 0xffff;
    352            } else {
    353              // Clear before write
    354              JLINKDCC_AbortOccurred = 0;
    355          
    356              if (_Command & DCC_OP_WRITE_U32) {
    357                _Data |= (_Command << 14) & 0xffff0000;
    358              } else {
    359                _Data = (_Command >> 2) & 0xffff;
    360              }
    361              if (_Command & DCC_OP_WRITE_U8) {
    362                *(U8*)_Addr = _Data;
    363                _Addr += 1;
    364              }
    365              if (_Command & DCC_OP_WRITE_U16) {
    366                *(U16*)_Addr = _Data;
    367                _Addr += 2;
    368              }
    369              if (_Command & DCC_OP_WRITE_U32) {
    370                *(U32*)_Addr =_Data;
    371                _Addr += 4;
    372              }
    373            }
    374          }
    375          
    376          /*********************************************************************
    377          *
    378          *       _HandleWrite
    379          *
    380          *  Function description
    381          *    Sends data back to host if there is space in DCC buffer and data to be send.
    382          */
    383          static void _HandleWrite(void) {
    384            U32 Data;
    385            int DCCBusy;
    386            int NumBytes;
    387          
    388            Data = 0;
    389            DCCBusy = (_ReadDCCStat() >> TX_FULL_FLAG_SHIFT) & 1;
    390            if (DCCBusy) {                  // Can we send data ?
    391              return;                       // If not, we are done.
    392            }
    393          
    394            if (_ActiveChannel) {
    395              U32 Channel;
    396          
    397              Channel = _ActiveChannel;
    398              _ActiveChannel = 0;
    399              if (_WritePendingNB) {
    400                _WriteDCC(_PendingPacketNB);
    401                _WritePendingNB = 0;
    402              }
    403              if (_pfOnTx[Channel]) {
    404                _pfOnTx[Channel](Channel);
    405              }
    406              return;
    407            }
    408          
    409            //
    410            // Check if a data item is pending
    411            //
    412            if (_WritePending) {
    413              _WriteDCC(_Data);
    414              _WritePending = 0;
    415              return;
    416            }
    417            //
    418            // Check if a read command is pending
    419            //
    420            if (_NumReadItems) {
    421              if (_Command & DCC_OP_GET_CAPS) {
    422                Data = (DCC_CONFIG | DCC_SIGNATURE);
    423                Data |= (JLINKDCC_AbortOccurred << 8);  // write abort status
    424                JLINKDCC_AbortOccurred = 0;
    425              } else {
    426          
    427                // Clear before next read
    428                JLINKDCC_AbortOccurred = 0;
    429          
    430                if (_Command & DCC_OP_READ_U8) {
    431                  Data = *(U8*)_Addr;
    432                  _Addr += 1;
    433                } else if (_Command & DCC_OP_READ_U16) {
    434                  Data = *(U16*)_Addr;
    435                  _Addr += 2;
    436                } else if (_Command & DCC_OP_READ_U32) {
    437                  Data = *(U32*)_Addr;
    438                  _Addr += 4;
    439                  if ((Data & 0xFF800000) == 0x93800000) {    // Do we need to use the escape sequence and split it up into 2 transfers ?
    440                    _Data = 0x93c10000 | (Data >> 16);
    441                    Data  = 0x93c00000 | (Data & 0xFFFF);
    442                    _WritePending = 1;
    443                  }
    444                }
    445                if (JLINKDCC_AbortOccurred) {
    446                  Data = 0x93c20000;          // read abort status
    447                  _WritePending = 0;
    448                  JLINKDCC_AbortOccurred = 0; // clear it
    449                }
    450              }
    451          
    452              _WriteDCC(Data);
    453              _NumReadItems--;
    454              return;
    455            }
    456            //
    457            // Handle terminal out. Up to 2 bytes in one 32-bit unit
    458            //
    459            NumBytes = _WrPos - _RdPos;
    460            if (NumBytes < 0) {
    461              NumBytes += sizeof(_acBuffer);
    462            }
    463            if (NumBytes) {
    464              int i;
    465              if (NumBytes > 2) {
    466                NumBytes = 2;
    467              }
    468              if (NumBytes == 2) {
    469                Data = 0x93A00000;
    470              } else {
    471                Data = 0x93800000;
    472              }
    473              for (i = 0; i < NumBytes; i++) {
    474                Data |= _acBuffer[_RdPos] << (8*i);
    475                _RdPos++;
    476                if (_RdPos == sizeof(_acBuffer)) {
    477                  _RdPos = 0;
    478                }
    479              }
    480              _WriteDCC(Data);
    481            }
    482          }
    483          
    484          
    485          /*********************************************************************
    486          *
    487          *       Public code
    488          *
    489          **********************************************************************
    490          */
    491          
    492          /*********************************************************************
    493          *
    494          *       JLINKDCC_Process
    495          *
    496          *  Function description
    497          *    This function should be called more or less regularily to allow
    498          *    memory reads while the application progam is running.
    499          *    The more often it is called, the higher the transfer speed.
    500          */
    501          void JLINKDCC_Process(void) {
    502            //
    503            // Avoid problems if this code is called from multiple threads or interrupts
    504            //
    505            if (JLINKDCC_IsInHandler) {
    506              return;
    507            }
    508            JLINKDCC_IsInHandler = 1;
    509            _HandleRead();
    510            _HandleWrite();
    511             JLINKDCC_IsInHandler = 0;
    512          }
    513          
    514          /*********************************************************************
    515          *
    516          *       JLINKDCC_SendChar
    517          *
    518          *  Function description
    519          *   Sends a single char to terminal out.
    520          */
    521          void JLINKDCC_SendChar(char c) {
    522            int Pos;
    523          
    524            Pos = _WrPos + 1;
    525            if (Pos == sizeof(_acBuffer)) {
    526              Pos = 0;
    527            }
    528            if (Pos == _RdPos) {
    529              return;
    530            }
    531            _acBuffer[_WrPos] = c;
    532            _WrPos = Pos;
    533          }
    534          
    535          /*********************************************************************
    536          *
    537          *       JLINKDCC_SendString
    538          *
    539          *  Function description
    540          *   Sends a NUL- terminated string to terminal out.
    541          */
    542          void JLINKDCC_SendString(const char * s) {
    543            char c;
    544            while (1) {
    545              c = *s++;
    546              if (c == 0) {
    547                break;
    548              }
    549              JLINKDCC_SendChar(c);
    550            }
    551          }
    552          
    553          /*********************************************************************
    554          *
    555          *       JLINKDCC_SendCharOnChannelNB
    556          *
    557          *  Function description
    558          *    Send data to the host on selected channel.
    559          *    This function is non-blocking.
    560          *    If data can not be send it is stored in a buffer
    561          *    and sent later, when the DCC Handler is called.
    562          */
    563          void JLINKDCC_SendCharOnChannelNB(unsigned Channel, U8 Data) {
    564            U32 DCCPacket;
    565            int DCCBusy;
    566          
    567            DCCPacket = 0x93800000 | (Channel << 16);
    568            DCCPacket |= Data;
    569            DCCBusy = _ReadDCCStat() & 2;
    570            if (DCCBusy == 0) {
    571              _WriteDCC(DCCPacket);
    572            } else {
    573              _WritePendingNB = 1;
    574              _PendingPacketNB = DCCPacket;
    575            }
    576            _ActiveChannel = Channel;
    577          }
    578          
    579          /*********************************************************************
    580          *
    581          *       JLINKDCC_SendOnChannel
    582          *
    583          *  Function description
    584          *    Send data to the host.
    585          *    32 channels are available, channel 0 is used for terminal output and is buffered,
    586          *    all other channels are unbuffered.
    587          */
    588          void JLINKDCC_SendOnChannel(unsigned Channel, U8 * pData, int NumItems) {
    589            U32 Data;
    590          
    591            if (Channel == DCC_CHANNEL_TERMINAL)  {
    592              while (NumItems-- > 0) {
    593                Data = *pData++;
    594                JLINKDCC_SendChar(Data);
    595              }
    596            } else {
    597              while (NumItems-- > 0) {
    598                Data = *pData++;
    599                if  (NumItems > 0) {
    600                  Data |= *pData++ << 8;
    601                  NumItems--;
    602                  Data |= 0x200000;
    603                }
    604                Data |= 0x93800000;
    605                Data |= Channel << 16;
    606                while (_ReadDCCStat() & 2);       // Wait until we can send data
    607                _WriteDCC(Data);
    608              }
    609            }
    610          }
    611          
    612          /*********************************************************************
    613          *
    614          *       JLINKDCC_SetpfOnRx
    615          *
    616          */
    617          void JLINKDCC_SetpfOnRx(unsigned Channel, void (* pf)(unsigned Channel, U8 Data)) {
    618            _pfOnRx[Channel] = pf;
    619          }
    620          
    621          /*********************************************************************
    622          *
    623          *       JLINKDCC_SetpfOnTx
    624          *
    625          */
    626          void JLINKDCC_SetpfOnTx(unsigned Channel, void (* pf)(unsigned Channel)) {
    627            _pfOnTx[Channel] = pf;
    628          }
    629          
    630          
    631          /*************************** end of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   JLINKDCC_Process
         8   -> _HandleRead
         8   -> _HandleWrite
       0   JLINKDCC_SendChar
      24   JLINKDCC_SendCharOnChannelNB
        24   -> _ReadDCCStat
        24   -> _WriteDCC
      24   JLINKDCC_SendOnChannel
        24   -> JLINKDCC_SendChar
        24   -> _ReadDCCStat
        24   -> _WriteDCC
      16   JLINKDCC_SendString
        16   -> JLINKDCC_SendChar
       0   JLINKDCC_SetpfOnRx
       0   JLINKDCC_SetpfOnTx
      16   _HandleRead
        16   -- Indirect call
        16   -> _ReadDCC
        16   -> _ReadDCCStat
      24   _HandleWrite
        24   -- Indirect call
        24   -> _ReadDCCStat
        24   -> _WriteDCC
       0   _ReadDCC
       0   _ReadDCCStat
       0   _WriteDCC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
       1  JLINKDCC_AbortOccurred
       1  JLINKDCC_IsInHandler
      56  JLINKDCC_Process
      76  JLINKDCC_SendChar
     104  JLINKDCC_SendCharOnChannelNB
     168  JLINKDCC_SendOnChannel
      56  JLINKDCC_SendString
      16  JLINKDCC_SetpfOnRx
      16  JLINKDCC_SetpfOnTx
       1  _ActiveChannel
       4  _Addr
       4  _Command
       4  _Data
     468  _HandleRead
     808  _HandleWrite
       2  _NumReadItems
       4  _PendingPacketNB
       2  _RdPos
       8  _ReadDCC
       8  _ReadDCCStat
       2  _WrPos
       8  _WriteDCC
       1  _WritePending
       1  _WritePendingNB
    1024  _acBuffer
       8  _pfOnRx
       8  _pfOnTx

 
 1 067 bytes in section .bss
 1 856 bytes in section .text
 
 1 856 bytes of CODE memory
 1 067 bytes of DATA memory

Errors: none
Warnings: none
