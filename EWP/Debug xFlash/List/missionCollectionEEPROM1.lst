###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        12/Oct/2015  11:05:03
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        projects\HR1_0100_00_I720_new2\callbackElement\missionCollectionEEPROM1.c
#    Command line =  
#        "D:\IAR
#        projects\HR1_0100_00_I720_new2\callbackElement\missionCollectionEEPROM1.c"
#        -D _STATIC_MEMORY_BOOT -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\List\missionCollectionEEPROM1.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\Obj\missionCollectionEEPROM1.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\callbackElement\missionCollectionEEPROM1.c
      1          #include "lpc_types.h"
      2          #include "lpc_irq_fiq.h"
      3          #include "lpc_arm922t_cp15_driver.h"
      4          
      5          #include "lpc32xx_hstimer.h"
      6          #include "lpc32xx_ssp.h"
      7          #include "lpc32xx_gpio.h"
      8          
      9          #include "lpc32xx_intc_driver.h"
     10          #include "lpc32xx_clkpwr_driver.h"
     11          
     12          #include "arm926ej_cp15_drv.h"
     13          #include "ttbl.h"
     14          
     15          
     16          #include <stdio.h>
     17          #include <string.h>
     18          
     19          #include "callbackelement\callbackelementdef.h"
     20          #include "callbackelement\ustrangEEPROMdef.h"
     21          
     22          #include "callbackelement\callbackelementfnc.h"
     23          #include "callbackelement\missionCollectionEEPROM.h"
     24          
     25          extern   HSTIMER_REGS_T *hst_regptr;  // Pointer to HSTIMER registers
     26          extern   SSP_REGS_T     *ssp1_regptr; // Pointer to SSP1 registers
     27          extern   GPIO_REGS_T    *gpio_regptr; // Pointer to GPIO registers
     28          extern CALLBACK_MISSION cb_missionDEVICE1;
     29          extern CALLBACK_MISSION *cb_mission_crrDEVICE1;//текущая миссия
     30          extern short  missionSeparatorDEVICE1;//сепаратор миссии
     31          
     32          void Build_cbMission_1BREAD_MASSIV(char *massiv, int srcB64, int dstB64)
     33          {
     34          //сформировать миссию чтения массива из EEPROM 
     35          int adrSrc = srcB64*64;//адрес чтения
     36          int adrDst = dstB64*64;//адрес в EEPROM
     37            if(cb_mission_crrDEVICE1->callBackMaxer<0)
     38            {
     39              missionSeparatorDEVICE1 = CBACK_MISSION_1BREAD_MASSIV;//номер миссии  EEPROM на 1 блок
     40              //1 задача
     41              OrderCallBack(cb_mission_crrDEVICE1, &callBackEEPROM_READ);//заказать новые задачи
     42              TASKMISSION_DEFINE1 tmDefine1 =
     43              {
     44                (void *)adrSrc,   //source
     45                &(massiv[adrDst]),//dest
     46                64//к-во
     47              };
     48              SetTaskParam1CallBack(cb_mission_crrDEVICE1, &tmDefine1);//параметры
     49            }//if(cb_mission_crrDEVICE1->callBackMaxer<0)
     50          }//Build_cbMission_8BREAD_MASSIV()
     51          
     52          void Build_cbMission_1BWRITE_MASSIV(char *massiv, int srcB64, int dstB64)
     53          {
     54          //сформировать миссию записи массива в EEPROM 
     55          int adrSrc = srcB64*64;//адрес источника
     56          int adrDst = dstB64*64;//адрес в EEPROM
     57            if(cb_mission_crrDEVICE1->callBackMaxer<0)
     58            {
     59              missionSeparatorDEVICE1 = CBACK_MISSION_1BWRITE_MASSIV;//номер миссии записи в EEPROM
     60              //1 задача
     61              OrderCallBack(cb_mission_crrDEVICE1, &callBackEEPROM_WRITE);//заказать новые задачи
     62              TASKMISSION_DEFINE1 tmDefine1 =
     63              {
     64                &(massiv[adrSrc]), //source
     65                (void *)adrDst,//dest
     66                64//к-во
     67              };
     68              SetTaskParam1CallBack(cb_mission_crrDEVICE1, &tmDefine1);//параметры
     69          
     70            }//if(cb_mission_crrDEVICE1->callBackMaxer<0)
     71          }//Build_cbMission_1BWRITE_MASSIV(char *massiv, int srcB64, int dstB64)
     72          
     73          void Build_cbMission_WRITE_USTALTER(char *massiv)//, int srcB64, int dstB64)
     74          {
     75          //сформировать миссию записи байта alter для уставок и ранжир
     76            if(cb_mission_crrDEVICE1->callBackMaxer<0)
     77            {
     78              missionSeparatorDEVICE1 = CBACK_MISSION_WRITE_ALTER;//номер миссии записи в EEPROM на 1 байт
     79              //1 задача
     80              OrderCallBack(cb_mission_crrDEVICE1, &callBackEEPROM_WRITE);//заказать новые задачи
     81              TASKMISSION_DEFINE1 tmDefine1 =
     82              {
     83                &(massiv[1]), //source
     84                (void *)0x1, //adrDst,//dest
     85                1//к-во
     86              };
     87              SetTaskParam1CallBack(cb_mission_crrDEVICE1, &tmDefine1);//параметры
     88          
     89            }//if(cb_mission_crrDEVICE1->callBackMaxer<0)
     90          }//Build_cbMission_WRITE_USTALTER(char *massiv)
     91          
     92          void FullStepWorkEEPROM(UNS_8 *data, short cntBytesArgument)
     93          //cntBytesArgument - к-во байт в аргументе
     94          {
     95          //полный шаг работы EEPROM
     96            gpio_regptr->p3_outp_clr = P3_STATE_GPIO(4);//cs EEPROM enable
     97            HalfStepWorkEEPROM_Middle(data, cntBytesArgument);//шаг работы EEPROM
     98            gpio_regptr->p3_outp_set = P3_STATE_GPIO(4);//cs EEPROM disable
     99          }//FullStepWorkEEPROM(UNS_8 *data, short cntBytesArgument)
    100          
    101          void HalfStepWorkEEPROM_Middle(UNS_8 *data, short cntBytesArgument)
    102          //cntBytesArgument - к-во байт в аргументе
    103          {
    104          //шаг работы EEPROM
    105            short n_fifo;
    106            short idx;
    107            short bytes;
    108          //transmit data
    109            n_fifo = cntBytesArgument;
    110            idx=0;
    111          //заполняем FIFO
    112            while ((n_fifo > 0) &&
    113                   ((ssp1_regptr->sr & SSP_SR_TNF) != 0))
    114            {
    115              ssp1_regptr->data = (UNS_32) data[idx];
    116              n_fifo--;
    117              idx++;
    118            }//while
    119          //ждем пока трансляция не закончится
    120            while (((ssp1_regptr->sr & SSP_SR_BSY) != 0)) {}
    121          
    122          //ждем принятые байты и записываем их в data
    123          //read data
    124            bytes = 0;
    125            idx=0;
    126            while (bytes < cntBytesArgument)
    127            {
    128              while (((ssp1_regptr->sr & SSP_SR_RNE) != 0))
    129              {
    130                data[idx] = (UNS_8) ssp1_regptr->data;//tmp1;
    131                idx++;
    132              }//while
    133              bytes++;
    134            }//while
    135          }//void HalfStepWorkEEPROM_Middle(UNS_8 *data, short cntBytesArgument)
    136          
    137          void HalfStepWorkEEPROM_Begin(UNS_8 *data, short cntBytesArgument)
    138          //cntBytesArgument - к-во байт в аргументе
    139          {
    140          //полу шаг работы EEPROM - начало
    141            gpio_regptr->p3_outp_clr = P3_STATE_GPIO(4);//cs EEPROM enable
    142            HalfStepWorkEEPROM_Middle(data, cntBytesArgument);//шаг работы EEPROM
    143          }//HalfStepWorkEEPROM_Begin(UNS_8 *data, short cntBytesArgument)
    144          
    145          void HalfStepWorkEEPROM_Ending()
    146          {
    147          //полу шаг работы EEPROM - закончить
    148            gpio_regptr->p3_outp_set = P3_STATE_GPIO(4);//cs EEPROM disable
    149          }//HalfStepWorkEEPROM_Ending()
    150          
    151          char callBackEEPROM_READ(CALLBACKELEMENT_TASK *cbt)
    152          {
    153          //TASK READ ARRAY
    154            union
    155            {
    156              void *p;
    157              short s;
    158            } pnt;
    159            UNS_8 data[5];
    160            short cntBytesArgument = 0;//к-во байт аргумента команды
    161            short addrEEPROM;//адрес EEPROM
    162            short idx = 1;
    163          
    164            pnt.p  = cbt->tmDefine.source;//адрес EEPROM
    165            addrEEPROM = pnt.s;//адрес EEPROM
    166            data [0] = 3;//op_cod
    167            data [1] = (addrEEPROM >> 8) & 0xFF;
    168            data [2] = (addrEEPROM >> 0) & 0xFF;
    169            data [3] = 0xFF;
    170            cntBytesArgument = 4;//к-во байт аргумента команды
    171            HalfStepWorkEEPROM_Begin(data, cntBytesArgument);//начало работы EEPROM
    172          
    173            cbt->tmDefine.count--;
    174            if(cbt->tmDefine.count>=0)
    175              ((UNS_8*)cbt->tmDefine.dest)[0] = data[3];
    176          
    177            while(cbt->tmDefine.count>0)
    178            {
    179              cntBytesArgument = 4;//к-во байт аргумента команды
    180              HalfStepWorkEEPROM_Middle(data, cntBytesArgument);//средина работы EEPROM
    181          
    182              cbt->tmDefine.count -= 4;
    183              if(cbt->tmDefine.count>=0)
    184              {
    185                ((UNS_8*)cbt->tmDefine.dest)[idx++] = data[0];
    186                ((UNS_8*)cbt->tmDefine.dest)[idx++] = data[1];
    187                ((UNS_8*)cbt->tmDefine.dest)[idx++] = data[2];
    188                ((UNS_8*)cbt->tmDefine.dest)[idx++] = data[3];
    189              }//if
    190              else
    191              {
    192                short max=cbt->tmDefine.count+4;
    193                for(short i=0; i<max; i++)
    194                  ((UNS_8*)cbt->tmDefine.dest)[idx++] = data[i];
    195                HalfStepWorkEEPROM_Ending();//закончить работу EEPROM
    196                return 0;//покинуть CallBackElement
    197              }//else
    198            }//while(cbt->tmDefine.count>0)
    199          
    200            HalfStepWorkEEPROM_Ending();//закончить работу EEPROM
    201          
    202            return 0;//покинуть CallBackElement
    203          }//callBackEEPROM_READ(CALLBACKELEMENT_TASK *cbt)
    204          
    205          char callBackEEPROM_WRITE(CALLBACKELEMENT_TASK *cbt)
    206          {
    207          //TASK WRITE ARRAY
    208            union
    209            {
    210              void *p;
    211              short s;
    212            } pnt;
    213            UNS_8 data[5];
    214            short cntBytesArgument = 0;//к-во байт аргумента команды
    215            short addrEEPROM;//адрес EEPROM
    216            UNS_8 data8EEPROM;//данные EEPROM
    217            short idx = 1;
    218          
    219            switch(cbt->callBackStepCntr)
    220            {
    221            case TASK_STEP0:
    222            {
    223          //Set Write Enable Latch
    224              data[0] = 6;//op_cod
    225              cntBytesArgument = 1;//к-во байт аргумента команды
    226              FullStepWorkEEPROM(data, cntBytesArgument);//полный шаг работы EEPROM
    227          
    228          //READ STATUS REGISTER
    229              data[0] = 5;//op_cod
    230              data[1] = 0xFF;
    231              cntBytesArgument = 2;//к-во байт аргумента команды
    232              FullStepWorkEEPROM(data, cntBytesArgument);//полный шаг работы EEPROM
    233              
    234              if(data[1]!=2){
    235                //отказ EEPROM
    236                cbt->callBackStepCntr--;
    237                return 1;//остаться в CallBackElement
    238              }//if
    239          
    240          //WRITE ARRAY
    241              cbt->tmDefine.count--;
    242          
    243              UNS_8 *source  = (UNS_8 *)cbt->tmDefine.source;//адрес массива
    244          
    245              pnt.p  = cbt->tmDefine.dest;//адрес EEPROM
    246              addrEEPROM = pnt.s;//адрес EEPROM
    247              if(cbt->tmDefine.count>=0)
    248              {
    249                data8EEPROM = source[0];//данные EEPROM
    250                data [0] = 2;//op_cod
    251                data [1] = (addrEEPROM >> 8) & 0xFF;
    252                data [2] = (addrEEPROM >> 0) & 0xFF;
    253                data [3] = data8EEPROM;
    254                cntBytesArgument = 4;//к-во байт аргумента команды
    255                HalfStepWorkEEPROM_Begin(data, cntBytesArgument);//начало работы EEPROM
    256              }//if
    257          
    258              while(cbt->tmDefine.count>0)
    259              {
    260                cbt->tmDefine.count -= 4;
    261                if(cbt->tmDefine.count>=0)
    262                {
    263                  data[0] = source[idx++];
    264                  data[1] = source[idx++];
    265                  data[2] = source[idx++];
    266                  data[3] = source[idx++];
    267                  cntBytesArgument = 4;//к-во байт аргумента команды
    268                  HalfStepWorkEEPROM_Middle(data, cntBytesArgument);//средина работы EEPROM
    269                }//if
    270                else
    271                {
    272                  short max=cbt->tmDefine.count+4;
    273                  for(short i=0; i<max; i++)
    274                  {
    275                    data[i] = source[idx++];//0x66;
    276                  }//for
    277                  cntBytesArgument = max;//к-во байт аргумента команды
    278                  HalfStepWorkEEPROM_Middle(data, cntBytesArgument);//средина работы EEPROM
    279                }//else
    280              }//while(cbt->tmDefine.count>0)
    281              HalfStepWorkEEPROM_Ending();//закончить работу EEPROM
    282            }
    283            break;
    284          
    285            default:
    286            {
    287          //READ STATUS REGISTER
    288              data[0] = 5;//op_cod
    289              data[1] = 0xFF;
    290              cntBytesArgument = 2;//к-во байт аргумента команды
    291              FullStepWorkEEPROM(data, cntBytesArgument);//полный шаг работы EEPROM
    292              if((data[1]&1)==0)
    293                return 0;//покинуть CallBackElement
    294            };
    295            }//switch
    296          
    297            return 1;//остаться в CallBackElement
    298          }//

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   Build_cbMission_1BREAD_MASSIV
        40   -> OrderCallBack
        40   -> SetTaskParam1CallBack
      40   Build_cbMission_1BWRITE_MASSIV
        40   -> OrderCallBack
        40   -> SetTaskParam1CallBack
      24   Build_cbMission_WRITE_USTALTER
        24   -> OrderCallBack
        24   -> SetTaskParam1CallBack
      16   FullStepWorkEEPROM
        16   -> HalfStepWorkEEPROM_Middle
      16   HalfStepWorkEEPROM_Begin
        16   -> HalfStepWorkEEPROM_Middle
       0   HalfStepWorkEEPROM_Ending
       8   HalfStepWorkEEPROM_Middle
      40   callBackEEPROM_READ
        40   -> HalfStepWorkEEPROM_Begin
        40   -> HalfStepWorkEEPROM_Ending
        40   -> HalfStepWorkEEPROM_Middle
      48   callBackEEPROM_WRITE
        48   -> FullStepWorkEEPROM
        48   -> HalfStepWorkEEPROM_Begin
        48   -> HalfStepWorkEEPROM_Ending
        48   -> HalfStepWorkEEPROM_Middle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
      12  ?_0
      12  ?_1
      12  ?_2
     132  Build_cbMission_1BREAD_MASSIV
     132  Build_cbMission_1BWRITE_MASSIV
     112  Build_cbMission_WRITE_USTALTER
      68  FullStepWorkEEPROM
      52  HalfStepWorkEEPROM_Begin
      20  HalfStepWorkEEPROM_Ending
     224  HalfStepWorkEEPROM_Middle
     436  callBackEEPROM_READ
     620  callBackEEPROM_WRITE

 
    36 bytes in section .rodata
 1 828 bytes in section .text
 
 1 828 bytes of CODE  memory
    36 bytes of CONST memory

Errors: none
Warnings: none
