###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        12/Oct/2015  11:05:10
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\virtualMenu\ViewMenuCnf.c
#    Command line =  
#        "D:\IAR projects\HR1_0100_00_I720_new2\virtualMenu\ViewMenuCnf.c" -D
#        _STATIC_MEMORY_BOOT -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\List\ViewMenuCnf.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\Obj\ViewMenuCnf.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\virtualMenu\ViewMenuCnf.c
      1          /*
      2          #include <vcl.h>
      3          #include <strstrea.h>
      4          #include <math.h>
      5          #include <mem.h>
      6          #include <fstream.h>
      7          #include <strstrea.h>
      8          #include <iomanip.h>
      9          #pragma hdrstop
     10          
     11          #include "vmenuDis.h"
     12          */
     13          
     14          #include <stdio.h>
     15          #include <string.h>
     16          
     17          #include "bazisdef.h"
     18          #include "component\componentdef.h"
     19          #include "virtualMenu\textstreamdef.h"
     20          #include "virtualMenu\systemmenudef.h"
     21          
     22          #include "virtualMenu\textstreamfnc.h"
     23          #include "virtualMenu\systemmenufnc.h"
     24          
     25          #include "virtualMenu\repozitfnc.h"
     26          #include "virtualMenu\viewMenuSub.h"
     27          
     28          #include "..\bazis.h"
     29          
     30          extern LineMenuItem sub_menu_tmp[];
     31          extern COMPONENT_OBJ rpzcomponent_obj;//обект компонента для репозитария
     32          
     33          //массив клонов - конфигурация
     34          extern COMPONENT_OBJ  cnfCOMPONENT[];
     35          extern COMPONENT_OBJ  cnfCOMPONENT_WL[];
     36          extern LineMenuItem sub_menu_cnf[];
     37          extern LineMenuItem sub_menu_cnfwl[];
     38          extern LineMenuItem sub_menu_rpz[];
     39          
     40          char addComp[] = "Добавить компонент...";
     41          char deleteComp[] = "Удалить компонент...";
     42          char deleteComp_WL[] = "Удалить из РЛ...";
     43          
     44          void ResetConfig()
     45          {
     46          //обнулить конфиграцию
     47            cnfCOMPONENT[0].componentEnable = 0;
     48            sub_menu_cnf[1+SUBDATA].Line1 = addComp;
     49            sub_menu_cnf[1+SUBDATA].Line2 = (void*)RpzComponent;
     50            sub_menu_cnf[1+SUBDATA].TypesWin = typeMenuProg;
     51          
     52            sub_menu_cnf[1+1+SUBDATA].Line1 = NULL;
     53            sub_menu_cnf[1+1+SUBDATA].Line2 = NULL;
     54          }//ResetConfig()
     55          
     56          void PereinitCnf(short flg)
     57          {
     58          //переинит конфигурации
     59            TxtStreamInit(&CONTROL_CNF,
     60                          &KadrMenuFormat_sub, sub_menu_cnf);//инит control и формир кадра
     61          
     62            PNTCRR_TEXTSTREAM->PntStringViewer = 0;
     63            if(flg==0)//END
     64            {
     65              TxtStreamSetEnd(&CONTROL_CNF, SIZE_PAGE_VIEW);//перейти на END
     66            }//if
     67            ViewDiskrMenu(typeMenuSub);//вывести окно отображения
     68            LanderPStr();//размещение указателя строки
     69          }//PereinitCnf()
     70          
     71          void OpenMenuCnf()
     72          {
     73          //открыть меню cnf
     74            TxtStreamCorrect(CRR_TEXTSTREAM);//коррекция текущий control
     75          
     76          //  CRR_TEXTSTREAM = &CONTROL_CNF;//новый текущий control
     77            SelectorTEXTCONTROL(&CONTROL_CNF);//новый текущий control
     78            PereinitCnf(1);//ф-ция переинит конфигурации
     79          //  CRR_FHOME = &PereinitCnf;//указатель на ф-цию HOME
     80            SelectorFHOME(&PereinitCnf);//указатель на ф-цию HOME
     81          }//OpenMenuCnf()
     82          
     83          void PereinitAvaitCnf(short flg)
     84          {
     85          //переиниц
     86            TxtStreamInit(&CONTROL_RPZ, &KadrMenuFormat_sub, sub_menu_rpz);//инит control и формир кадра
     87            if(flg==0)//END
     88            {
     89              TxtStreamSetEnd(&CONTROL_RPZ, SIZE_PAGE_VIEW);//перейти на END
     90            }//if
     91            ViewDiskrMenu(typeMenuCnf);//вывести окно отображения
     92            LanderPStr();//размещение указателя строки
     93          }//PereinitAvaitCnf()
     94          
     95          short SearchCnfClonComponent(short kC)
     96          {
     97          //искать в cnf к-во клонов данного компонента
     98            short next = 0;
     99            short cntC = 0;//к-во клонов компонента
    100            while (cnfCOMPONENT[next].componentEnable)   //все компоненты в конфигурации
    101            {
    102              if(cnfCOMPONENT[next].kodC==kC) cntC++;
    103              next++;
    104            }//while
    105            return cntC;
    106          }//SearchCnfClonComponent(short kC)
    107          
    108          short SearchCnfClonToComponent(short kC, short nC)
    109          {
    110          //искать в cnf данный клон данного компонента
    111            short next = 0;
    112            short idxC = -1;//индекс компонента в cnf
    113            while (cnfCOMPONENT[next].componentEnable)   //все компоненты в конфигурации
    114            {
    115          //   short tt1 = cnfCOMPONENT[next].kodC;
    116          //   short tt2 = cnfCOMPONENT[next].numClon;
    117              if(cnfCOMPONENT[next].kodC==kC && cnfCOMPONENT[next].numClon==nC )
    118                idxC = next;
    119              next++;
    120            }//while
    121            return idxC;
    122          }//SearchCnfClonToComponent(short kC, short nC)
    123          
    124          short SearchCnfClonToComponent_WL(short kC, short nC)
    125          {
    126          //искать в cnf РЛ данный клон данного компонента
    127            short next = 0;
    128            short idxC = -1;//индекс компонента в cnf
    129            while (cnfCOMPONENT_WL[next].componentEnable)   //все компоненты в конфигурации
    130            {
    131          //   short tt1 = cnfCOMPONENT[next].kodC;
    132          //   short tt2 = cnfCOMPONENT[next].numClon;
    133              if(cnfCOMPONENT_WL[next].kodC==kC && cnfCOMPONENT_WL[next].numClon==nC )
    134                idxC = next;
    135              next++;
    136            }//while
    137            return idxC;
    138          }//SearchCnfClonToComponent_WL(short kC, short nC)
    139          
    140          void  ConfigMaker()
    141          {
    142            /*
    143          //заполнить конфигурацию
    144          //  LIGHTLINEMENU = TxtStreamIdxKadr(CRR_TEXTSTREAM);//индекс тек кадра
    145            SelectorCRRLIGHTLINE();//найти подсвеченную строку текущего текст потока
    146            short numK = GetKodCompRpz(LIGHTLINEMENU);//получить из номера строки репозитария код компонента
    147          
    148            sub_menu_tmp[SUBDATA].Line2 = &sub_menu_cnf;// parent
    149          //  CRR_SUBMENU = sub_menu_tmp;//текущее субменю
    150            SelectorSUBMENU(sub_menu_tmp);//уcтановить текущее субменю
    151          
    152            AddCompIzRpz(numK);//добавить компонент из репозитария
    153          
    154            FvmenuDis->Str1Label->Caption = "Компонент";
    155            FvmenuDis->Str2Label->Caption = (char *)sub_menu_cnf[1+SUBDATA].Line1;
    156            FvmenuDis->Str3Label->Caption = "добавлен";
    157            FvmenuDis->Str4Label->Caption = "";
    158          
    159            ResetAllButton();//погасить все клавиши
    160          */
    161          }//ConfigMaker()
    162          /*
    163          void __fastcall TFvmenuDis::ConfirmDeleteButtonClick(TObject *Sender)
    164          {
    165            ConfirmDeleteButton();
    166            ResetUpDown(); //погасить Up Down
    167          }//ConfirmDeleteButton(TObject *Sender)
    168          
    169          void __fastcall TFvmenuDis::ConfirmDeleteButtonWLClick(TObject *Sender)
    170          {
    171            ConfirmDeleteButton_WL();//удалить из РЛ
    172            ResetUpDown(); //погасить Up Down
    173          }//ConfirmDeleteButtonWLClick(TObject *Sender)
    174          */
    175          void newsub_menu_cnf_Line1()
    176          {
    177          //новые имена меню cnf
    178          //в меню cnf присутствуют только имена тех клонов поле.packet которых или=0 или<0
    179          /*
    180            short i=1+SUBDATA;//2;
    181            short dx=0;
    182            while(cnfCOMPONENT[dx].componentEnable)
    183            {
    184              if(cnfCOMPONENT[dx].packet==0)
    185              {
    186                sub_menu_cnf[i].Line1 = cnfCOMPONENT[dx].nameComponent;
    187                i++;
    188              }//if
    189              if(cnfCOMPONENT[dx].packet<0) //начало пакета
    190              {
    191                short ii=0;//искать имя пакета
    192                while(cnfCOMPONENT[dx].nameComponent[ii]!=0)
    193                {
    194                  ii++;
    195                }
    196                ii++;
    197                sub_menu_cnf[i].Line1 = &(cnfCOMPONENT[dx].nameComponent[ii]);
    198                i++;
    199              }//if
    200              dx++;
    201            }//while
    202          */
    203          }//newsub_menu_cnf_Line1()
    204          
    205          short GetFromLinToClonCnf(short lin)
    206          {
    207          //получить из номера линии номер клона для cnf
    208          /*
    209            short dx=0;//индекс текущего клона
    210            short tmpCnfLin = lin;
    211            short bazaPkt=0;
    212            short pkt=0;
    213            short cntNoPkt=0;//к-во непакетов
    214            short nC=0;//номер клона
    215          
    216            //считать пакетную базу
    217            while (cnfCOMPONENT[dx].componentEnable)   //все компоненты в конфигурации
    218            {
    219              pkt = cnfCOMPONENT[dx].packet;
    220              if(pkt<0)
    221              {
    222                tmpCnfLin--;
    223                if(tmpCnfLin>=0)
    224                  bazaPkt += -pkt;
    225              }//if
    226              if(pkt==0)
    227              {
    228                tmpCnfLin--; //if
    229              }
    230          
    231              if(tmpCnfLin<0) break;
    232              dx++;
    233            }//while
    234          
    235            tmpCnfLin=lin;
    236            dx=0;
    237            //считать непакеты
    238            while (cnfCOMPONENT[dx].componentEnable)   //все компоненты в конфигурации
    239            {
    240              pkt = cnfCOMPONENT[dx].packet;
    241              if(pkt<0)
    242              {
    243                tmpCnfLin--; //if
    244              }
    245              if(pkt==0)
    246              {
    247                tmpCnfLin--;
    248                if(tmpCnfLin>=0) cntNoPkt++;
    249              }//if
    250          
    251              if(tmpCnfLin<0) break;
    252              dx++;
    253            }//while
    254          
    255            nC= bazaPkt+cntNoPkt;//номер клона
    256          
    257            return nC;
    258          */
    259           return 0;
    260          }//GetFromLinToClonCnf(short lin)
    261          
    262          short GetFromLinToClonCnf_WL(short lin)
    263          {
    264          /*
    265          //получить из номера линии номер клона для cnf РЛ
    266            short dx=0;//индекс текущего клона
    267            short tmpCnfLin = lin;
    268            short bazaPkt=0;
    269            short pkt=0;
    270            short cntNoPkt=0;//к-во непакетов
    271            short nC=0;//номер клона
    272          
    273            //считать пакетную базу
    274            while (cnfCOMPONENT_WL[dx].componentEnable)   //все компоненты в конфигурации
    275            {
    276              pkt = cnfCOMPONENT_WL[dx].packet;
    277              if(pkt<0)
    278              {
    279                tmpCnfLin--;
    280                if(tmpCnfLin>=0)
    281                  bazaPkt += -pkt;
    282              }//if
    283              if(pkt==0)
    284              {
    285                tmpCnfLin--; //if
    286              }
    287          
    288              if(tmpCnfLin<0) break;
    289              dx++;
    290            }//while
    291          
    292            tmpCnfLin=lin;
    293            dx=0;
    294            //считать непакеты
    295            while (cnfCOMPONENT_WL[dx].componentEnable)   //все компоненты в конфигурации
    296            {
    297              pkt = cnfCOMPONENT_WL[dx].packet;
    298              if(pkt<0)
    299              {
    300                tmpCnfLin--; //if
    301              }
    302              if(pkt==0)
    303              {
    304                tmpCnfLin--;
    305                if(tmpCnfLin>=0) cntNoPkt++;
    306              }//if
    307          
    308              if(tmpCnfLin<0) break;
    309              dx++;
    310            }//while
    311          
    312            nC= bazaPkt+cntNoPkt;//номер клона
    313          
    314            return nC;
    315          */
    316           return 0;
    317          }//GetFromLinToClonCnf_WL(short lin)
    318          
    319          short GetFromLinToClonPkt(short Lin)
    320          {
    321          /*
    322          //получить из номера линии номер клона для пакета
    323            //индекс текущего клона
    324            short dx=0;
    325            short bazaPkt=0;
    326            short pkt=0;
    327            short cntNoPkt=0;//к-во непакетов
    328            short shiftPkt = 0;//смещение внутри пакета
    329            short nC=0;//номер клона
    330          
    331            short cnfLin = TxtStreamIdxKadr(&CONTROL_CNF);//кадр конфигурации
    332            short tmpCnfLin = cnfLin;
    333          
    334            shiftPkt = Lin;//смещение внутри пакета
    335            //считать пакетную базу
    336            while (cnfCOMPONENT[dx].componentEnable)   //все компоненты в конфигурации
    337            {
    338              pkt = cnfCOMPONENT[dx].packet;
    339              if(pkt<0)
    340              {
    341                tmpCnfLin--;
    342                if(tmpCnfLin>=0)
    343                  bazaPkt += -pkt;
    344              }//if
    345              if(pkt==0)
    346              {
    347                tmpCnfLin--; //if
    348              }
    349          
    350              if(tmpCnfLin<0) break;
    351              dx++;
    352            }//while
    353          
    354            tmpCnfLin=cnfLin;//кадр конфигурации
    355            dx=0;
    356            //считать непакеты
    357            while (cnfCOMPONENT[dx].componentEnable)   //все компоненты в конфигурации
    358            {
    359              pkt = cnfCOMPONENT[dx].packet;
    360              if(pkt<0)
    361              {
    362                tmpCnfLin--; //if
    363              }
    364              if(pkt==0)
    365              {
    366                tmpCnfLin--;  //if
    367                cntNoPkt++;
    368              }
    369          
    370              if(tmpCnfLin<0) break;
    371              dx++;
    372            }//while
    373          
    374          
    375            nC= bazaPkt+cntNoPkt +shiftPkt;//номер клона
    376            return nC;
    377          */
    378           return 0;
    379          }//
    380          
    381          void newsub_menu_cnfwl_Line1()
    382          {
    383          //новые имена меню cnfwl
    384          //в меню cnf присутствуют только имена тех клонов поле.packet которых или=0 или<0
    385            short i=1+SUBDATA;
    386            short dx=0;
    387            while(cnfCOMPONENT_WL[dx].componentEnable)
    388            {
    389              if(cnfCOMPONENT_WL[dx].packet==0)
    390              {
    391                sub_menu_cnfwl[i].Line1 = cnfCOMPONENT_WL[dx].nameComponent;
    392                i++;
    393              }//if
    394              if(cnfCOMPONENT_WL[dx].packet<0) //начало пакета
    395              {
    396                short ii=0;//искать имя пакета
    397                while(cnfCOMPONENT_WL[dx].nameComponent[ii]!=0)
    398                {
    399                  ii++;
    400                }
    401                ii++;
    402                sub_menu_cnfwl[i].Line1 = &(cnfCOMPONENT_WL[dx].nameComponent[ii]);
    403                i++;
    404              }//if
    405              dx++;
    406            }//while
    407          }//newsub_menu_cnfwl_Line1()
    408          
    409          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ConfigMaker
       0   GetFromLinToClonCnf
       0   GetFromLinToClonCnf_WL
       0   GetFromLinToClonPkt
       8   OpenMenuCnf
         8   -> PereinitCnf
         8   -> SelectorFHOME
         8   -> SelectorTEXTCONTROL
         8   -> TxtStreamCorrect
       8   PereinitAvaitCnf
         8   -> LanderPStr
         8   -> TxtStreamInit
         8   -> TxtStreamSetEnd
         8   -> ViewDiskrMenu
       8   PereinitCnf
         8   -> LanderPStr
         8   -> TxtStreamInit
         8   -> TxtStreamSetEnd
         8   -> ViewDiskrMenu
       0   ResetConfig
       4   SearchCnfClonComponent
       8   SearchCnfClonToComponent
       8   SearchCnfClonToComponent_WL
       0   newsub_menu_cnf_Line1
       8   newsub_menu_cnfwl_Line1


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
       4  ConfigMaker
      12  GetFromLinToClonCnf
      12  GetFromLinToClonCnf_WL
      12  GetFromLinToClonPkt
      44  OpenMenuCnf
      72  PereinitAvaitCnf
      88  PereinitCnf
      76  ResetConfig
     116  SearchCnfClonComponent
     160  SearchCnfClonToComponent
     160  SearchCnfClonToComponent_WL
      24  addComp
      24  deleteComp
      20  deleteComp_WL
       4  newsub_menu_cnf_Line1
     324  newsub_menu_cnfwl_Line1

 
    68 bytes in section .data
 1 128 bytes in section .text
 
 1 128 bytes of CODE memory
    68 bytes of DATA memory

Errors: none
Warnings: none
