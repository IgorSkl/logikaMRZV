###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Oct/2015  12:49:46
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\zonaVRT\toSpeedZonaVRT.c
#    Command line =  
#        "D:\IAR projects\HR1_0100_00_I720_new2\zonaVRT\toSpeedZonaVRT.c" -D
#        _STATIC_MEMORY_BOOT -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\Obj\" --debug
#        --endian=little --cpu=ARM926EJ-S -e --fpu=VFP9-S --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --cpu_mode arm -Ohs
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\List\toSpeedZonaVRT.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\Obj\toSpeedZonaVRT.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\zonaVRT\toSpeedZonaVRT.c
      1          /*
      2          #include <vcl.h>
      3          #include <strstrea.h>
      4          #include <math.h>
      5          #pragma hdrstop
      6          */
      7          
      8          #include <stdio.h>
      9          #include <string.h>
     10          #include <math.h>
     11          
     12          #include "zonaVRTdef.h"
     13          #include "zonaVRTfnc.h"
     14          
     15          
     16          extern INT_64 X1_64, Y1_64, X2_64, Y2_64, X3_64, Y3_64, X4_64, Y4_64;
     17          extern INT_64 X14V_64, Y14V_64, X21V_64, Y21V_64, X32V_64, Y32V_64, X41V_64, Y41V_64;
     18          extern    INT_64 X13V_64, Y13V_64;
     19          
     20          extern INT_64 koordXZ_64, koordYZ_64;
     21          
     22          extern VectorXY_64   nVector34_64vrtBD[];//для хранения зон для 5 ступеней
     23          extern VectorXY_64   nVector32_64vrtBD[];
     24          extern VectorXY_64   nVector12_64vrtBD[];
     25          extern VectorXY_64   nVector14_64vrtBD[];
     26          
     27          extern VectorXY_64   nVector41_64vrtBD[];
     28          extern VectorXY_64   nVector43_64vrtBD[];
     29          extern VectorXY_64   nVector23_64vrtBD[];
     30          extern VectorXY_64   nVector21_64vrtBD[];
     31          extern VectorXY_64   nVector31_64vrtBD[];
     32          extern VectorXY_64   nVector13_64vrtBD[];
     33          
     34          extern INT_64  zonaVertexBD[];//4 *2 *5 *2*2];//массив вершин 
     35          
     36          extern int isZonaBD[];//попадание в зону ДЗ
     37          
     38          //текущие уставки супервизора
     39          extern int    spvUSTAVKI[];
     40          
     41          int isViewZMethod_64VRT(/*int off_spv,*/ int numClon, int idxIsZona) @ "Fast_function"
     42          {
     43           VectorXY_64   *nVector34_64vrt = &nVector34_64vrtBD[numClon];
     44          //нормализованный вектор сработки 32
     45           VectorXY_64   *nVector32_64vrt = &nVector32_64vrtBD[numClon];
     46          //нормализованный вектор сработки 12
     47           VectorXY_64   *nVector12_64vrt = &nVector12_64vrtBD[numClon];
     48          //нормализованный вектор сработки 14
     49           VectorXY_64   *nVector14_64vrt = &nVector14_64vrtBD[numClon];
     50          
     51          //нормализованный вектор сработки 41
     52           VectorXY_64   *nVector41_64vrt = &nVector41_64vrtBD[numClon];
     53          //нормализованный вектор сработки 43
     54           VectorXY_64   *nVector43_64vrt = &nVector43_64vrtBD[numClon];
     55          //нормализованный вектор сработки 23
     56           VectorXY_64   *nVector23_64vrt = &nVector23_64vrtBD[numClon];
     57          //нормализованный вектор сработки 21
     58           VectorXY_64   *nVector21_64vrt = &nVector21_64vrtBD[numClon];
     59          
     60           INT_64 *zonaVertex = &zonaVertexBD[numClon*16];//4 *2 *5 *2*2];//массив вершин 
     61          
     62          //работа с SPV массивом
     63          //целочисленный вариант
     64          //вычислить попадание вектора Z в зону
     65          //координаты приведенного вектора сработки Z3
     66             VectorXY_64  vectorZ3_64;
     67          //координаты приведенного вектора сработки Z1
     68             VectorXY_64  vectorZ1_64;
     69          //координаты приведенного вектора сработки Z4
     70             VectorXY_64  vectorZ4_64;
     71          //координаты приведенного вектора сработки Z2
     72             VectorXY_64  vectorZ2_64;
     73          
     74            INT_64 nMinZ_64;//минимальный нормализованный Z
     75            INT_64 XA_64, YA_64, XB_64, YB_64, XC_64, YC_64, XD_64, YD_64;
     76          
     77          //  if (TrianCheckBox->Checked) return isViewZTrianMethod_64();//треугольник
     78          
     79          //работа с SPV массивом
     80          // INT_64 *zonaSPV_64 = (INT_64 *)(&spvUSTAVKI[off_spv]);//(&zonaSPV[33]);
     81          //  else
     82            if (isZonaBD[idxIsZona])//попадание в зону ДЗ
     83          //isZona)
     84            {
     85              XA_64 = zonaVertex[iX14V_64];//X14V_64;
     86              YA_64 = zonaVertex[iY14V_64];//Y14V_64;
     87              XB_64 = zonaVertex[iX21V_64];//X21V_64;
     88              YB_64 = zonaVertex[iY21V_64];//Y21V_64;
     89              XC_64 = zonaVertex[iX32V_64];//X32V_64;
     90              YC_64 = zonaVertex[iY32V_64];//Y32V_64;
     91              XD_64 = zonaVertex[iX41V_64];//X41V_64;
     92              YD_64 = zonaVertex[iY41V_64];//Y41V_64;
     93            }//if (isZona)
     94             else
     95            {
     96              XA_64 = zonaVertex[iX1_64];//X1_64;
     97              YA_64 = zonaVertex[iY1_64];//Y1_64;
     98              XB_64 = zonaVertex[iX2_64];//X2_64;
     99              YB_64 = zonaVertex[iY2_64];//Y2_64;
    100              XC_64 = zonaVertex[iX3_64];//X3_64;
    101              YC_64 = zonaVertex[iY3_64];//Y3_64;
    102              XD_64 = zonaVertex[iX4_64];//X4_64;
    103              YD_64 = zonaVertex[iY4_64];//Y4_64;
    104            }//else
    105          
    106          //вычислить координаты приведенного вектора сработки Z3
    107          //целочисленный вариант
    108            makeOporVectorZ_64VRT(XC_64, YC_64, &vectorZ3_64);
    109          //целочисленный вариант
    110            nMinZ_64 = makeLenVector_64VRT(&vectorZ3_64);//минимальный нормализованный Z
    111          //вычислить координаты приведенного вектора сработки Z1
    112            makeOporVectorZ_64VRT(XA_64, YA_64, &vectorZ1_64);
    113            INT_64 tmpLen_64 = makeLenVector_64VRT(&vectorZ1_64);
    114          
    115            if (nMinZ_64>tmpLen_64)
    116                  nMinZ_64 = tmpLen_64;
    117          //вычислить координаты приведенного вектора сработки Z4
    118            makeOporVectorZ_64VRT(XD_64, YD_64, &vectorZ4_64);
    119          //вычислить координаты приведенного вектора сработки Z2
    120            makeOporVectorZ_64VRT(XB_64, YB_64, &vectorZ2_64);
    121          
    122            INT_64 lenZ2_64 = makeLenVector_64VRT(&vectorZ2_64);
    123            INT_64 lenZ4_64 = makeLenVector_64VRT(&vectorZ4_64);
    124          
    125          //  printLenVector(isZona);//отобразить длину векторов
    126          
    127            int axes31 = 0;//активный осевой вектор 31
    128            if (!(nMinZ_64<lenZ2_64 && nMinZ_64<lenZ4_64)) axes31 = 1;//активный осевой вектор 31
    129          
    130            int isSectorCA = 0;//false;
    131            int isSectorDB = 0;//false;
    132          //  if (!errorZona) //ошибка расположения вершин зоны
    133          //  {
    134              if (axes31)   //активный осевой вектор 31
    135              {
    136                if (isSectorZ_64VRT(&vectorZ3_64, nVector34_64vrt, nVector32_64vrt) &&
    137                    isSectorZ_64VRT(&vectorZ1_64, nVector12_64vrt, nVector14_64vrt)) isSectorCA = 1;//true;
    138              }//if
    139              else
    140              {
    141                if (isSectorZ_64VRT(&vectorZ4_64, nVector41_64vrt, nVector43_64vrt) &&
    142                    isSectorZ_64VRT(&vectorZ2_64, nVector23_64vrt, nVector21_64vrt)) isSectorDB = 1;//true;
    143              }//else
    144          //    if (isZona)
    145               if (isZonaBD[idxIsZona])//попадание в зону ДЗ
    146              {
    147                //вычислить  возврат
    148          //      if ((isSectorCA | isSectorDB)==0) isZona = 0;//false;
    149                if (isSectorCA | isSectorDB);
    150          //      else isZona = 0;
    151                else isZonaBD[idxIsZona] = 0;//попадание в зону ДЗ
    152              }
    153               else
    154              {
    155                //вычислить сработку
    156          //      isZona = isSectorCA | isSectorDB;
    157                  isZonaBD[idxIsZona] = isSectorCA | isSectorDB;//попадание в зону ДЗ
    158              }
    159              return isZonaBD[idxIsZona];//isZona;
    160          }//isViewZMethod_64()
    161          
    162          int isSectorZ_64VRT(VectorXY_64 *oporZ, VectorXY_64 *nVectorLow, VectorXY_64 *nVectorHi) @ "Fast_function"
    163          {
    164          //вычислить попадание в сектор опорного Z
    165          //синус вектора с углом ALFA - BETA
    166          //float Rez1 =
    167            if (
    168              oporZ->yVect_64 * nVectorLow->xVect_64 - oporZ->xVect_64 * nVectorLow->yVect_64>0 &&
    169          //float Rez2 =
    170              oporZ->yVect_64 * nVectorHi->xVect_64  - oporZ->xVect_64 * nVectorHi->yVect_64<0) return 1;//true;
    171          
    172            return 0;//false;
    173          }//isSectorZ(
    174          
    175          void makeOporVectorZ_64VRT(INT_64 xOpor_64, INT_64 yOpor_64, VectorXY_64 *oporZ_64) @ "Fast_function"
    176          {
    177          //целочисленный вариант
    178          //вычислить приведенный Z
    179          //xOpor, yOpor - опорная точка
    180            oporZ_64 ->  xVect_64 = koordXZ_64 - xOpor_64;
    181            oporZ_64 ->  yVect_64 = koordYZ_64 - yOpor_64;
    182          }//makeOporVectorZ_64(INT_64 xOpor, INT_64 yOpor, VectorXY_64 *oporZ_64)
    183          
    184          INT_64 makeLenVector_64VRT(VectorXY_64 *oporZ_64) @ "Fast_function"
    185          {
    186          //вычислить длину приведенного Z
    187          //  return makeLenVector_64(oporZ_64->xVect_64, oporZ_64->yVect_64);
    188            return oporZ_64->xVect_64 * oporZ_64->xVect_64 + oporZ_64->yVect_64 * oporZ_64->yVect_64;//xn*xn+yn*yn;
    189          
    190          }//makeLenVector_64(VectorXY_64 *oporZ_64)
    191          
    192          int isViewZTrianMethod_64VRT(int numClon, int idxIsZona)  @ "Fast_function"
    193          {
    194          ///*
    195          //восстановить нормализ вектора
    196          //для хранения зон для 5 ступеней
    197          
    198          // VectorXY_64   *nVector34_64vrt = &nVector34_64vrtBD[numClon];
    199          //нормализованный вектор сработки 32
    200           VectorXY_64   *nVector32_64vrt = &nVector32_64vrtBD[numClon];
    201          //нормализованный вектор сработки 12
    202           VectorXY_64   *nVector12_64vrt = &nVector12_64vrtBD[numClon];
    203          //нормализованный вектор сработки 14
    204          // VectorXY_64   *nVector14_64vrt = &nVector14_64vrtBD[numClon];
    205          
    206          //нормализованный вектор сработки 41
    207          // VectorXY_64   *nVector41_64vrt = &nVector41_64vrtBD[numClon];
    208          //нормализованный вектор сработки 43
    209          // VectorXY_64   *nVector43_64vrt = &nVector43_64vrtBD[numClon];
    210          //нормализованный вектор сработки 23
    211           VectorXY_64   *nVector23_64vrt = &nVector23_64vrtBD[numClon];
    212          //нормализованный вектор сработки 21
    213           VectorXY_64   *nVector21_64vrt = &nVector21_64vrtBD[numClon];
    214          //для треугольника
    215           VectorXY_64   *nVector31_64vrt = &nVector31_64vrtBD[numClon];
    216           VectorXY_64   *nVector13_64vrt = &nVector13_64vrtBD[numClon];
    217          
    218          
    219           INT_64 *zonaVertex = &zonaVertexBD[numClon*16];//4 *2 *5 *2*2];//массив вершин 
    220          
    221          //вычислить попадание вектора Z в зону треугольника
    222          //координаты приведенного вектора сработки Z3
    223          //  struct VectorXY  vectorZ3;
    224            VectorXY_64  vectorZ3_64;
    225          //координаты приведенного вектора сработки Z1
    226            //struct VectorXY  vectorZ1;
    227            VectorXY_64  vectorZ1_64;
    228          //координаты приведенного вектора сработки Z2
    229           // struct VectorXY  vectorZ2;
    230            VectorXY_64  vectorZ2_64;
    231          
    232           // float nMinZ;//минимальный нормализованный Z
    233            INT_64 nMinZ_64;//минимальный нормализованный Z
    234           // float XA, YA, XB, YB, XC, YC;
    235            INT_64 XA_64, YA_64, XB_64, YB_64, XC_64, YC_64;
    236          
    237            if (isZonaBD[idxIsZona])//попадание в зону ДЗ
    238            {
    239              XA_64 = zonaVertex[iX13V_64];
    240              YA_64 = zonaVertex[iY13V_64];
    241              XB_64 = zonaVertex[iX21V_64];
    242              YB_64 = zonaVertex[iY21V_64];
    243              XC_64 = zonaVertex[iX32V_64];
    244              YC_64 = zonaVertex[iY32V_64];
    245            }//if (isZona)
    246             else
    247            {
    248              XA_64 = zonaVertex[iX1_64];
    249              YA_64 = zonaVertex[iY1_64];
    250              XB_64 = zonaVertex[iX2_64];
    251              YB_64 = zonaVertex[iY2_64];
    252              XC_64 = zonaVertex[iX3_64];
    253              YC_64 = zonaVertex[iY3_64];
    254            }//else
    255          
    256            int axesZ = 1;//активный осевой вектор Z1
    257          //вычислить координаты приведенного вектора сработки Z1
    258            makeOporVectorZ_64VRT(XA_64, YA_64, &vectorZ1_64);
    259            nMinZ_64 = makeLenVector_64VRT(&vectorZ1_64);//минимальный нормализованный Z
    260          //вычислить координаты приведенного вектора сработки Z2
    261            makeOporVectorZ_64VRT(XB_64, YB_64, &vectorZ2_64);
    262            INT_64 tmpLen_64 = makeLenVector_64VRT(&vectorZ2_64);
    263            if (nMinZ_64>tmpLen_64){ nMinZ_64 = tmpLen_64; axesZ = 2;}
    264          //вычислить координаты приведенного вектора сработки Z2
    265            makeOporVectorZ_64VRT(XC_64, YC_64, &vectorZ3_64);
    266            tmpLen_64 = makeLenVector_64VRT(&vectorZ3_64);
    267            if (nMinZ_64>tmpLen_64) axesZ = 3;
    268          
    269          //  printLenVectorTrian(isZona);//отобразить длину векторов
    270          
    271            int isSectorZ1 = 0;//false;
    272            int isSectorZ2 = 0;//false;
    273            int isSectorZ3 = 0;//false;
    274          
    275          //  if (!errorZona) //ошибка расположения вершин зоны
    276          //  {
    277          
    278              switch (axesZ) {
    279              case 1:
    280                if (isSectorZ_64VRT(&vectorZ3_64, nVector31_64vrt, nVector32_64vrt) &&
    281                    isSectorZ_64VRT(&vectorZ2_64, nVector23_64vrt, nVector21_64vrt)) isSectorZ1 = 1;//true;
    282              break;
    283              case 2:
    284                if (isSectorZ_64VRT(&vectorZ3_64, nVector31_64vrt, nVector32_64vrt) &&
    285                    isSectorZ_64VRT(&vectorZ1_64, nVector12_64vrt, nVector13_64vrt)) isSectorZ2 = 1;//true;
    286              break;
    287              case 3:
    288                if (isSectorZ_64VRT(&vectorZ2_64, nVector23_64vrt, nVector21_64vrt) &&
    289                    isSectorZ_64VRT(&vectorZ1_64, nVector12_64vrt, nVector13_64vrt)) isSectorZ3 = 1;//true;
    290              break;
    291          
    292              default:;
    293              }//switch
    294          
    295              if (isZonaBD[idxIsZona])//isZona)
    296              {
    297                //вычислить  возврат
    298                if (isSectorZ1 | isSectorZ2 | isSectorZ3);
    299                else isZonaBD[idxIsZona] = 0;//isZona = 0;//false;
    300              }
    301              else
    302              {
    303                //вычислить сработку
    304          //      isZona
    305                isZonaBD[idxIsZona] = isSectorZ1 | isSectorZ2 | isSectorZ3;
    306              }//if
    307          
    308          
    309            //}//if(!errorZona)
    310          //*/
    311              return isZonaBD[idxIsZona];//0;//isZona;
    312          
    313          }//int isViewZTrianMethod_64VRT(int numClon, int idxIsZona)
    314          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      28   isSectorZ_64VRT
     160   isViewZMethod_64VRT
     120   isViewZTrianMethod_64VRT
       8   makeLenVector_64VRT
       8   makeOporVectorZ_64VRT


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     144  isSectorZ_64VRT
    1300  isViewZMethod_64VRT
    1392  isViewZTrianMethod_64VRT
      52  makeLenVector_64VRT
      64  makeOporVectorZ_64VRT

 
 3 008 bytes in section Fast_function
 
 3 008 bytes of CODE memory

Errors: none
Warnings: none
