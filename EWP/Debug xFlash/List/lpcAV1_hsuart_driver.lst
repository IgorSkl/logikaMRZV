###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        12/Oct/2015  11:05:02
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        projects\HR1_0100_00_I720_new2\LIB\CDL_AV0\csps\lpc32xx\source\lpcAV1_hsuart_driver.c
#    Command line =  
#        "D:\IAR
#        projects\HR1_0100_00_I720_new2\LIB\CDL_AV0\csps\lpc32xx\source\lpcAV1_hsuart_driver.c"
#        -D _STATIC_MEMORY_BOOT -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\List\lpcAV1_hsuart_driver.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\Obj\lpcAV1_hsuart_driver.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\LIB\CDL_AV0\csps\lpc32xx\source\lpcAV1_hsuart_driver.c
      1          /***********************************************************************
      2           * $Id: lpc32xx_hsuart_driver.c 35145 2010-03-19 18:10:17Z anderslu $
      3           *
      4           * Project: LPC3xxx High Speed UART driver
      5           *
      6           * Description:
      7           *     This file contains driver support for the LPC3xxx HS UART
      8           *
      9           ***********************************************************************
     10           * Software that is described herein is for illustrative purposes only
     11           * which provides customers with programming information regarding the
     12           * products. This software is supplied "AS IS" without any warranties.
     13           * NXP Semiconductors assumes no responsibility or liability for the
     14           * use of the software, conveys no license or title under any patent,
     15           * copyright, or mask work right to the product. NXP Semiconductors
     16           * reserves the right to make changes in the software without
     17           * notification. NXP Semiconductors also make no representation or
     18           * warranty that such application will be suitable for the specified
     19           * use without further testing or modification.
     20           *********************************************************************/
     21          
     22          #include "../include/lpc32xx_uart.h"
     23          #include "../include/lpc32xx_hsuart_driver.h"
     24          #include "../include/lpc32xx_intc_driver.h"
     25          #include "../include/lpc32xx_clkpwr_driver.h"
     26          #include "../include/lpc32xx_timer_driver.h"
     27          #include "lpc_irq_fiq.h"
     28          /***********************************************************************
     29           * HSUART driver package data
     30          ***********************************************************************/
     31          extern unsigned char chEntry_Hs7;
     32          extern unsigned char chHdwErorHSU7;
     33          extern unsigned char chEntry_Hs2;
     34          extern unsigned char chHdwErorHSU2;
     35          extern unsigned char chEntry_Hs1;
     36          extern unsigned char chHdwErorHSU1;
     37          extern unsigned long lTmrHSU2Val;
     38          /* HSUART driver data */
     39          static HSUART_CFG_T hs_uart_dat [3];
     40          
     41          /***********************************************************************
     42           * HSUART driver private functions
     43           **********************************************************************/
     44          
     45          /***********************************************************************
     46           *
     47           * Function: hsuart_gen_int_handler
     48           *
     49           * Purpose: General HS UART interrupt handler and router
     50           *
     51           * Processing:
     52           *     Handles transmit, receive, and status interrupts for the HS UART.
     53           *     Based on the interrupt status, routes the interrupt to the
     54           *     respective callback to be handled by the user application using
     55           *     this driver.
     56           *
     57           * Parameters: None
     58           *
     59           * Outputs: None
     60           *
     61           * Returns: Nothing
     62           *
     63           * Notes: If a callback doesn't exist, the interrupt will be disabled.
     64           *
     65           **********************************************************************/
     66          void hs_uart_gen_int_handler(HSUART_CFG_T *phsuartcfg)
     67          {
     68            volatile UNS_32 tmp;
     69            long il;
     70          
     71            /* Determine the interrupt source */
     72            tmp = phsuartcfg->regptr->iir;
     73            il = 0;
     74          
     75            if ((tmp & (HSU_RX_TRIG_INT | HSU_RX_TIMEOUT_INT)) != 0)
     76            {
     77              /* RX interrupt, needs servicing */
     78              if (phsuartcfg->cbs.rxcb != NULL)
     79              {
     80                phsuartcfg->cbs.rxcb(&phsuartcfg);
     81          	  
     82          	    if(tmp & HSU_RX_TIMEOUT_INT)
     83          	    {
     84          		  if (phsuartcfg->cbs.eofcb != NULL)
     85          		  phsuartcfg->cbs.eofcb();
     86          	    }
     87          	  il++;
     88              }
     89              else
     90              {
     91                /* No callback, disable interrupt */
     92                phsuartcfg->regptr->ctrl &= ~HSU_RX_INT_EN;
     93          	  	  
     94              }
     95            }
     96          
     97            if ((tmp & HSU_TX_INT) != 0)
     98            {
     99              /* TX interrupt, needs servicing */
    100              if (phsuartcfg->cbs.txcb != NULL)
    101              {
    102                //phsuartcfg->regptr->ctrl &= ~HSU_TX_INT_EN;
    103          	  phsuartcfg->cbs.txcb(&phsuartcfg);
    104          	  //phsuartcfg->regptr->ctrl |= HSU_TX_INT_EN;
    105              }
    106              else
    107              {
    108                /* No callback, disable interrupt */
    109                phsuartcfg->regptr->ctrl &= ~HSU_TX_INT_EN;
    110              }
    111            }
    112          
    113            if ((tmp & (HSU_RX_OE_INT | HSU_BRK_INT | HSU_FE_INT)) != 0)
    114            {
    115              /* Error interrupt, needs servicing */
    116              if (phsuartcfg->cbs.rxerrcb != NULL)
    117              {
    118                phsuartcfg->cbs.rxerrcb(&phsuartcfg);
    119              }
    120              else
    121              {
    122                /* No callback, disable interrupt */
    123                phsuartcfg->regptr->ctrl &= ~HSU_ERR_INT_EN;
    124              }
    125            }
    126              
    127          	if(il==0) return;//Frease on receive
    128          	il = hs_uart_ptr_to_hsuart_num(phsuartcfg->regptr);
    129          	switch (il )
    130          	{
    131          		case 0:
    132          		
    133          		    il = (1<<IRQ_UART_IIR1);
    134          			il &= MIC->rsr;
    135          			if(il )   //  
    136          			{
    137          			    MIC-> er &= ~il;//~tmp;
    138          				phsuartcfg->regptr->ctrl &= ~(HSU_RX_INT_EN);
    139          				//MIC-> er |= tmp;	
    140          				chEntry_Hs1++;
    141          				chHdwErorHSU1++;
    142          			}
    143          			
    144          		break;
    145          		case 1:
    146          		
    147          			il = (1<<IRQ_UART_IIR2);
    148          			il &= MIC->rsr;
    149          			if(il )   //  
    150          			{
    151          			    MIC-> er &= ~il;//~tmp;
    152          				phsuartcfg->regptr->ctrl &= ~(HSU_RX_INT_EN);
    153          				//MIC-> er |= tmp;	
    154          				chEntry_Hs2++;
    155          				chHdwErorHSU2++;
    156          			}
    157          		break;
    158          		case 2:
    159          		    il = (1<<IRQ_UART_IIR7);
    160          			il &= MIC->rsr;
    161          			if(il )   //  
    162          			{
    163          			    MIC-> er &= ~il;//~tmp;
    164          				phsuartcfg->regptr->ctrl &= ~(HSU_RX_INT_EN);
    165          				//MIC-> er |= tmp;	
    166          				chEntry_Hs7++;
    167          				chHdwErorHSU7++;
    168          			}
    169          		break;
    170          	 default:
    171          		;
    172          	}
    173          
    174          	
    175            //else
    176            //MIC-> er |= tmp;
    177            
    178          }
    179          
    180          /***********************************************************************
    181           *
    182           * Function: uart1_int_handler
    183           *
    184           * Purpose: UART1 interrupt handler and router
    185           *
    186           * Processing:
    187           *     Handles UART 1 interrupt by routing the to general handler with
    188           *     the UART 1 driver data.
    189           *
    190           * Parameters: None
    191           *
    192           * Outputs: None
    193           *
    194           * Returns: Nothing
    195           *
    196           * Notes: None
    197           *
    198           **********************************************************************/
    199          void hs_uart1_int_handler(void)
    200          {
    201            //hs_uart_gen_int_handler(&hsuartdat[0]);
    202            //int_disable(IRQ_UART_IIR1);
    203            hs_uart_gen_int_handler(&hs_uart_dat[0]);
    204            //int_enable(IRQ_UART_IIR1);
    205          }
    206          
    207          /***********************************************************************
    208           *
    209           * Function: uart2_int_handler
    210           *
    211           * Purpose: UART2 interrupt handler and router
    212           *
    213           * Processing:
    214           *     Handles UART 2 interrupt by routing the to general handler with
    215           *     the UART 2 driver data.
    216           *
    217           * Parameters: None
    218           *
    219           * Outputs: None
    220           *
    221           * Returns: Nothing
    222           *
    223           * Notes: None
    224           *
    225           **********************************************************************/
    226          void hs_uart2_int_handler(void)
    227          {
    228            //hs_uart_gen_int_handler(&hsuartdat[1]);
    229            //Int_disable(IRQ_UART_IIR2);
    230            hs_uart_gen_int_handler(&hs_uart_dat[1]);
    231            //Int_enable(IRQ_UART_IIR2);
    232          }
    233          
    234          /***********************************************************************
    235           *
    236           * Function: uart7_int_handler
    237           *
    238           * Purpose: UART7 interrupt handler and router
    239           *
    240           * Processing:
    241           *     Handles UART 7 interrupt by routing the to general handler with
    242           *     the UART 7 driver data.
    243           *
    244           * Parameters: None
    245           *
    246           * Outputs: None
    247           *
    248           * Returns: Nothing
    249           *
    250           * Notes: None
    251           *
    252           **********************************************************************/
    253          void hs_uart7_int_handler(void)
    254          {
    255            //hsuart_gen_int_handler(&hsuartdat[2]);
    256            //disable_irq_fiq();
    257            hs_uart_gen_int_handler(&hs_uart_dat[2]);
    258           //enable_irq_fiq();
    259          }
    260          
    261          /***********************************************************************
    262           *
    263           * Function: hsuart_abs
    264           *
    265           * Purpose: ABS difference function
    266           *
    267           * Processing:
    268           *     See function.
    269           *
    270           * Parameters:
    271           *     v1 : Value 1 for ABS
    272           *     v2 : Value 2 for ABS
    273           *
    274           * Outputs: None
    275           *
    276           * Returns: Absolute difference between the 2 values
    277           *
    278           * Notes: None
    279           *
    280           **********************************************************************/
    281          INT_32 hsuart_abs(INT_32 v1, INT_32 v2)
    282          {
    283            if (v1 > v2)
    284            {
    285              return v1 - v2;
    286            }
    287          
    288            return v2 - v1;
    289          }
    290          
    291          /***********************************************************************
    292           *
    293           * Function: hsuart_ptr_to_hsuart_num
    294           *
    295           * Purpose: Convert a HS UART register pointer to a HS UART number
    296           *
    297           * Processing:
    298           *     Based on the passed HS UART address, return the HS UART number.
    299           *
    300           * Parameters:
    301           *     puart : Pointer to a HS UART register set
    302           *
    303           * Outputs: None
    304           *
    305           * Returns: The HS UART number (0 to 2) or -1 if register pointer is bad
    306           *
    307           **********************************************************************/
    308          INT_32 hs_uart_ptr_to_hsuart_num(HSUART_REGS_T *phsuart)
    309          {
    310            INT_32 hsuartnum = -1;
    311          
    312            if (phsuart == UART1)
    313            {
    314              hsuartnum = 0; /* UART 1 */
    315            }
    316            else if (phsuart == UART2)
    317            {
    318              hsuartnum = 1; /* UART 2 */
    319            }
    320            else if (phsuart == UART7)
    321            {
    322              hsuartnum = 2; /* UART 7 */
    323            }
    324          
    325            return hsuartnum;
    326          }
    327          
    328          /***********************************************************************
    329           *
    330           * Function: hsuart_flush_fifos
    331           *
    332           * Purpose: Flushes one or both of the HS UART FIFOs
    333           *
    334           * Processing:
    335           *     See function.
    336           *
    337           * Parameters:
    338           *     pregs     : Pointer to a HS UART register base
    339           *     flushword : Masked flush value
    340           *
    341           * Outputs: None
    342           *
    343           * Returns: Nothing
    344           *
    345           * Notes: None
    346           *
    347           **********************************************************************/
    348          void hs_uart_flush_fifos(HSUART_REGS_T *pregs,
    349                                  UNS_32 flushword)
    350          {
    351            UNS_8 dummy = 0;
    352          
    353            (void) dummy;
    354          
    355            while ((pregs->level & 0xFF00) != 0);
    356            while ((pregs->level & 0xFF) != 0)
    357            {
    358              dummy =	pregs->txrx_fifo;
    359            }
    360          }
    361          
    362          /***********************************************************************
    363           *
    364           * Function: hsuart_find_clk
    365           *
    366           * Purpose: Determines best divider to get a target clock rate
    367           *
    368           * Processing:
    369           *     See function.
    370           *
    371           * Parameters:
    372           *     hsuartnum : HSUART number (0..2) for HS UARTS (1, 2, 7)
    373           *     freq      : Desired HS UART baud rate
    374           *     div       : Structure to place dividers to get rate into
    375           *
    376           * Outputs: None
    377           *
    378           * Returns: Actual HS UART baud rate
    379           *
    380           * Notes: None
    381           *
    382           **********************************************************************/
    383          UNS_32 hs_uart_find_clk(UNS_32 freq,
    384                                 HSUART_CFG_T *phsuartcfg)
    385          {
    386            UNS_32 clkrate, savedclkrate, diff, basepclk;
    387            INT_32 idiv, divider;
    388          
    389            /* Get the clock rate for the UART block */
    390            basepclk = clkpwr_get_base_clock_rate(CLKPWR_PERIPH_CLK);
    391          
    392            /* Find the best divider */
    393            divider = 0;
    394            savedclkrate = 0;
    395            diff = 0xFFFFFFFF;
    396            for (idiv = 0; idiv < 0x100; idiv++)
    397            {
    398              clkrate = basepclk / (14 * (idiv + 1));
    399              if (hsuart_abs(clkrate, freq) < diff)
    400              {
    401                diff = hsuart_abs(clkrate, freq);
    402                savedclkrate = clkrate;
    403                divider = idiv;
    404              }
    405            }
    406          
    407            /* Saved computed divider */
    408            phsuartcfg->divider = divider;
    409          
    410            return savedclkrate;
    411          }
    412          
    413          /***********************************************************************
    414           *
    415           * Function: hsuart_setup_trans_mode
    416           *
    417           * Purpose: Sets up a HS UART data transfer mode
    418           *
    419           * Processing:
    420           *     See function.
    421           *
    422           * Parameters:
    423           *     puartcfg   : Pointer to HS UART configuration data
    424           *     puartsetup : Pointer to a HS UART transfer mode setup structure
    425           *
    426           * Outputs: None
    427           *
    428           * Returns: _NO_ERROR if setup was ok, otherwise _ERROR
    429           *
    430           * Notes: None
    431           *
    432           **********************************************************************/
    433          STATUS hs_uart_setup_trans_mode(HSUART_CFG_T *phsuartcfg,
    434                                         HSUART_CONTROL_T *phsuartsetup)
    435          {
    436            STATUS err = _NO_ERROR;
    437          
    438            /* Find closest baud rate for desired clock frequency */
    439            phsuartcfg->baudrate = hs_uart_find_clk(phsuartsetup->baud_rate, phsuartcfg);
    440          
    441            /* Set clock divider for the HS UART */
    442            switch (phsuartcfg->hsuartnum)
    443            {
    444              case 0:
    445                UART1->rate = phsuartcfg->divider;
    446                break;
    447          
    448              case 1:
    449                UART2->rate = phsuartcfg->divider;
    450                break;
    451          
    452              case 2:
    453                UART7->rate = phsuartcfg->divider;
    454                break;
    455          
    456              default:
    457                err = _ERROR;
    458                break;
    459            }
    460          
    461            if (err == _NO_ERROR)
    462            {
    463              /* Set CTS control */
    464              if (phsuartsetup->cts_en)
    465              {
    466                phsuartcfg->regptr->ctrl |=	HSU_HCTS_EN;
    467                /* CTS inversion control */
    468                if (phsuartsetup->cts_inv)
    469                {
    470                  phsuartcfg->regptr->ctrl |=	HSU_HCTS_INV;
    471                }
    472                else
    473                {
    474                  phsuartcfg->regptr->ctrl &=	~HSU_HCTS_INV;
    475                }
    476              }
    477              else
    478              {
    479                phsuartcfg->regptr->ctrl &=	~HSU_HCTS_EN;
    480              }
    481          
    482              /* Set RTS control */
    483              if (phsuartsetup->rts_en)
    484              {
    485                phsuartcfg->regptr->ctrl |=	HSU_HRTS_EN;
    486                /* RTS inversion control */
    487                if (phsuartsetup->rts_inv)
    488                {
    489                  phsuartcfg->regptr->ctrl |=	HSU_HRTS_INV;
    490                }
    491                else
    492                {
    493                  phsuartcfg->regptr->ctrl &=	~HSU_HRTS_INV;
    494                }
    495              }
    496              else
    497              {
    498                phsuartcfg->regptr->ctrl &=	~HSU_HRTS_EN;
    499              }
    500            }
    501          
    502            return err;
    503          }
    504          
    505          /***********************************************************************
    506           * HS UART driver public functions
    507           **********************************************************************/
    508          
    509          /***********************************************************************
    510           *
    511           * Function: hsuart_open
    512           *
    513           * Purpose: Open the HS UART
    514           *
    515           * Processing:
    516           *     See function.
    517           *
    518           * Parameters:
    519           *     ipbase: Pointer to a HS UART peripheral block
    520           *     arg   : Pointer to HS UART setup structure or NULL
    521           *
    522           * Outputs: None
    523           *
    524           * Returns: The pointer to a HS UART config structure or NULL
    525           *
    526           * Notes: None
    527           *
    528           **********************************************************************/
    529          INT_32 hs_uart_open(void *ipbase,
    530                             INT_32 arg)
    531          {
    532            HSUART_CONTROL_T hsuarttran;
    533            volatile UNS_32 tmp;
    534            INT_32 hsuartnum, tptr = (INT_32) NULL;
    535            HSUART_CONTROL_T *pucfg = (HSUART_CONTROL_T *) arg;
    536          
    537            /* Try to find a matching HSUART number based on the passed pointer */
    538            hsuartnum = hs_uart_ptr_to_hsuart_num((HSUART_REGS_T *) ipbase);
    539            if (hsuartnum >= 0)
    540            {
    541              /* Has the HS UART been previously initialized? */
    542              if (hs_uart_dat[hsuartnum].hsuart_init == FALSE)
    543              {
    544                /* HS UART is free */
    545                hs_uart_dat[hsuartnum].hsuart_init = TRUE;
    546                hs_uart_dat[hsuartnum].hsuartnum = hsuartnum;
    547                hs_uart_dat[hsuartnum].regptr = (HSUART_REGS_T *) ipbase;
    548          
    549                /* No callbacks by default */
    550                hs_uart_dat[hsuartnum].cbs.rxcb = NULL;
    551                hs_uart_dat[hsuartnum].cbs.txcb = NULL;
    552                hs_uart_dat[hsuartnum].cbs.rxerrcb = NULL;
    553          
    554                /* Install general interrupt handler */
    555                switch (hsuartnum)
    556                {
    557                  case 0:
    558                    int_install_irq_handler(IRQ_UART_IIR1,
    559                                            //uart1_int_handler);
    560          								  hs_uart1_int_handler);
    561                    break;
    562                  case 1:
    563                    int_install_irq_handler(IRQ_UART_IIR2,
    564                                            //uart2_int_handler);
    565          								  hs_uart2_int_handler);
    566                    break;
    567          
    568                  case 2:
    569                    int_install_irq_handler(IRQ_UART_IIR7,
    570                                            //uart7_int_handler);
    571          								  hs_uart7_int_handler);
    572                    break;
    573                }
    574          
    575                /* Setup default UART state for 9600 */
    576                if (pucfg == NULL)
    577                {
    578                  hsuarttran.baud_rate = 9600;
    579                  hsuarttran.cts_en = FALSE;
    580                  hsuarttran.rts_en = FALSE;
    581                  hs_uart_setup_trans_mode(&hs_uart_dat[hsuartnum], &hsuarttran);
    582                }
    583                else
    584                {
    585                  hs_uart_setup_trans_mode(&hs_uart_dat[hsuartnum], pucfg);
    586                }
    587          
    588                /* Set FIFO level, and clear pending interrupts */
    589                hs_uart_dat[hsuartnum].regptr->ctrl = (HSU_HRTS_TRIG_32B | HSU_TMO_INACT_16B |
    590                                                     HSU_OFFSET(0x14) | HSU_RX_TL32B | HSU_TX_TL0B);
    591          
    592                /* Receive, transmit and status interrupts enabled */
    593                hs_uart_dat[hsuartnum].regptr->ctrl |= HSU_RX_INT_EN | HSU_TX_INT_EN | HSU_ERR_INT_EN;
    594          
    595                /* Return pointer to specific UART structure */
    596                tptr = (INT_32) & hs_uart_dat[hsuartnum];
    597              }
    598            }
    599          
    600            return tptr;
    601          }
    602          
    603          /***********************************************************************
    604           *
    605           * Function: hsuart_close
    606           *
    607           * Purpose: Close the HS UART
    608           *
    609           * Processing:
    610           *     If init is not TRUE, then return _ERROR to the caller as the
    611           *     device was not previously opened. Otherwise, disable the UART,
    612           *     set init to FALSE, and return _NO_ERROR to the caller.
    613           *
    614           * Parameters:
    615           *     devid: Pointer to HS UART config structure
    616           *
    617           * Outputs: None
    618           *
    619           * Returns: The status of the close operation
    620           *
    621           * Notes: None
    622           *
    623           **********************************************************************/
    624          STATUS hs_uart_close(INT_32 devid)
    625          {
    626            volatile UNS_32 tmp;
    627            HSUART_CFG_T *phsuart = (HSUART_CFG_T *) devid;
    628            STATUS status = _NO_ERROR;
    629          
    630            /* Close and disable device if it was previously initialized */
    631            if (phsuart->hsuart_init == TRUE)
    632            {
    633              /* Disable interrupts */
    634              phsuart->regptr->ctrl &= ~(HSU_ERR_INT_EN | HSU_RX_INT_EN | HSU_TX_INT_EN);
    635          
    636              /* Free UART and Disable timer system clock */
    637              phsuart->hsuart_init = FALSE;
    638            }
    639            else
    640            {
    641              status = _ERROR;
    642            }
    643          
    644            return status;
    645          }
    646          
    647          /***********************************************************************
    648           *
    649           * Function: uart_ioctl
    650           *
    651           * Purpose: UART configuration block
    652           *
    653           * Processing:
    654           *     This function is a large case block. Based on the passed function
    655           *     and option values, set or get the appropriate UART parameter.
    656           *
    657           * Parameters:
    658           *     devid: Pointer to UART config structure
    659           *     cmd:   ioctl command
    660           *     arg:   ioctl argument
    661           *
    662           * Outputs: None
    663           *
    664           * Returns: The status of the ioctl operation
    665           *
    666           * Notes: None
    667           *
    668           **********************************************************************/
    669          STATUS hs_uart_ioctl(INT_32 devid,
    670                              INT_32 cmd,
    671                              INT_32 arg)
    672          {
    673            HSUART_CBS_T *pcbs;
    674            HSUART_CFG_T *phsuart = (HSUART_CFG_T *) devid;
    675            STATUS status = _ERROR;
    676            UNS_8 dummy = 0;
    677          
    678            (void) dummy;
    679          
    680            /* Close and disable device if it was previously initialized */
    681            if (phsuart->hsuart_init == TRUE)
    682            {
    683              status = _NO_ERROR;
    684          
    685              switch (cmd)
    686              {
    687                case HSUART_CLEAR_FIFOS:
    688                  while ((phsuart->regptr->level & 0xFF00) != 0);
    689                  while ((phsuart->regptr->level & 0xFF) != 0)
    690                  {
    691                    dummy =	phsuart->regptr->txrx_fifo;
    692                  }
    693                  break;
    694          
    695                case HSUART_SETUP_TRANSFER:
    696                  hs_uart_setup_trans_mode(phsuart, (HSUART_CONTROL_T *) arg);
    697                  break;
    698          
    699                case HSUART_LOOPBACK_EN:
    700                  if (arg != 0)
    701                  {
    702                    UARTCNTL->loop |=
    703                      UART_LPBACK_ENABLED(phsuart->hsuartnum + 1);
    704                  }
    705                  else
    706                  {
    707                    UARTCNTL->loop &=
    708                      ~UART_LPBACK_ENABLED(phsuart->hsuartnum + 1);
    709                  }
    710                  break;
    711          
    712                case HSUART_FORCE_BREAK:
    713                  if (arg != 0)
    714                  {
    715                    phsuart->regptr->ctrl |= HSU_BREAK;
    716                  }
    717                  else
    718                  {
    719                    phsuart->regptr->ctrl &= ~HSU_BREAK;
    720                  }
    721                  break;
    722          
    723                case HSUART_INSTALL_CBS:
    724                  pcbs = (HSUART_CBS_T *) arg;
    725                  phsuart->cbs.rxcb    = pcbs->rxcb;
    726                  phsuart->cbs.txcb    = pcbs->txcb;
    727                  phsuart->cbs.rxerrcb = pcbs->rxerrcb;
    728          		phsuart->cbs.eofcb    = pcbs->eofcb;
    729                  break;
    730          
    731                case HSUART_GET_STATUS:
    732                  /* Return a UART status */
    733                  switch (arg)
    734                  {
    735                    case HSUART_GET_IP_CLOCK:
    736                      status = clkpwr_get_base_clock_rate(
    737                                 CLKPWR_PERIPH_CLK);
    738                      break;
    739          
    740                    case HSUART_GET_DERIVED_CLOCK:
    741                      status = phsuart->baudrate;
    742                      break;
    743          
    744                    case HSUART_GET_LINE_STATUS:
    745                      status = (STATUS) phsuart->regptr->iir;
    746                      break;
    747          
    748                    default:
    749                      /* Unsupported parameter */
    750                      status = LPC_BAD_PARAMS;
    751                      break;
    752                  }
    753                  break;
    754          
    755                default:
    756                  /* Unsupported parameter */
    757                  status = LPC_BAD_PARAMS;
    758              }
    759            }
    760          
    761            return status;
    762          }
    763          
    764          /***********************************************************************
    765           *
    766           * Function: uart_read
    767           *
    768           * Purpose: UART read function (stub only)
    769           *
    770           * Processing:
    771           *     Read the passed number of bytes in the passed buffer, or the
    772           *     amount of data that is available, whichever is less.
    773           *
    774           * Parameters:
    775           *     devid:     Pointer to UART descriptor
    776           *     buffer:    Pointer to data buffer to copy to
    777           *     max_bytes: Number of bytes to read
    778           *
    779           * Outputs: None
    780           *
    781           * Returns: Number of bytes actually read
    782           *
    783           * Notes: None
    784           *
    785           **********************************************************************/
    786          INT_32 hs_uart_read(INT_32 devid,
    787                             void *buffer,
    788                             INT_32 max_bytes)
    789          {
    790            INT_32 bread = 0;
    791            HSUART_CFG_T *phsuart = (HSUART_CFG_T *) devid;
    792            HSUART_REGS_T *pregs = phsuart->regptr;
    793            UNS_8 *buff8 = (UNS_8 *) buffer;
    794          
    795            while ((max_bytes > 0) && ((pregs->level & 0xFF) != 0))
    796            {
    797              *buff8 = (UNS_8) pregs->txrx_fifo;
    798              buff8++;
    799              max_bytes--;
    800              bread++;
    801            }
    802          
    803            return bread;
    804          }
    805          
    806          /***********************************************************************
    807           *
    808           * Function: uart_write
    809           *
    810           * Purpose: Timer UART function
    811           *
    812           * Processing:
    813           *     Write the passed number of bytes in the passed buffer to the UART
    814           *     FIFO, or the amounf of data that the FIFO can handle.
    815           *
    816           * Parameters:
    817           *     devid:   Pointer to UART descriptor
    818           *     buffer:  Pointer to data buffer to copy from
    819           *     n_bytes: Number of bytes to write
    820           *
    821           * Outputs: None
    822           *
    823           * Returns: Number of bytes actually written (always 0)
    824           *
    825           * Notes: None
    826           *
    827           **********************************************************************/
    828          INT_32 hs_uart_write(INT_32 devid,
    829                              void *buffer,
    830                              INT_32 n_bytes)
    831          {
    832            INT_32 bwrite = 0;
    833            HSUART_CFG_T *phsuart = (HSUART_CFG_T *) devid;
    834            HSUART_REGS_T *pregs = phsuart->regptr;
    835            UNS_8 *buff8 = (UNS_8 *) buffer;
    836          
    837            /* Only add data if the current FIFO level can be determined */
    838            if (((pregs->level) >> 8) == 0)
    839            {
    840              while ((n_bytes > 0) && (((pregs->level) >> 8) == 0))
    841              {
    842                pregs->txrx_fifo = (UNS_32) * buff8;
    843                buff8++;
    844                n_bytes--;
    845                bwrite++;
    846              }
    847          
    848              /* Since the trip point is at 8 bytes, it's ok to add up to
    849                 8 more bytes of data for transmit */
    850              if (n_bytes > 8)
    851              {
    852                n_bytes = 8;
    853              }
    854              while (n_bytes > 0)
    855              {
    856                pregs->txrx_fifo = (UNS_32) * buff8;
    857                buff8++;
    858                n_bytes--;
    859                bwrite++;
    860              }
    861            }
    862          
    863            return bwrite;
    864          }
    865          //static long lMaxTimeTransmit;
    866          INT_32 hs_uart_write1(INT_32 devid,
    867                              void *buffer,
    868                              INT_32 n_bytes) @ "Fast_function"
    869          {
    870            INT_32 bwrite = 0;
    871            HSUART_CFG_T *phsuart = (HSUART_CFG_T *) devid;
    872            HSUART_REGS_T *pregs = phsuart->regptr;
    873            UNS_8 *buff8 = (UNS_8 *) buffer;
    874          
    875            /* Only add data if the current FIFO level can be determined */
    876            if (((pregs->level) >> 8) < 4)
    877            {
    878              while ((n_bytes > 0) && (((pregs->level) >> 8) < 63 ))
    879              {
    880                pregs->txrx_fifo = (UNS_32) * buff8;
    881                buff8++;
    882                n_bytes--;
    883                bwrite++;
    884          	    if (n_bytes == 0)
    885          		{
    886          		n_bytes = 0;
    887          		buffer = TIMER_CNTR0;
    888          		lTmrHSU2Val = ((TIMER_CNTR_REGS_T*) buffer)->tc;
    889          		}
    890              }
    891          	
    892          
    893              /* Since the trip point is at 8 bytes, it's ok to add up to
    894                 8 more bytes of data for transmit /
    895              if (n_bytes > 8)
    896              {
    897                n_bytes = 8;
    898              }
    899              while (n_bytes > 0)
    900              {
    901                pregs->txrx_fifo = (UNS_32) * buff8;
    902                buff8++;
    903                n_bytes--;
    904                bwrite++;
    905              }*/
    906            }
    907          
    908            return bwrite;
    909          }
    910          /***********************************************************************
    911           *
    912           * Function: hs_uart_recover
    913           *
    914           * Purpose: Close the HS UART
    915           *
    916           * Processing:
    917           *     If init is not TRUE, then return _ERROR to the caller as the
    918           *     device was not previously opened. Otherwise, disable the UART,
    919           *     set init to FALSE, and return _NO_ERROR to the caller.
    920           *
    921           * Parameters:
    922           *     devid: Pointer to HS UART config structure
    923           *
    924           * Outputs: None
    925           *
    926           * Returns: The status of the close operation
    927           *
    928           * Notes: None
    929           *
    930           **********************************************************************/
    931          STATUS  hs_uart_recover(INT_32 devid)
    932          {
    933            volatile UNS_32 tmp;
    934            HSUART_CFG_T *phsuart = (HSUART_CFG_T *) devid;
    935            //INT_32 hsuartnum = 0;
    936            STATUS status = _NO_ERROR;
    937            long dummy = 0;
    938            (void) dummy;
    939          
    940            /* Close and disable device if it was previously initialized */
    941            if (phsuart->hsuart_init == TRUE)
    942            {
    943              //hsuartnum = hs_uart_ptr_to_hsuart_num((HSUART_REGS_T *) devid);
    944          	/* Disable interrupts */
    945              phsuart->regptr->ctrl &= ~(HSU_ERR_INT_EN | HSU_RX_INT_EN | HSU_TX_INT_EN);
    946          	phsuart->regptr->ctrl = 0;
    947          	 tmp = phsuart->regptr->rate;
    948          	phsuart->regptr->rate = 0;
    949          	phsuart->regptr->iir  = HSU_BRK_INT|HSU_FE_INT|HSU_RX_OE_INT|HSU_TX_INT ;
    950          	phsuart->regptr->iir  = 0;
    951          
    952              /* Free UART and Disable timer system clock */
    953              //phsuart->hsuart_init = FALSE;
    954          	dummy =	phsuart->regptr->txrx_fifo;
    955          	hs_uart_ioctl(devid, HSUART_CLEAR_FIFOS, 0);
    956          	
    957          	phsuart->regptr->iir  = HSU_RX_TRIG_INT;
    958          	phsuart->regptr->iir  = 0;
    959          	phsuart->regptr->rate = tmp;
    960          	phsuart->regptr->ctrl =   (HSU_TMO_INACT_16B |
    961              HSU_OFFSET(0x14) | HSU_RX_TL32B | HSU_TX_TL0B);//HSU_HRTS_TRIG_32B | 
    962          	phsuart->regptr->ctrl |= HSU_RX_INT_EN |   HSU_TX_INT_EN | HSU_ERR_INT_EN;//HSU_RX_INT_EN |
    963          	
    964            }
    965            else
    966            {
    967              status = _ERROR;
    968            }
    969          
    970            return status;
    971          }
    972          
    973          
    974          
    975          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   hs_uart1_int_handler
         8   -> hs_uart_gen_int_handler
       8   hs_uart2_int_handler
         8   -> hs_uart_gen_int_handler
       8   hs_uart7_int_handler
         8   -> hs_uart_gen_int_handler
       0   hs_uart_close
      40   hs_uart_find_clk
        40   -> clkpwr_get_base_clock_rate
        40   -> hsuart_abs
        40 __aeabi_uidiv
       0   hs_uart_flush_fifos
      16   hs_uart_gen_int_handler
        16   -- Indirect call
        16   -> hs_uart_ptr_to_hsuart_num
      32   hs_uart_ioctl
        32   -> clkpwr_get_base_clock_rate
        32   -> hs_uart_setup_trans_mode
      48   hs_uart_open
        48   -> hs_uart_ptr_to_hsuart_num
        48   -> hs_uart_setup_trans_mode
        48   -> int_install_irq_handler
       0   hs_uart_ptr_to_hsuart_num
      12   hs_uart_read
      24   hs_uart_recover
        24   -> hs_uart_ioctl
      16   hs_uart_setup_trans_mode
        16   -> hs_uart_find_clk
      12   hs_uart_write
      16   hs_uart_write1
       0   hsuart_abs


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      16  hs_uart1_int_handler
      16  hs_uart2_int_handler
      16  hs_uart7_int_handler
      68  hs_uart_close
     108  hs_uart_dat
     152  hs_uart_find_clk
      44  hs_uart_flush_fifos
     748  hs_uart_gen_int_handler
     428  hs_uart_ioctl
     404  hs_uart_open
      92  hs_uart_ptr_to_hsuart_num
      72  hs_uart_read
     232  hs_uart_recover
     368  hs_uart_setup_trans_mode
     140  hs_uart_write
     136  hs_uart_write1
      24  hsuart_abs

 
   108 bytes in section .bss
 2 872 bytes in section .text
   136 bytes in section Fast_function
 
 3 008 bytes of CODE memory
   108 bytes of DATA memory

Errors: none
Warnings: 1
