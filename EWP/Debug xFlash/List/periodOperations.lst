###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Oct/2015  12:49:41
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  D:\IAR projects\HR1_0100_00_I720_new2\periodOperations.c
#    Command line =  
#        "D:\IAR projects\HR1_0100_00_I720_new2\periodOperations.c" -D
#        _STATIC_MEMORY_BOOT -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\List\periodOperations.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\Obj\periodOperations.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\periodOperations.c
      1          
      2          #include "lpc_types.h"
      3          
      4          #include <stdio.h>
      5          #include <string.h>
      6          
      7          #include "psuperVisor\supermanager.h"
      8          
      9          #include "component\componentdef.h"
     10          #include "callbackelement\callbackelementdef.h"
     11          #include "psuperVisor\psvisor_helpdef.h"
     12          #include "virtualMenu\wideLogManagerdef.h"
     13          //#include "zonaVRT\zonaVRTdef.h"
     14          
     15          #include "callbackelement\callbackelementfnc.h"
     16          #include "psuperVisor\psvisor_helpfnc.h"
     17          #include "virtualMenu\systemmenufnc.h"
     18          
     19          #include "toSpeedOptim.h"
     20          #include "toSpeedDIS.h"
     21          
     22          #include "periodOperations.h"
     23          
     24          #include "header.h"
     25          #include "ici_r_ef.h"
     26          
     27          #define _HIDE_COMPONENT
     28          #include "PRM1Component.c"
     29          
     30          #include "APVComponent.c"
     31          #include "DZ1Component.c"
     32          #include "DZ2Component.c"
     33          
     34          #include "MTZ1Component.c"
     35          #include "MTZ2Component.c"
     36          
     37          #include "NZOP1Component.c"
     38          
     39          extern CALLBACK_MISSION cb_missionDEVICE1;
     40          extern CALLBACK_MISSION *cb_mission_crrDEVICE1;//текущая миссия
     41          extern short  missionSeparatorDEVICE1;//сепаратор миссии
     42          extern int    WideCmdBuffer[];//широкий ком массив
     43          extern UNS_32 pActualCMD[];//текущие
     44          extern UNS_32 ArrayRANGIR[];
     45          extern int  spvUSTAVKI[];//текущие уставки супервизора
     46          
     47          //глобальный сброс всех таймеров
     48          extern int  globalTimerReset;
     49          extern int ReleTrigger;//тригг реле
     50          extern int CDITrigger;//тригг СДИ
     51          extern int offsetSPVCmdPRM1;//смещение для SPV PRM1
     52          extern int    TypLE[];
     53          extern UNS_32 *WideLogActual;//командный массив расшир логики
     54          extern UNS_32 PlusCircleCmd[];//командный массив плюсовых команд LE
     55          extern UNS_32 InputLECmd[];//входной командный массив LE
     56          extern UNS_32 EXEOutputCmd[];//выходной командный массив компонентов
     57          extern int    isTimeSection;//критическая секция с двойным доступом
     58          
     59          extern UNS_32 dataCmdStateINTERFACE[];//INTERFACE CmdState
     60          extern UNS_32 dataTrgCmdStateINTERFACE[];//INTERFACE Trg CmdState
     61          extern UNS_32 buffTrgCmdStateINTERFACE[];//INTERFACE CmdState
     62          extern UNS_32 buffCmdStateINTERFACE[];//INTERFACE CmdState
     63          extern UNS_32 buffInStateINTERFACE;//INTERFACE  In
     64          extern UNS_32 buffOutStateINTERFACE;//INTERFACE Out
     65          extern UNS_32 buffLedStateINTERFACE;//INTERFACE Led
     66          extern UNS_32 buffTrgOutStateINTERFACE;//INTERFACE Trg Out
     67          extern UNS_32 buffTrgLedStateINTERFACE;//INTERFACE Trg Led
     68          extern UNS_32 buffGruppaUstINTERFACE;//группа уставок
     69          extern UNS_32 GruppaUst;//группа уставок
     70          
     71          //флаги уставок
     72          //extern char chbrCfgTblState;
     73          
     74          typedef struct
     75          {
     76            volatile UNS_8 bdvv_unisost1;  //0 рег сост БДВВ1
     77            volatile UNS_8 bdvv_in1;       //1 рег входов БДВВ1
     78            volatile UNS_8 bdvv_out1;      //2 рег выходов БДВВ1
     79            volatile UNS_8 bdvv_outsost1;  //3 рег сост выходов БДВВ1
     80            volatile UNS_8 bdvv_outena1;   //4 разрешение выходов БДВВ1
     81            volatile UNS_8 bdvv_rezerv1;   //5 резерв
     82            volatile UNS_8 bdvv_rezerv2;   //6 резерв
     83            volatile UNS_8 bdvv_rezerv3;   //7 резерв
     84            volatile UNS_8 bdvv_unisost2;  //8 рег сост БДВВ2
     85            volatile UNS_8 bdvv_in2;       //9 рег входов БДВВ2
     86            volatile UNS_8 bdvv_out2;      //A рег выходов БДВВ2
     87            volatile UNS_8 bdvv_outsost2;  //B рег сост выходов БДВВ2
     88            volatile UNS_8 bdvv_outena2;   //C разрешение выходов БДВВ2
     89          } BDVV_REGS_T;
     90          
     91          typedef struct
     92          {
     93            volatile UNS_8 bdvv_unisost_new;  //0 рег сост БДВВ _new
     94            volatile UNS_8 bdvv_in_new;       //1 рег входов БДВВ _new
     95            volatile UNS_8 bdvv_out_new;      //2 рег выходов БДВВ _new
     96            volatile UNS_8 bdvv_outsost_new;  //3 рег сост выходов БДВВ _new
     97            volatile UNS_8 bdvv_outena_new;   //4 разрешение выходов БДВВ _new
     98          } BDVVNEW_REGS_T;
     99          
    100          typedef struct
    101          {
    102            volatile UNS_8 bdv_unisost;  //0 рег сост БД
    103            volatile UNS_8 bdv_in1;          //1 рег входов БДВ
    104            volatile UNS_8 bdv_in2;          //2 рег входов БДВ
    105          } BDV_REGS_T;
    106          
    107          #define BDVV_BASE  0xE3000000
    108          #define BDVV_PNT ((BDVV_REGS_T *)(BDVV_BASE))
    109          #define BDV_BASE  0xE3000010
    110          #define BDV_PNT ((BDV_REGS_T *)(BDV_BASE))
    111          #define BDVVNEW_BASE  0xE3000020
    112          #define BDVVNEW_PNT ((BDVVNEW_REGS_T *)(BDVVNEW_BASE))
    113          
    114          
    115          //UNS_8 arrayEEPROM[100];//массив EEPROM для чтения
    116          extern int timing;  
    117          extern int timingLoad;  
    118          extern int cicling;  
    119          
    120          extern int trigReg;//заполнить дискр рег
    121          
    122          extern int IndexTIMERS;
    123          extern int IndexTLog;
    124          extern int IndexIO;
    125          extern int IndexENA;
    126          extern int IndexUstSPV;//индекс уставок в супервизоре
    127          extern int GlobalLevelI_ABC[];//уровни фазных токов Фурье
    128          extern int GlobalLevelUL_ABC[];//уровни напр лин
    129          extern int GlobalLevelUF_ABC[];//уровни напр фаз
    130          extern int GlobalLevel_3I0;
    131          extern int GlobalLevel_3U0;
    132          extern UNS_32 rawDVLow;//сырые ДВ
    133          
    134          int indexLgm=0;//индекс исполняемого ЛЭ
    135          int isRunWL=1;//исполнение РЛ
    136          
    137          UNS_32 rele_bdvv1;//селекция реле
    138          UNS_32 cdi_bdvv1;//селекция CDI
    139          
    140          UNS_32 selectorDVLow;//селекция ДВ активный-неактивный для мл 16 DV
    141          UNS_32 selectorDVMidd;//селекция ДВ активный-неактивный для cp 16 DV
    142          UNS_32 selectorDVHi;//селекция ДВ активный-неактивный для ct 16 DV
    143          
    144          #include "ici_r_ef.h"
    145          
    146          int flag_max_monitoring;//макс параметры сработки
    147          int IA_maxMonitoring;//сбор данных макс сраб по IA
    148          int IB_maxMonitoring;//сбор данных макс сраб по IB
    149          int IC_maxMonitoring;//сбор данных макс сраб по IC
    150          
    151          int IA_maxFix;//фиксация данных макс сраб по IA
    152          int IB_maxFix;//фиксация данных макс сраб по IB
    153          int IC_maxFix;//фиксация данных макс сраб по IC
    154          
    155          int cntToBC=0;//обмен с BC
    156          void periodical_operations(void)
    157          {
    158           UNS_32 dvUnion[DQUADRO];//DV
    159           UNS_32 tmpUnion[2*DQUADRO];//временное
    160           UNS_32 tmpUnion2[2*DQUADRO];//временное
    161          
    162          
    163           switch(trigReg)//заполнить регистратор
    164           {
    165            case 1: DiskrRegList();//первые 50 строк дискр регистратора
    166            break;
    167          
    168            case 2: ActualRegList();//первые 50 строк текущих
    169            break;
    170          
    171            case 3: ActualDVList();//первые 50 строк текущих DV
    172            break;
    173          
    174            case 4: ActualReleList();//первые 50 строк текущих Реле
    175            break;
    176          
    177            default:;
    178           }//switch
    179            trigReg  = 0;//заполнить регистратор
    180          
    181          
    182           #define TEST_PIN_1          0
    183          
    184                  UNS_32 set = 0, clr = 0, maska = P3_STATE_GPO(TEST_PIN_1);
    185                  if ((GPIO->p3_outp_state & maska) != 0) clr = maska; 
    186                  else set = maska;
    187                  gpio_set_gpo_state(set, clr);
    188          
    189            JLINKDCC_Process();
    190            
    191          //операции реального времени
    192            Scan_Ici_Event_Req(); //межпроцессорный обмен
    193            Scan_Ici_Entry_Data();//межпроцессорный обмен
    194          
    195            flag_max_monitoring = 0;//макс параметры сработки
    196          
    197            dataAccessICI();//доступ к данным ICI
    198          
    199            UNS_8 test1 = BDVV_PNT->bdvv_unisost1;  //0 рег сост БДВВ1
    200          //  BDVV_PNT->bdvv_outena1 = 0xA5;   //4 разрешение выходов БДВВ1
    201          //  BDVV_PNT->bdvv_out1    = 0xff;      //2 рег выходов БДВВ1
    202            UNS_8 test2 = BDVV_PNT->bdvv_outsost1;  //3 рег сост выходов БДВВ1
    203            UNS_8 test3 = BDVV_PNT->bdvv_in1;       //1 рег входов БДВВ1
    204          
    205              UNS_8 test1_v = BDV_PNT->bdv_unisost;  //0 рег сост БДВ
    206            UNS_8 test3_v = BDV_PNT->bdv_in1;       //1 рег входов БДВ
    207            UNS_8 test4_v = BDV_PNT->bdv_in2;       //1 рег входов БДВ
    208          
    209            UNS_8 test1_new = BDVVNEW_PNT->bdvv_unisost_new;  //0 рег сост БДВВ _new
    210          //  BDVVNEW_PNT->bdvv_outena_new = 0xA5;   //4 разрешение выходов БДВВ _new
    211          //  BDVVNEW_PNT->bdvv_out_new    = 0xff;      //2 рег выходов БДВВ _new
    212            UNS_8 test2_new = BDVVNEW_PNT->bdvv_outsost_new;  //3 рег сост выходов БДВВ _new
    213            UNS_8 test3_new = BDVVNEW_PNT->bdvv_in_new;       //1 рег входов БДВВ _new
    214            
    215           rawDVLow = test3_new;
    216          
    217           //BDV_PNT->bdv_unisost = 0x00;  //0 рег сост БДВ
    218          
    219          //операции раз в оборот
    220           memset(dvUnion, 0, 4*DQUADRO);//обнулить DV
    221          
    222            isTimeSection = 1;//критическая секция с двойным доступом
    223            selectorDVLow = SelectorDVdriverLow();//селекция ДВ активный-неактивный для мл 16 DV
    224            //уставка ДВ -ПрямойИнверсный
    225            UNS_32 upr_dvLow  =   SPV_USTOUT(offsetSPVCmdPRM1+ SPV_UPR_DVLOW);
    226            selectorDVLow ^= upr_dvLow;
    227            dvUnionMakerLow(selectorDVLow, dvUnion);//получить массив dvUnion для мл 16 DV
    228          
    229            selectorDVMidd = SelectorDVdriverMidd();//селекция ДВ активный-неактивный для cp 16 DV
    230            //уставка ДВ -ПрямойИнверсный
    231            UNS_32 upr_dvMidd =   SPV_USTOUT(offsetSPVCmdPRM1+ SPV_UPR_DVMIDD);
    232            selectorDVMidd ^= upr_dvMidd;
    233            dvUnionMakerMidd(selectorDVMidd, dvUnion);//получить массив dvUnion для cp 16 DV
    234          
    235            selectorDVHi = SelectorDVdriverHi();//селекция ДВ активный-неактивный для ct DV
    236            UNS_32 upr_dvHi   =   SPV_USTOUT(offsetSPVCmdPRM1+ SPV_UPR_DVHI);
    237            selectorDVHi ^= upr_dvHi;
    238            dvUnionMakerHi(selectorDVHi, dvUnion);//получить массив dvUnion для ct  DV
    239            isTimeSection = 0;//критическая секция с двойным доступом
    240            buffInStateINTERFACE = selectorDVLow + selectorDVMidd*65536;
    241          /*
    242            FDVForm1->VisualDVdriver(selectorDVHi);//визуализация ДВ активный-неактивный
    243          
    244           if(DV1Box->Checked)
    245             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV1_SM*DQUADRO+ i];
    246           if(DV2Box->Checked)
    247             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV2_SM*DQUADRO+ i];
    248           if(DV3Box->Checked)
    249             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV3_SM*DQUADRO+ i];
    250           if(DV4Box->Checked)
    251             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV4_SM*DQUADRO+ i];
    252           if(DV5Box->Checked)
    253             for(int i=0; i<DQUADRO; i++) dvUnion[i] |= ArrayRANGIR[DV5_SM*DQUADRO+ i];
    254          */
    255          
    256           //общая логика измерений
    257           CommonMeasureLogic();
    258          
    259            if(TypLE[indexLgm]==0){
    260                     indexLgm=0;//индекс исполняемого ЛЭ
    261                     }//if
    262          
    263          //получить входные для ЛЭ
    264           for (int i=0; i<2*DQUADRO; i++) InputLECmd[i] = PlusCircleCmd[i] | EXEOutputCmd[i] | dvUnion[i];
    265          
    266          //исполнить массив ЛЭ 
    267            switch(TypLE[indexLgm])//индекс исполняемого ЛЭ
    268            {
    269             case typeLE_OR:{
    270               elementOR(indexLgm);//OR
    271               }
    272             break;
    273             case typeLE_AND:
    274               elementAND(indexLgm);//AND
    275             break;
    276             case typeLE_XOR:
    277               elementXOR(indexLgm);//XOR
    278             break;
    279             default:;
    280          
    281            }//switch
    282          
    283            indexLgm++;//индекс исполняемого ЛЭ
    284            if(indexLgm==LE_TOTAL) indexLgm=0;
    285          
    286          
    287           //сформировать текущие(первую половину) как выход схемы ЛЭ и ДВ
    288           for (int i=0; i<DQUADRO; i++) pActualCMD[i] = PlusCircleCmd[i] | dvUnion[i];
    289           //спрятать текущие pActualCMD (первую половину)
    290           memcpy(tmpUnion, pActualCMD, 4*DQUADRO);
    291          
    292          //Превратить ком массив(первую половину) в широкий ком массив RT
    293           TranslateQuadroToWideRTCmd(pActualCMD);
    294          
    295           EXElogicCOMPONENT();//СУПЕРВИЗОР Логика компонентов из конфиг
    296          
    297           memset(pActualCMD, 0, 4*DQUADRO);//обнулить текущие (первую половину)
    298           CompressorToActualCMD();//получить текущие (первую половину) из WideCmdRTBuffer
    299          
    300           //получить новые cmd от компонентов(первую половину)
    301           for (int i=0; i<DQUADRO; i++) EXEOutputCmd[i] = pActualCMD[i] & ~tmpUnion[i];
    302          
    303          //---------КОМПОНЕНТЫ РЛ--------------------------
    304           //спрятать текущие pActualCMD (первую половину)
    305           memcpy(tmpUnion2, pActualCMD, 4*DQUADRO);
    306          ///*
    307           //сформировать текущие(первую половину) как выход схемы ЛЭ(вторая половина)
    308           memcpy(pActualCMD, PlusCircleCmd, 2* 4*DQUADRO);
    309          // for (int i=0; i<DQUADRO; i++) pActualCMD[i +DQUADRO] = PlusCircleCmd[i +DQUADRO];
    310           //спрятать текущие pActualCMD (вторую половину)
    311           memcpy(tmpUnion, WideLogActual, 4*DQUADRO);
    312          
    313           //спрятать текущие pActualCMD (вторую половину)
    314          // memcpy(tmpUnion, WideLogActual, 4*DQUADRO);
    315          //Превратить текущие(вторая половина) в широкий ком массив RT
    316           TranslateQuadroToWideRTCmd(WideLogActual);
    317          
    318           EXElogicCOMPONENT_WL();//СУПЕРВИЗОР Логика компонентов из конфиг РЛ
    319          
    320           memset(pActualCMD, 0, 4*DQUADRO);//обнулить текущие (первую половину)
    321           CompressorToActualCMD();//получить текущие из WideCmdRTBuffer
    322          
    323           //получить новые cmd от компонентов(вторую половину)
    324           for (int i=0; i<DQUADRO; i++) EXEOutputCmd[i +DQUADRO] = pActualCMD[i] & ~tmpUnion[i];
    325          //*/
    326           //восстановить pActualCMD (первую половину)
    327           memcpy(pActualCMD, tmpUnion2, 4*DQUADRO);
    328          //-------------------------------------------------------------------------------------
    329          
    330           globalTimerReset = 0;//глобальный сброс всех таймеров
    331           DiskretRegWorking();//работа дискр регистратора
    332           PuskAPV_UROV_OFWorking();//пуск АПВ УРОВ ОФ
    333          
    334           isTimeSection = 1;//критическая секция с двойным доступом
    335           TranslateINTERFACE();//перетранслировать широкий ком массив
    336          
    337          //исполнить ранжирование реле
    338            rele_bdvv1 = WorkRangirRele();
    339            if((rele_bdvv1&0x40)!=0){
    340              int tt1=0;
    341            }//if
    342          //исполнить ранжирование СДИ
    343            cdi_bdvv1 = WorkRangirCDI();
    344            isTimeSection = 0;//критическая секция с двойным доступом
    345          
    346            buffOutStateINTERFACE = rele_bdvv1;//INTERFACE Out
    347            buffLedStateINTERFACE = cdi_bdvv1;//INTERFACE Led
    348            buffTrgOutStateINTERFACE = ReleTrigger;//INTERFACE Trg Out
    349            buffTrgLedStateINTERFACE = CDITrigger;//INTERFACE Trg Led
    350            buffGruppaUstINTERFACE = GruppaUst;//группа уставок
    351            memcpy(buffCmdStateINTERFACE, dataCmdStateINTERFACE, 4*DQUADRO);//INTERFACE CmdState
    352            memcpy(buffTrgCmdStateINTERFACE, dataTrgCmdStateINTERFACE, 4*DQUADRO);//INTERFACE Trg CmdState
    353          
    354            BDVV_PNT->bdvv_outena1 = 0xA5;   //4 разрешение выходов БДВВ1
    355          //  BDVV_PNT->bdvv_out1    = 0x00;//rele_bdvv1;//0xff;      //2 рег выходов БДВВ1
    356            
    357            BDVVNEW_PNT->bdvv_outena_new = 0xA5;   //4 разрешение выходов БДВВ1
    358            BDVVNEW_PNT->bdvv_out_new    = rele_bdvv1;      //2 рег выходов БДВВ1
    359            
    360          //  dataAccessEEPROM();//доступ к данным EEPROM 
    361           
    362           cicling ++;  
    363           
    364           if(cicling==100000){
    365                int tt0 = timingLoad;  
    366                int tt1 = timing;  
    367                int tt2 = cicling;  
    368                
    369                int tt3 = IndexTIMERS;
    370                int tt4 = IndexTLog;
    371                int tt5 = IndexIO;
    372                int tt6 = IndexENA;
    373                int tt7 = IndexUstSPV;//индекс уставок в супервизоре
    374                    tt7 = IndexUstSPV;//индекс уставок в супервизоре
    375                
    376           }//if
    377           
    378          
    379           if(flag_max_monitoring==0)//макс параметры сработки
    380           {
    381             //нет ни сбора данных ни фиксации
    382             IA_maxMonitoring = 0;//сбор данных макс сраб по IA
    383             IB_maxMonitoring = 0;//сбор данных макс сраб по IB
    384             IC_maxMonitoring = 0;//сбор данных макс сраб по IC
    385          
    386             IA_maxFix = 0;//фиксация данных макс сраб по IA
    387             IB_maxFix = 0;//фиксация данных макс сраб по IB
    388             IC_maxFix = 0;//фиксация данных макс сраб по IC
    389           }//if(flag_max_monitoring==0)//макс параметры сработки
    390          //  case MAXMONITORING_COLLECT:
    391           if(flag_max_monitoring&MAXMONITORING_COLLECT){//макс параметры сработки
    392            //сбор данных макс параметров
    393             }//if(flag_max_monitoring&MAXMONITORING_COLLECT){//макс параметры сработки
    394          //  case MAXMONITORING_FIX:
    395          
    396           if(flag_max_monitoring&MAXMONITORING_FIX){//макс параметры сработки
    397            //фиксация данных макс параметров
    398            //применение формулы
    399            }//if(flag_max_monitoring&MAXMONITORING_FIX){//макс параметры сработки
    400           
    401           
    402          }//periodical_operations(void)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     280   periodical_operations
       280   -> ActualDVList
       280   -> ActualRegList
       280   -> ActualReleList
       280   -> CommonMeasureLogic
       280   -> CompressorToActualCMD
       280   -> DiskrRegList
       280   -> DiskretRegWorking
       280   -> EXElogicCOMPONENT
       280   -> EXElogicCOMPONENT_WL
       280   -> JLINKDCC_Process
       280   -> PuskAPV_UROV_OFWorking
       280   -> Scan_Ici_Entry_Data
       280   -> Scan_Ici_Event_Req
       280   -> SelectorDVdriverHi
       280   -> SelectorDVdriverLow
       280   -> SelectorDVdriverMidd
       280   -> TranslateINTERFACE
       280   -> TranslateQuadroToWideRTCmd
       280   -> WorkRangirCDI
       280   -> WorkRangirRele
       280   -> __aeabi_memcpy
       280   -> __aeabi_memset
       280   -> dataAccessICI
       280   -> dvUnionMakerHi
       280   -> dvUnionMakerLow
       280   -> dvUnionMakerMidd
       280   -> elementAND
       280   -> elementOR
       280   -> elementXOR
       280   -> gpio_set_gpo_state


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  IA_maxFix
       4  IA_maxMonitoring
       4  IB_maxFix
       4  IB_maxMonitoring
       4  IC_maxFix
       4  IC_maxMonitoring
       4  cdi_bdvv1
       4  cntToBC
       4  flag_max_monitoring
       4  indexLgm
       4  isRunWL
    2016  periodical_operations
       4  rele_bdvv1
       4  selectorDVHi
       4  selectorDVLow
       4  selectorDVMidd

 
    56 bytes in section .bss
     4 bytes in section .data
 2 016 bytes in section .text
 
 2 016 bytes of CODE memory
    60 bytes of DATA memory

Errors: none
Warnings: 11
