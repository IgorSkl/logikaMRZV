###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        12/Oct/2015  11:05:02
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\LIB\source\lpc32xx_intc_driver.c
#    Command line =  
#        "D:\IAR
#        projects\HR1_0100_00_I720_new2\LIB\source\lpc32xx_intc_driver.c" -D
#        _STATIC_MEMORY_BOOT -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\List\lpc32xx_intc_driver.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\Obj\lpc32xx_intc_driver.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\LIB\source\lpc32xx_intc_driver.c
      1          /***********************************************************************
      2           * $Id: lpc32xx_intc_driver.c 30870 2009-07-05 10:16:16Z anderslu $
      3           *
      4           * Project: LPC32XX interrupt driver
      5           *
      6           * Description:
      7           *     This file contains driver support for the LPC32xx
      8           *     interrupt driver.
      9           *
     10           * Notes:
     11           *     This driver requires that the CP15 MMU driver is correctly
     12           *     working.
     13           *
     14           ***********************************************************************
     15           * Software that is described herein is for illustrative purposes only
     16           * which provides customers with programming information regarding the
     17           * products. This software is supplied "AS IS" without any warranties.
     18           * NXP Semiconductors assumes no responsibility or liability for the
     19           * use of the software, conveys no license or title under any patent,
     20           * copyright, or mask work right to the product. NXP Semiconductors
     21           * reserves the right to make changes in the software without
     22           * notification. NXP Semiconductors also make no representation or
     23           * warranty that such application will be suitable for the specified
     24           * use without further testing or modification.
     25          ***********************************************************************/
     26          
     27          #include "lpc_arm_arch.h"
     28          #include "lpc_arm922t_cp15_driver.h"
     29          #include "lpc32xx_intc_driver.h"
     30          
     31          /***********************************************************************
     32           * Interrupt driver package data
     33          ***********************************************************************/
     34          
     35          /* External vector jump addresses - setting one of these addresses with
     36             a new address of a function will cause the new function to be called
     37             when the interrupt or exception occurs */
     38          extern UNS_32 lpc32xx_reset_vector;
     39          extern UNS_32 vec_reset_handler;
     40          extern UNS_32 vec_undefined_handler;
     41          extern UNS_32 vec_swi_handler;
     42          extern UNS_32 vec_prefetch_handler;
     43          extern UNS_32 vec_abort_handler;
     44          extern UNS_32 vec_irq_handler;
     45          extern UNS_32 vec_fiq_handler;
     46          
     47          /* Array of Interrupt handlers */
     48          PFV irq_func_ptrs[IRQ_END_OF_INTERRUPTS];
     49          
     50          /* Pointer to logical interrupt vector area (writable) */
     51          UNS_32 *vecarea;
     52          
     53          /***********************************************************************
     54           * Vectored Interrupt driver private functions
     55          ***********************************************************************/
     56          
     57          
     58          /***********************************************************************
     59           *
     60           * Function: int_write_arm_vec_table
     61           *
     62           * Purpose: Writes the vector table and jump addresses to vector area
     63           *
     64           * Processing:
     65           *     Copy the shadowed image of the interrupt and exception vector
     66           *     table from memory to the vector jump area (usually at location
     67           *     0x00000000). Force out any cached values to external memory.
     68           *
     69           * Parameters: None
     70           *
     71           * Outputs: None
     72           *
     73           * Returns: Nothing
     74           *
     75           * Notes:
     76           *     Ideally, we would check the state of the V bit in the CP15
     77           *     coprocessor register 1 to determine the address of the where
     78           *     the vector area is located. If that bit was set, the vectors
     79           *     would be located at address 0xFFFF0000 instead of 0x00000000.
     80           *     This function assumes that the vector area is at 0x00000000.
     81           *
     82           **********************************************************************/
     83          static void int_write_arm_vec_table(void)
     84          {
     85            UNS_32 *dst, *dstsave, *src;
     86            INT_32 vecsize;
     87            UNS_32 high_vector;
     88          
     89            /* If vector address is automatic address, compute address */
     90            dst = vecarea;
     91            if ((UNS_32) dst == 0xFFFFFFFF)
     92            {
     93              /* Assume that vector table is located at low vector
     94                 (0x00000000) address */
     95              dst = (UNS_32 *) ARM_RESET_VEC;
     96          
     97              /* Check status of high vector bit in MMU control register and
     98                 set destination address of vector table to high vector
     99                 address if bit is set */
    100              high_vector = cp15_get_mmu_control_reg();
    101          
    102              /* If high bit is set, use high vector addresses instead */
    103              if ((high_vector & ARM922T_MMU_CONTROL_V) != 0)
    104              {
    105                dst = (UNS_32 *) 0xFFFF0000;
    106              }
    107            }
    108          
    109            /* Copy vector block to interrupt vector area */
    110            dstsave = dst;
    111            for (src = (UNS_32 *) & lpc32xx_reset_vector;
    112                 src <= (UNS_32 *) &vec_fiq_handler; src++)
    113            {
    114              *dst = *src;
    115              dst++;
    116            }
    117          
    118            /* Write out cached vector table to memory */
    119            vecsize = ((INT_32) & vec_fiq_handler -
    120                       (INT_32) & lpc32xx_reset_vector) / 4;
    121            cp15_force_cache_coherence(dstsave, (dstsave + vecsize));
    122          }
    123          
    124          /***********************************************************************
    125           *
    126           * Function: int_get_controller
    127           *
    128           * Purpose: Determines the interrupt controller based on interrupt
    129           *   source
    130           *
    131           * Processing:
    132           *     If the interrupt source is in the range of the MIC controller
    133           *	   then return MIC controller base or else if interrupt source is
    134           *	   in the range of the SIC1 controller return MIC controller base
    135           *	   or else if interrupt source is in the range of the SIC2
    136           *	   controller return SIC2 controller base.
    137           *
    138           * Parameters:
    139           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    140           *
    141           * Outputs:
    142           *	   pIntc_base: Contains the base address of controller
    143           *	   pBit_pos  : Contains the bit position of interrpt source within
    144           *                 controller regs
    145           *
    146           * Returns:
    147           *	  Interrupt controller base.
    148           *
    149           *
    150           **********************************************************************/
    151          static BOOL_32 int_get_controller(INTERRUPT_SOURCE_T source,
    152                                            INTC_REGS_T** pIntc_base,
    153                                            UNS_32* pBit_pos)
    154          {
    155            BOOL_32 ret_value = TRUE;
    156          
    157            /* Determine the interrupt controller */
    158            if (source < IRQ_SIC1_BASE)
    159            {
    160              *pIntc_base = MIC;
    161              *pBit_pos = (UNS_32)source;
    162            }
    163            else if ((source >= IRQ_SIC1_BASE) && (source < IRQ_SIC2_BASE))
    164            {
    165              *pIntc_base = SIC1;
    166              *pBit_pos = ((UNS_32)source - IRQ_SIC1_BASE);
    167            }
    168            else if (source <= IRQ_END_OF_INTERRUPTS)
    169            {
    170              *pIntc_base = SIC2;
    171              *pBit_pos = ((UNS_32)source - IRQ_SIC2_BASE);
    172            }
    173            else
    174            {
    175              *pIntc_base = 0;
    176              *pBit_pos = 0;
    177              ret_value = FALSE;
    178            }
    179            return ret_value;
    180          }
    181          
    182          
    183          /***********************************************************************
    184           * Interrupt driver public functions
    185          ***********************************************************************/
    186          
    187          /***********************************************************************
    188           *
    189           * Function: int_initialize
    190           *
    191           * Purpose: Initialize the interrupt controller
    192           *
    193           * Processing:
    194           *     For all IRQ interrupt sources, clear the dispatcher jump address
    195           *     and disable the interrupt in the interrupt controller. Copy the
    196           *     vector table and vector branch instructions to the interrupt
    197           *     and exception area with a call to int_write_table.
    198           *
    199           * Parameters:
    200           *     vectbladdr: Pointer to interrupt vector area, or 0xFFFFFFFF to
    201           *                 have driver determine address
    202           *
    203           * Outputs: None
    204           *
    205           * Returns: Nothing
    206           *
    207           * Notes: None
    208           *
    209           **********************************************************************/
    210          void int_initialize(UNS_32 vectbladdr)
    211          {
    212            UNS_32 source;
    213          
    214            /* Initialize main interrupt controller*/
    215            MIC->er = 0x00000000; /*disable all interrupt sources*/
    216            MIC->rsr = 0xFFFFFFFF;/*clear all edge triggered interrupts*/
    217            MIC->apr = MIC_APR_DEFAULT;/*set polarity for all internal irqs*/
    218            MIC->atr = MIC_ATR_DEFAULT;/*set act. types for all internal irqs*/
    219            MIC->itr = (_BIT(IRQ_HSTIMER));
    220          
    221            /* Initialize sub interrupt controller 1 */
    222            SIC1->er = 0x00000000; /*disable all interrupt sources*/
    223            SIC1->rsr = 0xFFFFFFFF;/*clear all edge triggered interrupts*/
    224            SIC1->apr = SIC1_APR_DEFAULT;/*set polarity for internal irqs*/
    225            SIC1->atr = SIC1_ATR_DEFAULT;/*set act-types for internal irqs*/
    226            SIC1->itr = 0x00000000;/*set all interrupts as irqs*/
    227          
    228            /* Initialize sub interrupt controller 2 */
    229            SIC2->er = 0x00000000; /*disable all interrupt sources*/
    230            SIC2->rsr = 0xFFFFFFFF;/*clear all edge triggered interrupts*/
    231            SIC2->apr = SIC2_APR_DEFAULT;/*set polarity for internal irqs*/
    232            SIC2->atr = SIC2_ATR_DEFAULT;/*set act. types for internal irqs*/
    233            SIC2->itr = 0x00000000;/*set all interrupts as irqs*/
    234          
    235            /* Enable sub-IRQ/FIQ handlers on main interrupt controller */
    236            MIC->er = (_BIT(IRQ_HSTIMER));
    237          
    238            /* Clear the IRQ vector table and disable all interrupts */
    239            for (source = 0; source < IRQ_END_OF_INTERRUPTS; source++)
    240            {
    241              irq_func_ptrs[source] = (PFV) NULL;
    242            }
    243          
    244            /* Save user passed vector area pointer */
    245            vecarea = (UNS_32 *) vectbladdr;
    246          
    247            /* write ARM vector table */
    248            int_write_arm_vec_table();
    249          }
    250          
    251          /***********************************************************************
    252           *
    253           * Function: int_install_arm_vec_handler
    254           *
    255           * Purpose: Install an new ARM exception vector handler
    256           *
    257           * Processing:
    258           *     If the passed fiq_handler_ptr pointer is not NULL, then
    259           *     set the handler jump address for the specific interrupt or
    260           *     exception to handler_ptr.  Recopy the vector table and vector
    261           *     branch instructions to the interrupt and exception area with a
    262           *     call to int_write_table.
    263           *
    264           * Parameters:
    265           *     handler_id  : Must be an enumeration of type VECTOR_T
    266           *     handler_ptr : Pointer to new interrupt or exception handler
    267           *
    268           * Outputs: None
    269           *
    270           * Returns: Nothing
    271           *
    272           * Notes: None
    273           *
    274           **********************************************************************/
    275          void int_install_arm_vec_handler(VECTOR_T handler_id,
    276                                           PFV handler_ptr)
    277          {
    278            /* Update address only if it is not NULL */
    279            if (handler_ptr != (PFV) NULL)
    280            {
    281              switch (handler_id)
    282              {
    283                case RESET_VEC:
    284                  vec_reset_handler = (UNS_32) handler_ptr;
    285                  cp15_force_cache_coherence(
    286                    (UNS_32 *) &vec_reset_handler,
    287                    (UNS_32 *) &vec_reset_handler);
    288                  break;
    289          
    290                case UNDEFINED_INST_VEC:
    291                  vec_undefined_handler = (UNS_32) handler_ptr;
    292                  cp15_force_cache_coherence(
    293                    (UNS_32 *) &vec_undefined_handler,
    294                    (UNS_32 *) &vec_undefined_handler);
    295                  break;
    296          
    297                case SWI_VEC:
    298                  vec_swi_handler = (UNS_32) handler_ptr;
    299                  cp15_force_cache_coherence(
    300                    (UNS_32 *) &vec_swi_handler,
    301                    (UNS_32 *) &vec_swi_handler);
    302                  break;
    303          
    304                case PREFETCH_ABORT_VEC:
    305                  vec_prefetch_handler = (UNS_32) handler_ptr;
    306                  cp15_force_cache_coherence(
    307                    (UNS_32 *) &vec_prefetch_handler,
    308                    (UNS_32 *) &vec_prefetch_handler);
    309                  break;
    310          
    311                case DATA_ABORT_VEC:
    312                  vec_abort_handler = (UNS_32) handler_ptr;
    313                  cp15_force_cache_coherence(
    314                    (UNS_32 *) &vec_abort_handler,
    315                    (UNS_32 *) &vec_abort_handler);
    316                  break;
    317          
    318                case IRQ_VEC:
    319                  vec_irq_handler = (UNS_32) handler_ptr;
    320                  cp15_force_cache_coherence(
    321                    (UNS_32 *) &vec_irq_handler,
    322                    (UNS_32 *) &vec_irq_handler);
    323                  break;
    324          
    325                case FIQ_VEC:
    326                  vec_fiq_handler = (UNS_32) handler_ptr;
    327                  cp15_force_cache_coherence(
    328                    (UNS_32 *) &vec_fiq_handler,
    329                    (UNS_32 *) &vec_fiq_handler);
    330                  break;
    331          
    332                default:
    333                  break;
    334              }
    335          
    336              /* Update ARM vector table */
    337              int_write_arm_vec_table();
    338            }
    339          }
    340          
    341          /***********************************************************************
    342           *
    343           * Function: int_install_irq_handler
    344           *
    345           * Purpose: Install an IRQ interrupt handler for an internal interrupt
    346           *
    347           * Processing:
    348           *     For the selected interrupt, sets the function called as the
    349           *     passed value.
    350           *
    351           * Parameters:
    352           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    353           *     func_ptr : Pointer to a void function
    354           *
    355           * Outputs: None
    356           *
    357           * Returns: Returns TRUE or FALSE.
    358           *
    359           * Notes: None
    360           *
    361           **********************************************************************/
    362          BOOL_32 int_install_irq_handler(INTERRUPT_SOURCE_T source,
    363                                          PFV func_ptr)
    364          {
    365            BOOL_32 ret_value = FALSE;
    366          
    367            if (source < IRQ_END_OF_INTERRUPTS)
    368            {
    369              irq_func_ptrs[source] = func_ptr;
    370              ret_value = TRUE;
    371            }
    372            return ret_value;
    373          }
    374          
    375          /***********************************************************************
    376           *
    377           * Function: int_install_ext_irq_handler
    378           *
    379           * Purpose: Install an IRQ interrupt handler for an external interrupt
    380           *
    381           * Processing:
    382           *     For the selected interrupt, sets the function called as the
    383           *     passed value.
    384           *
    385           * Parameters:
    386           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    387           *     func_ptr : Pointer to a void function
    388           *     type	    : Interrupt activation type (INTERRUPT_TYPE_T)
    389           *     high     : Interrupt on high level or edge
    390           *
    391           * Outputs: None
    392           *
    393           * Returns: Returns TRUE or FALSE.
    394           *
    395           * Notes: None
    396           *
    397           **********************************************************************/
    398          BOOL_32 int_install_ext_irq_handler(INTERRUPT_SOURCE_T source,
    399                                              PFV func_ptr,
    400                                              INTERRUPT_TYPE_T type,
    401                                              int high)
    402          {
    403            BOOL_32 ret_value = TRUE;
    404            INTC_REGS_T *pIntc;
    405            UNS_32 bit_pos = 0;
    406          
    407            /* get the interrupt controller for the give interrupt source */
    408            ret_value = int_get_controller(source, &pIntc, &bit_pos);
    409            if (TRUE == ret_value)
    410            {
    411              switch (type)
    412              {
    413                case ACTIVE_LOW:
    414                  pIntc->apr &= ~_BIT(bit_pos);
    415                  pIntc->atr &= ~_BIT(bit_pos);
    416                  break;
    417                case ACTIVE_HIGH:
    418                  pIntc->apr |= _BIT(bit_pos);
    419                  pIntc->atr &= ~_BIT(bit_pos);
    420                  break;
    421                case FALLING_EDGE:
    422                  pIntc->apr &= ~_BIT(bit_pos);
    423                  pIntc->atr |= _BIT(bit_pos);
    424                  break;
    425                case RISING_EDGE:
    426                  pIntc->apr |= _BIT(bit_pos);
    427                  pIntc->atr |= _BIT(bit_pos);
    428                  break;
    429                default:
    430                  ret_value = FALSE;
    431                  break;
    432              }
    433              if (TRUE == ret_value)
    434                irq_func_ptrs[source] = func_ptr;
    435            }
    436          
    437            return ret_value;
    438          }
    439          
    440          /***********************************************************************
    441           *
    442           * Function: int_enable
    443           *
    444           * Purpose: Enable an interrupt
    445           *
    446           * Processing:
    447           *     Enables the interrupt in the controller for the selected source.
    448           *
    449           * Parameters:
    450           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    451           *
    452           * Outputs: None
    453           *
    454           * Returns: Nothing
    455           *
    456           * Notes: None
    457           *
    458           **********************************************************************/
    459          void int_enable(INTERRUPT_SOURCE_T source)
    460          {
    461            BOOL_32 ret_value = FALSE;
    462            INTC_REGS_T *pIntc;
    463            UNS_32 bit_pos = 0;
    464          
    465            /* get the interrupt controller for the give interrupt source */
    466            ret_value = int_get_controller(source, &pIntc, &bit_pos);
    467            if (TRUE == ret_value)
    468            {
    469              /* cast the interrupt controller pointer*/
    470              pIntc->er |= _BIT(bit_pos);
    471            }
    472          }
    473          
    474          /***********************************************************************
    475           *
    476           * Function: int_disable
    477           *
    478           * Purpose: Disable an interrupt
    479           *
    480           * Processing:
    481           *     Masks the interrupt in the controller for the selected source.
    482           *
    483           * Parameters:
    484           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    485           *
    486           * Outputs: None
    487           *
    488           * Returns: Nothing
    489           *
    490           * Notes: None
    491           *
    492           **********************************************************************/
    493          void int_disable(INTERRUPT_SOURCE_T source)
    494          {
    495            BOOL_32 ret_value = FALSE;
    496            INTC_REGS_T *pIntc;
    497            UNS_32 bit_pos = 0;
    498          
    499            /* get the interrupt controller for the give interrupt source */
    500            ret_value = int_get_controller(source, &pIntc, &bit_pos);
    501            if (TRUE == ret_value)
    502            {
    503              /* cast the interrupt controller pointer*/
    504              pIntc->er &= ~_BIT(bit_pos);
    505            }
    506          }
    507          
    508          /***********************************************************************
    509           *
    510           * Function: int_pending
    511           *
    512           * Purpose: Check to see if a unmasked interrupt is pending
    513           *
    514           * Processing:
    515           *     If the status for the selected interrupt source is set,
    516           *     a TRUE is returned. Otherwise, FALSE is returned.
    517           *
    518           * Parameters:
    519           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    520           *
    521           * Outputs: None
    522           *
    523           * Returns: Returns TRUE or FALSE.
    524           *
    525           * Notes: None
    526           *
    527           **********************************************************************/
    528          BOOL_32 int_pending(INTERRUPT_SOURCE_T source)
    529          {
    530            BOOL_32 ret_value = FALSE;
    531            INTC_REGS_T *pIntc;
    532            UNS_32 bit_pos = 0;
    533          
    534            /* get the interrupt controller for the give interrupt source */
    535            ret_value = int_get_controller(source, &pIntc, &bit_pos);
    536            if (TRUE == ret_value)
    537            {
    538              /* cast the interrupt controller pointer*/
    539              ret_value = ((pIntc->sr & _BIT(bit_pos)) != 0);
    540            }
    541          
    542            return ret_value;
    543          }
    544          
    545          /***********************************************************************
    546           *
    547           * Function: int_raw_pending
    548           *
    549           * Purpose: Check to see if a raw interrupt is pending
    550           *
    551           * Processing:
    552           *     If the raw status for the selected interrupt source is set,
    553           *     a TRUE is returned. Otherwise, FALSE is returned.
    554           *
    555           * Parameters:
    556           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    557           *
    558           * Outputs: None
    559           *
    560           * Returns: Returns TRUE or FALSE.
    561           *
    562           * Notes: None
    563           *
    564           **********************************************************************/
    565          BOOL_32 int_raw_pending(INTERRUPT_SOURCE_T source)
    566          {
    567            BOOL_32 ret_value = FALSE;
    568            INTC_REGS_T *pIntc;
    569            UNS_32 bit_pos = 0;
    570          
    571            /* get the interrupt controller for the give interrupt source */
    572            ret_value = int_get_controller(source, &pIntc, &bit_pos);
    573            if (TRUE == ret_value)
    574            {
    575              /* cast the interrupt controller pointer*/
    576              ret_value = ((pIntc->rsr & _BIT(bit_pos)) != 0);
    577            }
    578          
    579            return ret_value;
    580          }
    581          
    582          /***********************************************************************
    583           *
    584           * Function: int_enabled
    585           *
    586           * Purpose: Check to see if an interrupt is enabled
    587           *
    588           * Processing:
    589           *     If the selected interrupt source is enabled, a TRUE is returned.
    590           *     Otherwise, FALSE is returned.
    591           *
    592           * Parameters:
    593           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    594           *
    595           * Outputs: None
    596           *
    597           * Returns: Returns TRUE or FALSE.
    598           *
    599           * Notes: None
    600           *
    601           **********************************************************************/
    602          BOOL_32 int_enabled(INTERRUPT_SOURCE_T source)
    603          {
    604            BOOL_32 ret_value = FALSE;
    605            INTC_REGS_T *pIntc;
    606            UNS_32 bit_pos = 0;
    607          
    608            /* get the interrupt controller for the give interrupt source */
    609            ret_value = int_get_controller(source, &pIntc, &bit_pos);
    610            if (TRUE == ret_value)
    611            {
    612              /* cast the interrupt controller pointer*/
    613              ret_value = ((pIntc->er & _BIT(bit_pos)) != 0);
    614            }
    615          
    616            return ret_value;
    617          }
    618          
    619          /***********************************************************************
    620           *
    621           * Function: int_clear
    622           *
    623           * Purpose: Clear a pending (latched) interrupt
    624           *
    625           * Processing:
    626           *     See function.
    627           *
    628           * Parameters:
    629           *     source   : Interrupt source of type INTERRUPT_SOURCE_T
    630           *
    631           * Outputs: None
    632           *
    633           * Returns: Returns TRUE or FALSE.
    634           *
    635           * Notes: None
    636           *
    637           **********************************************************************/
    638          BOOL_32 int_clear(INTERRUPT_SOURCE_T source)
    639          {
    640            BOOL_32 ret_value = FALSE;
    641            INTC_REGS_T *pIntc;
    642            UNS_32 bit_pos = 0;
    643          
    644            /* get the interrupt controller for the give interrupt source */
    645            ret_value = int_get_controller(source, &pIntc, &bit_pos);
    646            if (TRUE == ret_value)
    647            {
    648              /* Clear pending interrupt */
    649              pIntc->rsr = _BIT(bit_pos);
    650            }
    651          
    652            return ret_value;
    653          }
    654          
    655          /***********************************************************************
    656           *
    657           * Function: int_setup_irq_fiq
    658           *
    659           * Purpose: Setup an interrupt as an IRQ (FALSE) or and FIQ (TRUE)
    660           *
    661           * Processing:
    662           *     See function.
    663           *
    664           * Parameters:
    665           *     source  : Interrupt source of type INTERRUPT_SOURCE_T
    666           *     use_fiq : TRUE to use an FIQ interrupt type, FALSE for IRQ
    667           *
    668           * Outputs: None
    669           *
    670           * Returns: Returns TRUE or FALSE.
    671           *
    672           * Notes: None
    673           *
    674           **********************************************************************/
    675          BOOL_32 int_setup_irq_fiq(INTERRUPT_SOURCE_T source,
    676                                    BOOL_32 use_fiq)
    677          {
    678            BOOL_32 ret_value = FALSE;
    679            INTC_REGS_T *pIntc;
    680            UNS_32 bit_pos = 0;
    681          
    682            /* get the interrupt controller for the give interrupt source */
    683            ret_value = int_get_controller(source, &pIntc, &bit_pos);
    684            if (use_fiq == TRUE)
    685            {
    686              /* FIQ interrupt type */
    687              pIntc->itr |= _BIT(bit_pos);
    688            }
    689            else
    690            {
    691              /* IRQ interrupt type */
    692              pIntc->itr &= ~_BIT(bit_pos);
    693            }
    694          
    695            return ret_value;
    696          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   int_clear
        24   -> int_get_controller
      24   int_disable
        24   -> int_get_controller
      24   int_enable
        24   -> int_get_controller
      24   int_enabled
        24   -> int_get_controller
       0   int_get_controller
      16   int_initialize
        16   -> int_write_arm_vec_table
      16   int_install_arm_vec_handler
        16   -> cp15_force_cache_coherence
        16   -> int_write_arm_vec_table
      32   int_install_ext_irq_handler
        32   -> int_get_controller
       0   int_install_irq_handler
      24   int_pending
        24   -> int_get_controller
      24   int_raw_pending
        24   -> int_get_controller
      24   int_setup_irq_fiq
        24   -> int_get_controller
      24   int_write_arm_vec_table
        24   -> cp15_force_cache_coherence
        24   -> cp15_get_mmu_control_reg
        24 __aeabi_idiv


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      84  int_clear
      92  int_disable
      88  int_enable
      88  int_enabled
     192  int_get_controller
     324  int_initialize
     228  int_install_arm_vec_handler
     392  int_install_ext_irq_handler
      56  int_install_irq_handler
      88  int_pending
      88  int_raw_pending
     128  int_setup_irq_fiq
     148  int_write_arm_vec_table
     384  irq_func_ptrs
       4  vecarea

 
   388 bytes in section .bss
 2 044 bytes in section .text
 
 2 044 bytes of CODE memory
   388 bytes of DATA memory

Errors: none
Warnings: none
