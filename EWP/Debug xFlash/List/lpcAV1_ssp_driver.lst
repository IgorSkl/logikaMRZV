###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        12/Oct/2015  11:05:02
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR
#        projects\HR1_0100_00_I720_new2\LIB\CDL_AV0\csps\lpc32xx\source\lpcAV1_ssp_driver.c
#    Command line =  
#        "D:\IAR
#        projects\HR1_0100_00_I720_new2\LIB\CDL_AV0\csps\lpc32xx\source\lpcAV1_ssp_driver.c"
#        -D _STATIC_MEMORY_BOOT -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\List\lpcAV1_ssp_driver.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\Obj\lpcAV1_ssp_driver.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\LIB\CDL_AV0\csps\lpc32xx\source\lpcAV1_ssp_driver.c
      1          /***********************************************************************
      2           * $Id: lpc32xx_ssp_driver.c 30870 2009-07-05 10:16:16Z anderslu $
      3           *
      4           * Project: LPC32XX SSP driver
      5           *
      6           * Description:
      7           *     This file contains driver support for the SSP module on the
      8           *     LPC32XX
      9           *
     10           ***********************************************************************
     11           * Software that is described herein is for illustrative purposes only
     12           * which provides customers with programming information regarding the
     13           * products. This software is supplied "AS IS" without any warranties.
     14           * NXP Semiconductors assumes no responsibility or liability for the
     15           * use of the software, conveys no license or title under any patent,
     16           * copyright, or mask work right to the product. NXP Semiconductors
     17           * reserves the right to make changes in the software without
     18           * notification. NXP Semiconductors also make no representation or
     19           * warranty that such application will be suitable for the specified
     20           * use without further testing or modification.
     21           **********************************************************************/
     22          #include "../include/lpc32xx_intc_driver.h"
     23          #include "../include/lpc32xx_clkpwr_driver.h"
     24          #include "../include/lpc32xx_ssp_driver.h"
     25          #include "lpc_irq_fiq.h"
     26          /***********************************************************************
     27           * SSP driver private data and types
     28           **********************************************************************/
     29          
     30          /* SSP device configuration structure type */
     31          typedef struct
     32          {
     33            BOOL_32 init;          /* Device initialized flag */
     34            SSP_REGS_T *regptr;    /* Pointer to SSP registers */
     35            SSP_CBS_T cbs;         /* Interrupt callbacks */
     36            INT_32 thisdev;        /* 0 or 1, SSP number */
     37            INT_32 dsize;          /* Size of data (in bytes) */
     38          } SSP_DRVDAT_T;
     39          
     40          /* SSP device configuration structure */
     41          static SSP_DRVDAT_T sspdrv [2];
     42          
     43          /* Clocks for each SSP */
     44          static const CLKPWR_CLK_T sspclks [2] =
     45            {CLKPWR_SSP0_CLK, CLKPWR_SSP1_CLK};
     46          
     47          /***********************************************************************
     48           * SSP driver private functions
     49           **********************************************************************/
     50          
     51          /***********************************************************************
     52           *
     53           * Function: ssp_set_clock
     54           *
     55           * Purpose: Sets or resets the serial clock rate of the SSP interface
     56           *          (in Hz)
     57           *
     58           * Processing:
     59           *     Determine the best dividers to generate the closest possible
     60           *     target clock rate for the SSP.
     61           *
     62           * Parameters:
     63           *     psspdrvdat   : Pointer to driver data
     64           *     target_clock : The value in Hz for the new SSP serial clock
     65           *
     66           * Outputs: None
     67           *
     68           * Returns: _ERROR if the configuration setup failed, otherwise _NO_ERROR
     69           *
     70           * Notes: None
     71           *
     72           **********************************************************************/
     73          static STATUS Ssp_set_clock(SSP_DRVDAT_T *psspdrvdat,
     74                                      UNS_32 target_clock)
     75          {
     76            UNS_32 control, prescale, cr0_div, cmp_clk, ssp_clk;
     77          
     78            /* The SSP clock is derived from the (main system oscillator / 2),
     79               so compute the best divider from that clock */
     80            ssp_clk = clkpwr_get_clock_rate(sspclks [psspdrvdat->thisdev]);
     81          
     82            /* Find closest divider to get at or under the target frequency.
     83               Use smallest prescaler possible and rely on the divider to get
     84               the closest target frequency */
     85            cr0_div = 0;
     86            cmp_clk = 0xFFFFFFFF;
     87            prescale = 2;
     88            while (cmp_clk > target_clock)
     89            {
     90              cmp_clk = ssp_clk / ((cr0_div + 1) * prescale);
     91              if (cmp_clk > target_clock)
     92              {
     93                cr0_div++;
     94                if (cr0_div > 0xFF)
     95                {
     96                  cr0_div = 0;
     97                  prescale += 2;
     98                }
     99              }
    100            }
    101          
    102            /* Write computed prescaler and divider back to register */
    103            control = psspdrvdat->regptr->cr0 &= ~(SSP_CR0_SCR(0xFF));
    104            psspdrvdat->regptr->cr0 = control | SSP_CR0_SCR(cr0_div - 1);
    105            psspdrvdat->regptr->cpsr = prescale;
    106          
    107            return _NO_ERROR;
    108          }
    109          
    110          /***********************************************************************
    111           *
    112           * Function: ssp_configure
    113           *
    114           * Purpose: Configure SSP interface
    115           *
    116           * Processing:
    117           *     Setup the general capabilities of the SSP controller.
    118           *
    119           * Parameters:
    120           *     psspcfg : Pointer to an SSP_CONFIG_T structure
    121           *     psspdrvdat: Pointer to driver data
    122           *
    123           * Outputs: None
    124           *
    125           * Returns:
    126           *     _ERROR if the configuration setup failed, otherwise _NO_ERROR
    127           *
    128           * Notes: None
    129           *
    130           **********************************************************************/
    131          static STATUS Ssp_configure(SSP_CONFIG_T *psspcfg,
    132                                      SSP_DRVDAT_T *psspdrvdat)
    133          {
    134            UNS_32 tmp0, tmp1;
    135            STATUS setup = _NO_ERROR;
    136            SSP_REGS_T *psspregs = psspdrvdat->regptr;
    137          
    138            /* Setup CR0 word first */
    139            tmp0 = 0;
    140            if ((psspcfg->databits >= 4) && (psspcfg->databits <= 16))
    141            {
    142              tmp0 = SSP_CR0_DSS(psspcfg->databits);
    143            }
    144            else
    145            {
    146              setup = _ERROR;
    147            }
    148            if (psspcfg->databits <= 8)
    149            {
    150              psspdrvdat->dsize = 1;
    151            }
    152            else
    153            {
    154              psspdrvdat->dsize = 2;
    155            }
    156          
    157            /* Mode */
    158            if (((psspcfg->mode & ~SSP_CR0_PRT_MSK) != 0) ||
    159          	  (psspcfg->mode == (0x3 << 4)))
    160            {
    161              setup = _ERROR;
    162            }
    163            tmp0 |= psspcfg->mode;
    164          
    165            /* SPI clock control */
    166            if (psspcfg->highclk_spi_frames == TRUE)
    167            {
    168              tmp0 |= SSP_CR0_CPOL(1);
    169            }
    170            if (psspcfg->usesecond_clk_spi == TRUE)
    171            {
    172              tmp0 |= SSP_CR0_CPHA(1);
    173            }
    174          
    175            /* Master/slave mode control */
    176            tmp1 = 0;
    177            if (psspcfg->master_mode == FALSE)
    178            {
    179              tmp1 = SSP_CR1_MS;
    180            }
    181          
    182            /* Setup clock */
    183            if (setup == _NO_ERROR)
    184            {
    185              psspregs->cr0 = tmp0;
    186              psspregs->cr1 = tmp1;
    187              setup = Ssp_set_clock(psspdrvdat, psspcfg->ssp_clk);
    188            }
    189          
    190            return setup;
    191          }
    192          
    193          /***********************************************************************
    194           *
    195           * Function: ssp_standard_interrupt
    196           *
    197           * Purpose: SSP standard interrupt function
    198           *
    199           * Processing:
    200           *     Handle the SSP interrupt from SSP0 or SSP1. Route to the
    201           *     necessary callback function as needed. Disable interrupt if a
    202           *     callback is not associated with it.
    203           *
    204           * Parameters:
    205           *     psspdrvdat : Pointer to an SSP driver data
    206           *
    207           * Outputs: None
    208           *
    209           * Returns: Nothing
    210           *
    211           * Notes: None
    212           *
    213           **********************************************************************/
    214          static void Ssp_standard_interrupt(SSP_DRVDAT_T *psspdrvdat)
    215          {
    216            SSP_REGS_T *psspregs = psspdrvdat->regptr;
    217          
    218            /* Interrupt was due to a receive data FIFO service request */
    219            if ((psspregs->mis &
    220                 (SSP_RIS_RTRIS | SSP_MIS_RXMIS | SSP_MIS_RORMIS)) != 0)
    221            {
    222              if (psspdrvdat->cbs.rxcb == NULL)
    223              {
    224                /* Disable interrupt, no support for it */
    225                psspregs->imsc &= ~(SSP_IMSC_RTIM | SSP_IMSC_RXIM);
    226              }
    227              else
    228              {
    229                /* Handle callback */
    230                psspdrvdat->cbs.rxcb();
    231                psspregs->icr = (SSP_ICR_RORIC | SSP_ICR_RTIC);
    232              }
    233            }
    234          
    235            /* Interrupt was due to a transmit data FIFO service request */
    236            if ((psspregs->mis & SSP_MIS_TXMIS) != 0)
    237            {
    238              if (psspdrvdat->cbs.txcb == NULL)
    239              {
    240                /* Disable interrupt, no support for it */
    241                psspregs->imsc &= ~SSP_IMSC_TXIM;
    242              }
    243              else
    244              {
    245                /* Handle callback */
    246                psspdrvdat->cbs.txcb();
    247              }
    248            }
    249          }
    250          
    251          /***********************************************************************
    252           * SSP driver public functions
    253           **********************************************************************/
    254          
    255          /***********************************************************************
    256           *
    257           * Function: ssp_open
    258           *
    259           * Purpose: Open the SSP
    260           *
    261           * Processing:
    262           *     Initializes the SSP clocks and default state.
    263           *
    264           * Parameters:
    265           *     ipbase: SSP descriptor device address
    266           *     arg   : Pointer to config structure, or NULL if not used
    267           *
    268           * Outputs: None
    269           *
    270           * Returns: The pointer to a SSP config structure or 0
    271           *
    272           * Notes: None
    273           *
    274           **********************************************************************/
    275          INT_32 Ssp_open(void *ipbase,
    276                          INT_32 arg)
    277          {
    278            SSP_CONFIG_T ssp_cfg, *psspcfg;
    279            volatile UNS_32 tmp;
    280            SSP_REGS_T *psspregs = (SSP_REGS_T *) ipbase;
    281            SSP_DRVDAT_T *psspdrvdat = NULL;
    282            INT_32 status = 0;
    283          
    284            /* Map SSP registers to data index */
    285            if (psspregs == SSP0)
    286            {
    287              psspdrvdat = (SSP_DRVDAT_T *) & sspdrv [0];
    288              psspdrvdat->thisdev = 0;
    289            }
    290            else if (psspregs == SSP1)
    291            {
    292              psspdrvdat = (SSP_DRVDAT_T *) & sspdrv [1];
    293              psspdrvdat->thisdev = 1;
    294            }
    295          
    296            if (psspdrvdat != NULL)
    297            {
    298              if (psspdrvdat->init == FALSE)
    299              {
    300                /* Save and return address of peripheral block */
    301                psspdrvdat->regptr = (SSP_REGS_T *) ipbase;
    302          
    303                /* Enable SSP clock */
    304                clkpwr_clk_en_dis(sspclks[psspdrvdat->thisdev], 1);
    305          
    306                /* No initial callbacks */
    307                psspdrvdat->cbs.txcb = NULL;
    308                psspdrvdat->cbs.rxcb = NULL;
    309          
    310                /* Initialize device */
    311                if (arg == 0)
    312                {
    313                  /* Create and use defaults */
    314                  ssp_cfg.databits = 8;
    315                  ssp_cfg.mode = SSP_CR0_FRF_SPI;
    316                  ssp_cfg.highclk_spi_frames = TRUE;
    317                  ssp_cfg.usesecond_clk_spi = FALSE;
    318                  ssp_cfg.ssp_clk = 1000000;
    319                  ssp_cfg.master_mode = TRUE;
    320                  psspcfg = &ssp_cfg;
    321                }
    322                else
    323                {
    324                  psspcfg = (SSP_CONFIG_T *) arg;
    325                }
    326                if (Ssp_configure(psspcfg, psspdrvdat) != _ERROR)
    327                {
    328                  /* Device is valid */
    329                  psspdrvdat->init = TRUE;
    330                  status = (INT_32) psspdrvdat;
    331                }
    332                else
    333                {
    334                  clkpwr_clk_en_dis(sspclks[psspdrvdat->thisdev], 0);
    335                }
    336          
    337                /* Empty FIFO */
    338                while ((psspdrvdat->regptr->sr & SSP_SR_RNE) != 0)
    339                {
    340                  tmp = psspdrvdat->regptr->data;
    341                }
    342          
    343                /* Clear latched interrupts */
    344                psspdrvdat->regptr->icr = (SSP_ICR_RORIC | SSP_ICR_RTIC);
    345          
    346                /* Enable interrupts */
    347                psspdrvdat->regptr->imsc = (SSP_IMSC_RORIM |
    348                                            SSP_IMSC_RTIM | SSP_IMSC_RXIM);
    349              }
    350            }
    351          
    352            return status;
    353          }
    354          
    355          /***********************************************************************
    356           *
    357           * Function: ssp_close
    358           *
    359           * Purpose: Close the SSP
    360           *
    361           * Processing:
    362           *     Disable the SSP clock and device.
    363           *
    364           * Parameters:
    365           *     devid: Pointer to SSP config structure
    366           *
    367           * Outputs: None
    368           *
    369           * Returns: The status of the close operation
    370           *
    371           * Notes: None
    372           *
    373           **********************************************************************/
    374          STATUS Ssp_close(INT_32 devid)
    375          {
    376            SSP_DRVDAT_T *sspdrvdat = (SSP_DRVDAT_T *) devid;
    377            STATUS status = _ERROR;
    378          
    379            if (sspdrvdat->init == TRUE)
    380            {
    381              /* 'Uninitialize' device */
    382              sspdrvdat->init = FALSE;
    383              status = _NO_ERROR;
    384          
    385              /* Disable device */
    386              sspdrvdat->regptr->cr1 &= ~SSP_CR1_SSP_ENABLE;
    387          
    388              /* Disable clock */
    389              clkpwr_clk_en_dis(sspclks[sspdrvdat->thisdev], 0);
    390            }
    391          
    392            return status;
    393          }
    394          
    395          /***********************************************************************
    396           *
    397           * Function: ssp_ioctl
    398           *
    399           * Purpose: SSP configuration block
    400           *
    401           * Processing:
    402           *     This function is a large case block. Based on the passed function
    403           *     and option values, set or get the appropriate SSP parameter.
    404           *
    405           * Parameters:
    406           *     devid: Pointer to SSP config structure
    407           *     cmd:   ioctl command
    408           *     arg:   ioctl argument
    409           *
    410           * Outputs: None
    411           *
    412           * Returns: The status of the ioctl operation
    413           *
    414           * Notes: None
    415           *
    416           **********************************************************************/
    417          STATUS Ssp_ioctl(INT_32 devid,
    418                           INT_32 cmd,
    419                           INT_32 arg)
    420          {
    421            SSP_REGS_T *sspregs;
    422            SSP_CBS_T *psspcb;
    423            UNS_32 sspclk, tmp, tmp2;
    424            SSP_DRVDAT_T *sspdrvdat = (SSP_DRVDAT_T *) devid;
    425            STATUS status = _ERROR;
    426          
    427            if (sspdrvdat->init == TRUE)
    428            {
    429              status = _NO_ERROR;
    430              sspregs = sspdrvdat->regptr;
    431          
    432              switch (cmd)
    433              {
    434                case SSP_ENABLE:
    435                  if (arg == 1)
    436                  {
    437                    /* Enable SSP */
    438                    sspregs->cr1 |= SSP_CR1_SSP_ENABLE;
    439                  }
    440                  else
    441                  {
    442                    /* Disable SSP */
    443                    sspregs->cr1 &= ~SSP_CR1_SSP_ENABLE;
    444                  }
    445                  break;
    446          
    447                case SSP_CONFIG:
    448                  status = Ssp_configure((SSP_CONFIG_T *) arg,
    449                                         sspdrvdat);
    450                  break;
    451          
    452                case SSP_ENABLE_LOOPB:
    453                  /* Enable or disable loopback mode */
    454                  if (arg == 1)
    455                  {
    456                    /* Enable SSP loopback mode */
    457                    sspregs->cr1 |= SSP_CR1_LBM;
    458                  }
    459                  else
    460                  {
    461                    /* Disable SSP loopback mode */
    462                    sspregs->cr1 &= ~SSP_CR1_LBM;
    463                  }
    464                  break;
    465          
    466                case SSP_SO_DISABLE:
    467                  /* Slave output disable */
    468                  if (arg != 0)
    469                  {
    470                    sspregs->cr1 |= SSP_CR1_SOD;
    471                  }
    472                  else
    473                  {
    474                    sspregs->cr1 &= ~SSP_CR1_SOD;
    475                  }
    476                  break;
    477          
    478                case SSP_SET_CALLBACKS:
    479                  psspcb = (SSP_CBS_T *) arg;
    480                  sspdrvdat->cbs.txcb = psspcb->txcb;
    481                  sspdrvdat->cbs.rxcb = psspcb->rxcb;
    482                  break;
    483          
    484                case SSP_CLEAR_INTS:
    485                  sspregs->icr = ((UNS_32) arg) &
    486                                 (SSP_ICR_RORIC | SSP_ICR_RTIC);
    487                  break;
    488          
    489                case SSP_GET_STATUS:
    490                  /* Return an SSP status */
    491                  switch (arg)
    492                  {
    493                    case SSP_CLOCK_ST:
    494                      /* Return clock speed of SSP interface */
    495                      tmp = (sspregs->cr0 & SSP_CR0_SCR(0xFF)) >> 8;
    496                      tmp2 = sspregs->cpsr;
    497                      if (tmp2 < 1)
    498                      {
    499                        /* Not a valid value, so use a divider of 1 */
    500                        tmp2 = 1;
    501                      }
    502          
    503                      /* Compute SSP bit clock rate */
    504                      sspclk = clkpwr_get_clock_rate(
    505                                 sspclks [sspdrvdat->thisdev]);
    506                      status = sspclk / (tmp2 * (tmp + 1));
    507                      break;
    508          
    509                    case SSP_PENDING_INTS_ST:
    510                      status = sspregs->mis;
    511                      break;
    512          
    513                    case SSP_RAW_INTS_ST:
    514                      status = sspregs->ris;
    515                      break;
    516          
    517                    default:
    518                      /* Unsupported parameter */
    519                      status = LPC_BAD_PARAMS;
    520                      break;
    521                  }
    522                  break;
    523          
    524                default:
    525                  /* Unsupported parameter */
    526                  status = LPC_BAD_PARAMS;
    527              }
    528            }
    529          
    530            return status;
    531          }
    532          
    533          /***********************************************************************
    534           *
    535           * Function: ssp_read
    536           *
    537           * Purpose: SSP read function
    538           *
    539           * Processing:
    540           *     Reads data from the SSP FIFO.
    541           *
    542           * Parameters:
    543           *     devid:     Pointer to SSP config structure
    544           *     buffer:    Pointer to data buffer to copy to (2 byte aligned)
    545           *     max_fifo:  Number of items (of programmed data width) to read
    546           *
    547           * Outputs: None
    548           *
    549           * Returns: Number of items read from the SSP FIFO
    550           *
    551           * Notes: None
    552           *
    553           **********************************************************************/
    554          INT_32 Ssp_read(INT_32 devid,
    555                          void *buffer,
    556                          INT_32 max_fifo)
    557          {
    558            volatile UNS_32 tmp1;
    559            INT_32 count = 0;
    560            SSP_DRVDAT_T *sspcfgptr = (SSP_DRVDAT_T *) devid;
    561            UNS_16 *data16 = (UNS_16 *) buffer;
    562            UNS_8 *data8 = (UNS_8 *) buffer;
    563          
    564            if (sspcfgptr->init == TRUE)
    565            {
    566              while ((max_fifo > 0) &&
    567                     ((sspcfgptr->regptr->sr & SSP_SR_RNE) != 0))
    568              {
    569                tmp1 = sspcfgptr->regptr->data;
    570                if (sspcfgptr->dsize == 1)
    571                {
    572                  *data8 = (UNS_8) tmp1;
    573                  data8++;
    574                }
    575                else
    576                {
    577                  *data16 = (UNS_16) tmp1;
    578                  data16++;
    579                }
    580          
    581                /* Increment data count and decrement buffer size count */
    582                count++;
    583                max_fifo--;
    584              }
    585            }
    586          
    587            return count;
    588          }
    589          
    590          /***********************************************************************
    591           *
    592           * Function: ssp_write
    593           *
    594           * Purpose: SSP write function
    595           *
    596           * Processing:
    597           *     Write data to the SSP FIFO.
    598           *
    599           * Parameters:
    600           *     devid:   Pointer to SSP config structure
    601           *     buffer:  Pointer to data buffer to copy from (2 byte aligned)
    602           *     n_fifo:  Number of times to write data to the transmit fifo
    603           *
    604           * Outputs: None
    605           *
    606           * Returns: Number of items written to the transmit fifo
    607           *
    608           * Notes: None
    609           *
    610           **********************************************************************/
    611          INT_32 Ssp_write(INT_32 devid,
    612                           void *buffer,
    613                           INT_32 n_fifo)
    614          {
    615            INT_32 count = 0;
    616            SSP_DRVDAT_T *sspcfgptr = (SSP_DRVDAT_T *) devid;
    617            UNS_16 *data16 = (UNS_16 *) buffer;
    618            UNS_8 *data8 = (UNS_8 *) buffer;
    619          
    620            if (sspcfgptr->init == TRUE)
    621            {
    622              /* Loop until transmit ring buffer is full or until n_bytes
    623                 expires */
    624          	//devid = sspcfgptr->regptr->sr;
    625          	if(sspcfgptr->regptr->sr&SSP_SR_RFF)
    626          	devid = sspcfgptr->regptr->sr;
    627          	
    628              while ((n_fifo > 0) &&
    629                     ((sspcfgptr->regptr->sr & SSP_SR_TFE) != 0)&&//SSP_SR_TNF
    630          		   ((sspcfgptr->regptr->sr & SSP_SR_RFF) == 0)
    631          		   )
    632              {
    633                if (sspcfgptr->dsize == 1)
    634                {
    635                  sspcfgptr->regptr->data = (UNS_32) * data8;
    636                  data8++;
    637                }
    638                else
    639                {
    640                  sspcfgptr->regptr->data =(UNS_32) * data16;
    641                  data16++;
    642                }
    643          
    644                /* Increment data count and decrement buffer size count */
    645                count++;
    646                n_fifo--;
    647          	  if (count>=8) break;
    648              }
    649          
    650              /* Enable transmit interrupt */
    651              if (count > 0)
    652              {
    653                sspcfgptr->regptr->imsc |= SSP_IMSC_TXIM;
    654              }
    655            }
    656          
    657            return count;
    658          }
    659          
    660          /***********************************************************************
    661           *
    662           * Function: ssp0_int
    663           *
    664           * Purpose: SSP0 interrupt handler
    665           *
    666           * Processing:
    667           *     Handle the SSP0 interrupt.
    668           *
    669           * Parameters: None
    670           *
    671           * Outputs: None
    672           *
    673           * Returns: Nothing
    674           *
    675           * Notes: None
    676           *
    677           **********************************************************************/
    678          void Ssp0_int(void)
    679          {
    680            Ssp_standard_interrupt(&sspdrv [0]);
    681          }
    682          
    683          /***********************************************************************
    684           *
    685           * Function: ssp1_int
    686           *
    687           * Purpose: SSP1 interrupt handler
    688           *
    689           * Processing:
    690           *     Handle the SSP1 interrupt.
    691           *
    692           * Parameters: None
    693           *
    694           * Outputs: None
    695           *
    696           * Returns: Nothing
    697           *
    698           * Notes: None
    699           *
    700           **********************************************************************/
    701          void Ssp1_int(void)
    702          {
    703            Ssp_standard_interrupt(&sspdrv [1]);
    704          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Ssp0_int
         8   -> Ssp_standard_interrupt
       8   Ssp1_int
         8   -> Ssp_standard_interrupt
      16   Ssp_close
        16   -> clkpwr_clk_en_dis
      32   Ssp_configure
        32   -> Ssp_set_clock
      48   Ssp_ioctl
        48   -> Ssp_configure
        48   -> clkpwr_get_clock_rate
        48 __aeabi_uidiv
      56   Ssp_open
        56   -> Ssp_configure
        56   -> clkpwr_clk_en_dis
      20   Ssp_read
      32   Ssp_set_clock
        32   -> clkpwr_get_clock_rate
        32 __aeabi_uidiv
      16   Ssp_standard_interrupt
        16   -- Indirect call
      16   Ssp_write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
      16  Ssp0_int
      16  Ssp1_int
      92  Ssp_close
     256  Ssp_configure
     412  Ssp_ioctl
     356  Ssp_open
     128  Ssp_read
     180  Ssp_set_clock
     120  Ssp_standard_interrupt
     200  Ssp_write
       2  sspclks
      48  sspdrv

 
    48 bytes in section .bss
     2 bytes in section .rodata
 1 788 bytes in section .text
 
 1 788 bytes of CODE  memory
     2 bytes of CONST memory
    48 bytes of DATA  memory

Errors: none
Warnings: none
