###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        12/Oct/2015  11:05:05
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\SettingIci\SettingIci_OF.c
#    Command line =  
#        "D:\IAR projects\HR1_0100_00_I720_new2\SettingIci\SettingIci_OF.c" -D
#        _STATIC_MEMORY_BOOT -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\List\SettingIci_OF.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\Obj\SettingIci_OF.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\SettingIci\SettingIci_OF.c
      1          #include "lpc_types.h"
      2          #include "lpc_irq_fiq.h"
      3          #include "lpc_arm922t_cp15_driver.h"
      4          
      5          #include "lpc32xx_hstimer.h"
      6          #include "lpc32xx_ssp.h"
      7          #include "lpc32xx_gpio.h"
      8          
      9          #include "lpc32xx_intc_driver.h"
     10          #include "lpc32xx_clkpwr_driver.h"
     11          
     12          #include "arm926ej_cp15_drv.h"
     13          #include "ttbl.h"
     14          
     15          #include <stdio.h>
     16          #include <string.h>
     17          
     18          #include "psuperVisor\supermanager.h"
     19          
     20          #include "component\componentdef.h"
     21          #include "psuperVisor\psvisor_helpdef.h"
     22          
     23          #include "psuperVisor\psvisor_helpfnc.h"
     24          #include "SettingIci\SettingIci.h"
     25          #include "virtualmenu\systemmenufnc.h"
     26          #include "virtualMenu\rangmanagerfnc.h"
     27          
     28          #include "toSpeedOptim.h"
     29          #include "toSpeedDIS.h"
     30          
     31          #include "header.h"
     32          #include "ici_r_ef.h"
     33          
     34          #define _HIDE_COMPONENT
     35          #include "OFComponent.c"
     36          //#include "MTZ1Component.c"
     37          //#include "MTZ2Component.c"
     38          //#include "TZNP1Component.c"
     39          //#include "DZ1Component.c"
     40          //#include "DZ2Component.c"
     41          
     42          extern char chProtectTableComeIn;
     43          extern char chResultCallGetMeasPrt;
     44          //extern tic long lDemo_IA,lDemo_IB,lDemo_IC;
     45          extern  long lMtz1,lMtz1Tmr,lSt1,lSt2, lst3, lst4;
     46          extern __MEASUREMENT_TO_PROTECTION TestMeasProtection;
     47          extern MaskaOTAPVUROVOFcmd struct_maskaOTAPVUROVOFcmd;//маски для 16 опред функций UROV APV OT
     48          
     49          //int puskOFotZPLUS();//int num);
     50          
     51            puskOFfunction *pntPuskOF;//указатель на ф-цию
     52          
     53          
     54          //void puskOFModern(puskOFfunction *pntPuskOF);//, int num);
     55          
     56          //void SetCmdToUVV(int typRang);
     57          //void SetCmdToUVV(int typRang)
     58          //{
     59          //}
     60          /*
     61          typedef int (puskOFfunction(int cmd));//int num));//указат на ф-цию номер команды
     62          int puskOFotZPLUS(int cmd);
     63          int puskOFotZMINUS(int cmd);
     64          int puskOFotZBLK(int cmd);
     65          void puskOFModern(puskOFfunction *pntPuskOF, int typRang);//, int num);
     66          */
     67          
     68          void  SettingIci_OF()
     69          {
     70            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OFcmdMaska[i]=0;//Очистить
     71            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OFcmdMaska[i]=0;//Очистить
     72            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OFcmdMaska[i]=0;//Очистить
     73          
     74            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF2cmdMaska[i]=0;//Очистить
     75            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF2cmdMaska[i]=0;//Очистить
     76            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF2cmdMaska[i]=0;//Очистить
     77          
     78            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF3cmdMaska[i]=0;//Очистить
     79            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF3cmdMaska[i]=0;//Очистить
     80            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF3cmdMaska[i]=0;//Очистить
     81          
     82            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF4cmdMaska[i]=0;//Очистить
     83            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF4cmdMaska[i]=0;//Очистить
     84            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF4cmdMaska[i]=0;//Очистить
     85          
     86            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF5cmdMaska[i]=0;//Очистить
     87            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF5cmdMaska[i]=0;//Очистить
     88            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF5cmdMaska[i]=0;//Очистить
     89          
     90            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF6cmdMaska[i]=0;//Очистить
     91            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF6cmdMaska[i]=0;//Очистить
     92            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF6cmdMaska[i]=0;//Очистить
     93          
     94            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF7cmdMaska[i]=0;//Очистить
     95            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF7cmdMaska[i]=0;//Очистить
     96            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF7cmdMaska[i]=0;//Очистить
     97          
     98            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF8cmdMaska[i]=0;//Очистить
     99            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF8cmdMaska[i]=0;//Очистить
    100            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF8cmdMaska[i]=0;//Очистить
    101          
    102            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF9cmdMaska[i]=0;//Очистить
    103            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF9cmdMaska[i]=0;//Очистить
    104            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF9cmdMaska[i]=0;//Очистить
    105          
    106            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF10cmdMaska[i]=0;//Очистить
    107            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF10cmdMaska[i]=0;//Очистить
    108            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF10cmdMaska[i]=0;//Очистить
    109          
    110            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF11cmdMaska[i]=0;//Очистить
    111            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF11cmdMaska[i]=0;//Очистить
    112            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF11cmdMaska[i]=0;//Очистить
    113          
    114            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF12cmdMaska[i]=0;//Очистить
    115            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF12cmdMaska[i]=0;//Очистить
    116            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF12cmdMaska[i]=0;//Очистить
    117          
    118            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF13cmdMaska[i]=0;//Очистить
    119            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF13cmdMaska[i]=0;//Очистить
    120            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF13cmdMaska[i]=0;//Очистить
    121          
    122            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF14cmdMaska[i]=0;//Очистить
    123            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF14cmdMaska[i]=0;//Очистить
    124            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF14cmdMaska[i]=0;//Очистить
    125          
    126            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF15cmdMaska[i]=0;//Очистить
    127            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF15cmdMaska[i]=0;//Очистить
    128            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF15cmdMaska[i]=0;//Очистить
    129          
    130            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF16cmdMaska[i]=0;//Очистить
    131            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF16cmdMaska[i]=0;//Очистить
    132            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF16cmdMaska[i]=0;//Очистить
    133          
    134          
    135          //OFuncDsc   ownrOFunc;  //Опред. функции
    136          //unsigned char uch_ar_type_df[NUM_DEF_FUN];
    137          //Тип Определяемой функции1
    138          //	1- прямая
    139          //	2 - инверсная
    140          
    141          
    142          //OF1
    143              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[0];
    144            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF1, lMtz1Tmr);//выдержка
    145          //	длительность импульса определяемой функции1
    146              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[0];
    147            SetUstToClon(OF_COMP1,  1, MNGWORK_OF1, lMtz1Tmr);//выдержка OF1
    148          
    149          //OF2
    150              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[1];
    151            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF2, lMtz1Tmr);//выдержка
    152          //	длительность импульса определяемой функции1
    153              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[1];
    154            SetUstToClon(OF_COMP1,  1, MNGWORK_OF2, lMtz1Tmr);//выдержка OF2
    155          
    156          //OF3
    157              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[2];
    158            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF3, lMtz1Tmr);//выдержка
    159          //	длительность импульса определяемой функции1
    160              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[2];
    161            SetUstToClon(OF_COMP1,  1, MNGWORK_OF3, lMtz1Tmr);//выдержка OF2
    162          
    163          //OF4
    164              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[3];
    165            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF4, lMtz1Tmr);//выдержка
    166          //	длительность импульса определяемой функции1
    167              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[3];
    168            SetUstToClon(OF_COMP1,  1, MNGWORK_OF4, lMtz1Tmr);//выдержка OF2
    169          
    170          //OF5
    171              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[4];
    172            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF5, lMtz1Tmr);//выдержка
    173          //	длительность импульса определяемой функции1
    174              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[4];
    175            SetUstToClon(OF_COMP1,  1, MNGWORK_OF5, lMtz1Tmr);//выдержка OF2
    176          
    177          //OF6
    178              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[5];
    179            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF6, lMtz1Tmr);//выдержка
    180          //	длительность импульса определяемой функции1
    181              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[5];
    182            SetUstToClon(OF_COMP1,  1, MNGWORK_OF6, lMtz1Tmr);//выдержка OF2
    183          
    184          //OF7
    185              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[6];
    186            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF7, lMtz1Tmr);//выдержка
    187          //	длительность импульса определяемой функции1
    188              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[6];
    189            SetUstToClon(OF_COMP1,  1, MNGWORK_OF7, lMtz1Tmr);//выдержка OF2
    190          
    191          //OF8
    192              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[7];
    193            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF8, lMtz1Tmr);//выдержка
    194          //	длительность импульса определяемой функции1
    195              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[7];
    196            SetUstToClon(OF_COMP1,  1, MNGWORK_OF8, lMtz1Tmr);//выдержка OF2
    197          
    198          //OF9
    199              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[8];
    200            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF9, lMtz1Tmr);//выдержка
    201          //	длительность импульса определяемой функции1
    202              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[8];
    203            SetUstToClon(OF_COMP1,  1, MNGWORK_OF9, lMtz1Tmr);//выдержка OF2
    204          
    205          //OF10
    206              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[9];
    207            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF10, lMtz1Tmr);//выдержка
    208          //	длительность импульса определяемой функции1
    209              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[9];
    210            SetUstToClon(OF_COMP1,  1, MNGWORK_OF10, lMtz1Tmr);//выдержка OF2
    211          
    212          //OF11
    213              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[10];
    214            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF11, lMtz1Tmr);//выдержка
    215          //	длительность импульса определяемой функции1
    216              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[10];
    217            SetUstToClon(OF_COMP1,  1, MNGWORK_OF11, lMtz1Tmr);//выдержка OF2
    218          
    219          //OF12
    220              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[11];
    221            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF12, lMtz1Tmr);//выдержка
    222          //	длительность импульса определяемой функции1
    223              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[11];
    224            SetUstToClon(OF_COMP1,  1, MNGWORK_OF12, lMtz1Tmr);//выдержка OF2
    225          
    226          //OF13
    227              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[12];
    228            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF13, lMtz1Tmr);//выдержка
    229          //	длительность импульса определяемой функции1
    230              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[12];
    231            SetUstToClon(OF_COMP1,  1, MNGWORK_OF13, lMtz1Tmr);//выдержка OF2
    232          
    233          //OF14
    234              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[13];
    235            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF14, lMtz1Tmr);//выдержка
    236          //	длительность импульса определяемой функции1
    237              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[13];
    238            SetUstToClon(OF_COMP1,  1, MNGWORK_OF14, lMtz1Tmr);//выдержка OF2
    239          
    240          //OF15
    241              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[14];
    242            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF15, lMtz1Tmr);//выдержка
    243          //	длительность импульса определяемой функции1
    244              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[14];
    245            SetUstToClon(OF_COMP1,  1, MNGWORK_OF15, lMtz1Tmr);//выдержка OF2
    246          
    247          //OF16
    248              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[15];
    249            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF16, lMtz1Tmr);//выдержка
    250          //	длительность импульса определяемой функции1
    251              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[15];
    252            SetUstToClon(OF_COMP1,  1, MNGWORK_OF16, lMtz1Tmr);//выдержка OF2
    253          
    254          
    255              int uprOF=0;
    256              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[0];
    257          //Тип Определяемой функции1
    258          //	1- прямая
    259          //	2 - инверсная
    260            if(lSt1>0) uprOF |= 1; //Обр
    261            else  uprOF &= ~1; //Прямая
    262              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[1];
    263            if(lSt1>0) uprOF |= 2; //Обр
    264            else  uprOF &= ~2; //Прямая
    265              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[2];
    266            if(lSt1>0) uprOF |= 4; //Обр
    267            else  uprOF &= ~4; //Прямая
    268              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[3];
    269            if(lSt1>0) uprOF |= 8; //Обр
    270            else  uprOF &= ~8; //Прямая
    271              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[4];
    272            if(lSt1>0) uprOF |= 16; //Обр
    273            else  uprOF &= ~16; //Прямая
    274              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[5];
    275            if(lSt1>0) uprOF |= 32; //Обр
    276            else  uprOF &= ~32; //Прямая
    277              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[6];
    278            if(lSt1>0) uprOF |= 64; //Обр
    279            else  uprOF &= ~64; //Прямая
    280              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[7];
    281            if(lSt1>0) uprOF |= 128; //Обр
    282            else  uprOF &= ~128; //Прямая
    283              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[8];
    284            if(lSt1>0) uprOF |= 256; //Обр
    285            else  uprOF &= ~256; //Прямая
    286              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[9];
    287            if(lSt1>0) uprOF |= 512; //Обр
    288            else  uprOF &= ~512; //Прямая
    289              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[10];
    290            if(lSt1>0) uprOF |= 1024; //Обр
    291            else  uprOF &= ~1024; //Прямая
    292              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[11];
    293            if(lSt1>0) uprOF |= 2048; //Обр
    294            else  uprOF &= ~2048; //Прямая
    295              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[12];
    296            if(lSt1>0) uprOF |= 4096; //Обр
    297            else  uprOF &= ~4096; //Прямая
    298              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[13];
    299            if(lSt1>0) uprOF |= 8192; //Обр
    300            else  uprOF &= ~8192; //Прямая
    301              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[14];
    302            if(lSt1>0) uprOF |= 8192*2; //Обр
    303            else  uprOF &= ~(8192*2); //Прямая
    304              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[15];
    305            if(lSt1>0) uprOF |= 8192*4; //Обр
    306            else  uprOF &= ~(8192*4); //Прямая
    307          
    308             SetUstToClon(OF_COMP1,  1, MNGUPR_OF, uprOF);//устанвка прямая - обратная ОФ
    309          
    310            int FlagMaska = 0;//PLUS
    311          //команды запуска
    312            for(int numOF=0; numOF<16; numOF++) puskOFModern(FlagMaska, numOF);
    313            FlagMaska = 1;//MINUS
    314          //инверсные команды запуска
    315            for(int numOF=0; numOF<16; numOF++) puskOFModern(FlagMaska, numOF);
    316            FlagMaska = 2;//BLK
    317          //команды блокировки
    318            for(int numOF=0; numOF<16; numOF++) puskOFModern(FlagMaska, numOF);
    319          
    320          }
    321          
    322          void puskOFModern(int FlagMaska, int numOF)
    323          {
    324            SettingIci_OFDZ(FlagMaska, numOF);
    325            SettingIci_OFMTZ(FlagMaska, numOF);
    326            SettingIci_OFUMM(FlagMaska, numOF);
    327            SettingIci_OFTZNP(FlagMaska, numOF);
    328          }//puskOFModern(puskOFfunction *pntPuskOF, int typRang)
    329          
    330          
    331          int puskOFotZPLUS(int numCmd, int numOF)//AMOUNT_BYTE_FOR_OEPRF
    332          {
    333          //Пуск от Защит +
    334            int rez=0;
    335              if(brCfgTbl.uc_ar_df1_pl_rank_cfg[(numOF*AMOUNT_BYTE_FOR_OEPRF)+
    336                                                 numCmd/8]&(1<<(numCmd%8))) rez=1;
    337            return rez;
    338          }//puskOFotZPLUS(int num)
    339          
    340          int puskOFotZMINUS(int numCmd, int numOF)
    341          {
    342          //Пуск от Защит -
    343            int rez=0;
    344              if(brCfgTbl.uc_ar_df1_mn_rank_cfg[(numOF*AMOUNT_BYTE_FOR_OEPRF)+
    345                                                 numCmd/8]&(1<<(numCmd%8))) rez=1;
    346            return rez;
    347          }//puskOFotZMINUS(int num)
    348          
    349          int puskOFotZBLK(int numCmd, int numOF)
    350          {
    351          //Пуск от Защит -
    352            int rez=0;
    353              if(brCfgTbl.uc_ar_df1_blk_rank_cfg[(numOF*AMOUNT_BYTE_FOR_OEPRF)+
    354                                                 numCmd/8]&(1<<(numCmd%8))) rez=1;
    355            return rez;
    356          }//puskOFotZBLK(int num)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SettingIci_OF
        16   -> SetUstToClon
        16   -> puskOFModern
      16   puskOFModern
        16   -> SettingIci_OFDZ
        16   -> SettingIci_OFMTZ
        16   -> SettingIci_OFTZNP
        16   -> SettingIci_OFUMM
      24   puskOFotZBLK
        24 __aeabi_idiv
        24 __aeabi_idivmod
      24   puskOFotZMINUS
        24 __aeabi_idiv
        24 __aeabi_idivmod
      24   puskOFotZPLUS
        24 __aeabi_idiv
        24 __aeabi_idivmod


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_16
       4  ??DataTable3_17
       4  ??DataTable3_18
       4  ??DataTable3_19
       4  ??DataTable3_2
       4  ??DataTable3_20
       4  ??DataTable3_21
       4  ??DataTable3_22
       4  ??DataTable3_23
       4  ??DataTable3_24
       4  ??DataTable3_25
       4  ??DataTable3_26
       4  ??DataTable3_27
       4  ??DataTable3_28
       4  ??DataTable3_29
       4  ??DataTable3_3
       4  ??DataTable3_30
       4  ??DataTable3_31
       4  ??DataTable3_32
       4  ??DataTable3_33
       4  ??DataTable3_34
       4  ??DataTable3_35
       4  ??DataTable3_36
       4  ??DataTable3_37
       4  ??DataTable3_38
       4  ??DataTable3_39
       4  ??DataTable3_4
       4  ??DataTable3_40
       4  ??DataTable3_41
       4  ??DataTable3_42
       4  ??DataTable3_43
       4  ??DataTable3_44
       4  ??DataTable3_45
       4  ??DataTable3_46
       4  ??DataTable3_47
       4  ??DataTable3_48
       4  ??DataTable3_49
       4  ??DataTable3_5
       4  ??DataTable3_50
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
    4052  SettingIci_OF
       4  pntPuskOF
      64  puskOFModern
      92  puskOFotZBLK
      92  puskOFotZMINUS
      92  puskOFotZPLUS

 
     4 bytes in section .bss
 4 596 bytes in section .text
 
 4 596 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: 3
