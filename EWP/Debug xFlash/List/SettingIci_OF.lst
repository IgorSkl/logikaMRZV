###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Oct/2015  12:49:42
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\SettingIci\SettingIci_OF.c
#    Command line =  
#        "D:\IAR projects\HR1_0100_00_I720_new2\SettingIci\SettingIci_OF.c" -D
#        _STATIC_MEMORY_BOOT -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\List\SettingIci_OF.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\Obj\SettingIci_OF.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\SettingIci\SettingIci_OF.c
      1          #include "lpc_types.h"
      2          #include "lpc_irq_fiq.h"
      3          #include "lpc_arm922t_cp15_driver.h"
      4          
      5          #include "lpc32xx_hstimer.h"
      6          #include "lpc32xx_ssp.h"
      7          #include "lpc32xx_gpio.h"
      8          
      9          #include "lpc32xx_intc_driver.h"
     10          #include "lpc32xx_clkpwr_driver.h"
     11          
     12          #include "arm926ej_cp15_drv.h"
     13          #include "ttbl.h"
     14          
     15          #include <stdio.h>
     16          #include <string.h>
     17          
     18          #include "psuperVisor\supermanager.h"
     19          
     20          #include "component\componentdef.h"
     21          #include "psuperVisor\psvisor_helpdef.h"
     22          
     23          #include "psuperVisor\psvisor_helpfnc.h"
     24          #include "SettingIci\SettingIci.h"
     25          #include "virtualmenu\systemmenufnc.h"
     26          #include "virtualMenu\rangmanagerfnc.h"
     27          
     28          #include "toSpeedOptim.h"
     29          #include "toSpeedDIS.h"
     30          
     31          #include "header.h"
     32          #include "ici_r_ef.h"
     33          
     34          #define _HIDE_COMPONENT
     35          #include "OFComponent.c"
     36          //#include "MTZ1Component.c"
     37          //#include "MTZ2Component.c"
     38          //#include "TZNP1Component.c"
     39          //#include "DZ1Component.c"
     40          //#include "DZ2Component.c"
     41          
     42          extern char chProtectTableComeIn;
     43          extern char chResultCallGetMeasPrt;
     44          //extern tic long lDemo_IA,lDemo_IB,lDemo_IC;
     45          extern  long lMtz1,lMtz1Tmr,lSt1,lSt2, lst3, lst4;
     46          extern __MEASUREMENT_TO_PROTECTION TestMeasProtection;
     47          extern MaskaOTAPVUROVOFcmd struct_maskaOTAPVUROVOFcmd;//маски для 16 опред функций UROV APV OT
     48          
     49          extern MaskaOTcmd struct_maskaOTcmd;//маски для 8 опред триггеров
     50          
     51          //int puskOFotZPLUS();//int num);
     52          
     53            puskOFfunction *pntPuskOF;//указатель на ф-цию
     54          
     55          
     56          
     57          void  SettingIci_OF()
     58          {
     59          
     60            memset(&struct_maskaOTAPVUROVOFcmd, 0, sizeof(MaskaOTAPVUROVOFcmd));//стереть старое
     61            memset(&struct_maskaOTcmd,          0, sizeof(MaskaOTcmd));//стереть старое
     62          
     63          
     64          /*
     65            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OFcmdMaska[i]=0;//Очистить
     66            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OFcmdMaska[i]=0;//Очистить
     67            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OFcmdMaska[i]=0;//Очистить
     68          
     69            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF2cmdMaska[i]=0;//Очистить
     70            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF2cmdMaska[i]=0;//Очистить
     71            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF2cmdMaska[i]=0;//Очистить
     72          
     73            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF3cmdMaska[i]=0;//Очистить
     74            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF3cmdMaska[i]=0;//Очистить
     75            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF3cmdMaska[i]=0;//Очистить
     76          
     77            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF4cmdMaska[i]=0;//Очистить
     78            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF4cmdMaska[i]=0;//Очистить
     79            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF4cmdMaska[i]=0;//Очистить
     80          
     81            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF5cmdMaska[i]=0;//Очистить
     82            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF5cmdMaska[i]=0;//Очистить
     83            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF5cmdMaska[i]=0;//Очистить
     84          
     85            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF6cmdMaska[i]=0;//Очистить
     86            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF6cmdMaska[i]=0;//Очистить
     87            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF6cmdMaska[i]=0;//Очистить
     88          
     89            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF7cmdMaska[i]=0;//Очистить
     90            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF7cmdMaska[i]=0;//Очистить
     91            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF7cmdMaska[i]=0;//Очистить
     92          
     93            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF8cmdMaska[i]=0;//Очистить
     94            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF8cmdMaska[i]=0;//Очистить
     95            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF8cmdMaska[i]=0;//Очистить
     96          
     97            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF9cmdMaska[i]=0;//Очистить
     98            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF9cmdMaska[i]=0;//Очистить
     99            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF9cmdMaska[i]=0;//Очистить
    100          
    101            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF10cmdMaska[i]=0;//Очистить
    102            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF10cmdMaska[i]=0;//Очистить
    103            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF10cmdMaska[i]=0;//Очистить
    104          
    105            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF11cmdMaska[i]=0;//Очистить
    106            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF11cmdMaska[i]=0;//Очистить
    107            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF11cmdMaska[i]=0;//Очистить
    108          
    109            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF12cmdMaska[i]=0;//Очистить
    110            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF12cmdMaska[i]=0;//Очистить
    111            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF12cmdMaska[i]=0;//Очистить
    112          
    113            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF13cmdMaska[i]=0;//Очистить
    114            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF13cmdMaska[i]=0;//Очистить
    115            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF13cmdMaska[i]=0;//Очистить
    116          
    117            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF14cmdMaska[i]=0;//Очистить
    118            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF14cmdMaska[i]=0;//Очистить
    119            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF14cmdMaska[i]=0;//Очистить
    120          
    121            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF15cmdMaska[i]=0;//Очистить
    122            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF15cmdMaska[i]=0;//Очистить
    123            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF15cmdMaska[i]=0;//Очистить
    124          
    125            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP1OF16cmdMaska[i]=0;//Очистить
    126            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP2OF16cmdMaska[i]=0;//Очистить
    127            for(int i=0; i<DQUADRO; i++) struct_maskaOTAPVUROVOFcmd.pP3OF16cmdMaska[i]=0;//Очистить
    128          */
    129          
    130          //OFuncDsc   ownrOFunc;  //Опред. функции
    131          //unsigned char uch_ar_type_df[NUM_DEF_FUN];
    132          //Тип Определяемой функции1
    133          //	1- прямая
    134          //	2 - инверсная
    135          
    136          
    137          //OF1
    138              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[0];
    139            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF1, lMtz1Tmr);//выдержка
    140          //	длительность импульса определяемой функции1
    141              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[0];
    142            SetUstToClon(OF_COMP1,  1, MNGWORK_OF1, lMtz1Tmr);//выдержка OF1
    143          
    144          //OF2
    145              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[1];
    146            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF2, lMtz1Tmr);//выдержка
    147          //	длительность импульса определяемой функции1
    148              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[1];
    149            SetUstToClon(OF_COMP1,  1, MNGWORK_OF2, lMtz1Tmr);//выдержка OF2
    150          
    151          //OF3
    152              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[2];
    153            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF3, lMtz1Tmr);//выдержка
    154          //	длительность импульса определяемой функции1
    155              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[2];
    156            SetUstToClon(OF_COMP1,  1, MNGWORK_OF3, lMtz1Tmr);//выдержка OF2
    157          
    158          //OF4
    159              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[3];
    160            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF4, lMtz1Tmr);//выдержка
    161          //	длительность импульса определяемой функции1
    162              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[3];
    163            SetUstToClon(OF_COMP1,  1, MNGWORK_OF4, lMtz1Tmr);//выдержка OF2
    164          
    165          //OF5
    166              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[4];
    167            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF5, lMtz1Tmr);//выдержка
    168          //	длительность импульса определяемой функции1
    169              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[4];
    170            SetUstToClon(OF_COMP1,  1, MNGWORK_OF5, lMtz1Tmr);//выдержка OF2
    171          
    172          //OF6
    173              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[5];
    174            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF6, lMtz1Tmr);//выдержка
    175          //	длительность импульса определяемой функции1
    176              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[5];
    177            SetUstToClon(OF_COMP1,  1, MNGWORK_OF6, lMtz1Tmr);//выдержка OF2
    178          
    179          //OF7
    180              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[6];
    181            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF7, lMtz1Tmr);//выдержка
    182          //	длительность импульса определяемой функции1
    183              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[6];
    184            SetUstToClon(OF_COMP1,  1, MNGWORK_OF7, lMtz1Tmr);//выдержка OF2
    185          
    186          //OF8
    187              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[7];
    188            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF8, lMtz1Tmr);//выдержка
    189          //	длительность импульса определяемой функции1
    190              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[7];
    191            SetUstToClon(OF_COMP1,  1, MNGWORK_OF8, lMtz1Tmr);//выдержка OF2
    192          
    193          //OF9
    194              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[8];
    195            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF9, lMtz1Tmr);//выдержка
    196          //	длительность импульса определяемой функции1
    197              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[8];
    198            SetUstToClon(OF_COMP1,  1, MNGWORK_OF9, lMtz1Tmr);//выдержка OF2
    199          
    200          //OF10
    201              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[9];
    202            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF10, lMtz1Tmr);//выдержка
    203          //	длительность импульса определяемой функции1
    204              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[9];
    205            SetUstToClon(OF_COMP1,  1, MNGWORK_OF10, lMtz1Tmr);//выдержка OF2
    206          
    207          //OF11
    208              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[10];
    209            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF11, lMtz1Tmr);//выдержка
    210          //	длительность импульса определяемой функции1
    211              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[10];
    212            SetUstToClon(OF_COMP1,  1, MNGWORK_OF11, lMtz1Tmr);//выдержка OF2
    213          
    214          //OF12
    215              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[11];
    216            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF12, lMtz1Tmr);//выдержка
    217          //	длительность импульса определяемой функции1
    218              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[11];
    219            SetUstToClon(OF_COMP1,  1, MNGWORK_OF12, lMtz1Tmr);//выдержка OF2
    220          
    221          //OF13
    222              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[12];
    223            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF13, lMtz1Tmr);//выдержка
    224          //	длительность импульса определяемой функции1
    225              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[12];
    226            SetUstToClon(OF_COMP1,  1, MNGWORK_OF13, lMtz1Tmr);//выдержка OF2
    227          
    228          //OF14
    229              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[13];
    230            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF14, lMtz1Tmr);//выдержка
    231          //	длительность импульса определяемой функции1
    232              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[13];
    233            SetUstToClon(OF_COMP1,  1, MNGWORK_OF14, lMtz1Tmr);//выдержка OF2
    234          
    235          //OF15
    236              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[14];
    237            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF15, lMtz1Tmr);//выдержка
    238          //	длительность импульса определяемой функции1
    239              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[14];
    240            SetUstToClon(OF_COMP1,  1, MNGWORK_OF15, lMtz1Tmr);//выдержка OF2
    241          
    242          //OF16
    243              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_time_delay_df[15];
    244            SetUstToClon(OF_COMP1,  1, MNGPAUSA_OF16, lMtz1Tmr);//выдержка
    245          //	длительность импульса определяемой функции1
    246              lMtz1Tmr = brCfgTbl.ownrOFunc.ul_ar_duration_df[15];
    247            SetUstToClon(OF_COMP1,  1, MNGWORK_OF16, lMtz1Tmr);//выдержка OF2
    248          
    249          
    250              int uprOF=0;
    251              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[0];
    252          //Тип Определяемой функции1
    253          //	1- прямая
    254          //	2 - инверсная
    255            if(lSt1>0) uprOF |= 1; //Обр
    256            else  uprOF &= ~1; //Прямая
    257              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[1];
    258            if(lSt1>0) uprOF |= 2; //Обр
    259            else  uprOF &= ~2; //Прямая
    260              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[2];
    261            if(lSt1>0) uprOF |= 4; //Обр
    262            else  uprOF &= ~4; //Прямая
    263              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[3];
    264            if(lSt1>0) uprOF |= 8; //Обр
    265            else  uprOF &= ~8; //Прямая
    266              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[4];
    267            if(lSt1>0) uprOF |= 16; //Обр
    268            else  uprOF &= ~16; //Прямая
    269              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[5];
    270            if(lSt1>0) uprOF |= 32; //Обр
    271            else  uprOF &= ~32; //Прямая
    272              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[6];
    273            if(lSt1>0) uprOF |= 64; //Обр
    274            else  uprOF &= ~64; //Прямая
    275              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[7];
    276            if(lSt1>0) uprOF |= 128; //Обр
    277            else  uprOF &= ~128; //Прямая
    278              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[8];
    279            if(lSt1>0) uprOF |= 256; //Обр
    280            else  uprOF &= ~256; //Прямая
    281              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[9];
    282            if(lSt1>0) uprOF |= 512; //Обр
    283            else  uprOF &= ~512; //Прямая
    284              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[10];
    285            if(lSt1>0) uprOF |= 1024; //Обр
    286            else  uprOF &= ~1024; //Прямая
    287              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[11];
    288            if(lSt1>0) uprOF |= 2048; //Обр
    289            else  uprOF &= ~2048; //Прямая
    290              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[12];
    291            if(lSt1>0) uprOF |= 4096; //Обр
    292            else  uprOF &= ~4096; //Прямая
    293              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[13];
    294            if(lSt1>0) uprOF |= 8192; //Обр
    295            else  uprOF &= ~8192; //Прямая
    296              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[14];
    297            if(lSt1>0) uprOF |= 8192*2; //Обр
    298            else  uprOF &= ~(8192*2); //Прямая
    299              lSt1 = brCfgTbl.ownrOFunc.uch_ar_type_df[15];
    300            if(lSt1>0) uprOF |= 8192*4; //Обр
    301            else  uprOF &= ~(8192*4); //Прямая
    302          
    303             SetUstToClon(OF_COMP1,  1, MNGUPR_OF, uprOF);//устанвка прямая - обратная ОФ
    304          
    305            int FlagMaska = 0;//PLUS
    306          //команды запуска
    307            for(int numOF=0; numOF<16; numOF++) puskOFModern(FlagMaska, numOF);
    308            FlagMaska = 1;//MINUS
    309          //инверсные команды запуска
    310            for(int numOF=0; numOF<16; numOF++) puskOFModern(FlagMaska, numOF);
    311            FlagMaska = 2;//BLK
    312          //команды блокировки
    313            for(int numOF=0; numOF<16; numOF++) puskOFModern(FlagMaska, numOF);
    314          
    315            FlagMaska = 0;//PLUS Set
    316          //команды запуска
    317            for(int numOT=0; numOT<8; numOT++) puskOTModern(FlagMaska, numOT);
    318            FlagMaska = 1;//PLUS Rst
    319          //команды запуска
    320            for(int numOT=0; numOT<8; numOT++) puskOTModern(FlagMaska, numOT);
    321            FlagMaska = 2;//MINUS Set
    322          //инверсные команды запуска
    323            for(int numOT=0; numOT<8; numOT++) puskOTModern(FlagMaska, numOT);
    324            FlagMaska = 3;//MINUS Rst
    325          //инверсные команды запуска
    326            for(int numOT=0; numOT<8; numOT++) puskOTModern(FlagMaska, numOT);
    327          
    328          }
    329          
    330          void puskOFModern(int FlagMaska, int numOF)
    331          {
    332            SettingIci_OFDZ(0, FlagMaska, numOF);
    333            SettingIci_OFMTZ(0, FlagMaska, numOF);
    334            SettingIci_OFUMM(0, FlagMaska, numOF);
    335            SettingIci_OFTZNP(0, FlagMaska, numOF);
    336          }//puskOFModern(int FlagMaska, int numOF)
    337          
    338          void puskOTModern(int FlagMaska, int numOT)
    339          {
    340            SettingIci_OFDZ(1, FlagMaska, numOT);
    341            SettingIci_OFMTZ(1, FlagMaska, numOT);
    342            SettingIci_OFUMM(1, FlagMaska, numOT);
    343            SettingIci_OFTZNP(1, FlagMaska, numOT);
    344          }//puskOFModern(int FlagMaska, int numOF)
    345          
    346          int puskOFotZPLUS(int numCmd, int numOF)//AMOUNT_BYTE_FOR_OEPRF
    347          {
    348          //Пуск от Защит +
    349            int rez=0;
    350              if(brCfgTbl.uc_ar_df1_pl_rank_cfg[(numOF*AMOUNT_BYTE_FOR_OEPRF)+
    351                                                 numCmd/8]&(1<<(numCmd%8))) rez=1;
    352            return rez;
    353          }//puskOFotZPLUS(int num)
    354          
    355          int puskOFotZMINUS(int numCmd, int numOF)
    356          {
    357          //Пуск от Защит -
    358            int rez=0;
    359              if(brCfgTbl.uc_ar_df1_mn_rank_cfg[(numOF*AMOUNT_BYTE_FOR_OEPRF)+
    360                                                 numCmd/8]&(1<<(numCmd%8))) rez=1;
    361            return rez;
    362          }//puskOFotZMINUS(int num)
    363          
    364          int puskOFotZBLK(int numCmd, int numOF)
    365          {
    366          //Пуск от Защит -
    367            int rez=0;
    368              if(brCfgTbl.uc_ar_df1_blk_rank_cfg[(numOF*AMOUNT_BYTE_FOR_OEPRF)+
    369                                                 numCmd/8]&(1<<(numCmd%8))) rez=1;
    370            return rez;
    371          }//puskOFotZBLK(int num)
    372          
    373          int puskSetOTotZPLUS(int numCmd, int numOT)//AMOUNT_BYTE_FOR_OEPRF
    374          {
    375          //Пуск от Защит +
    376            int rez=0;
    377              if(brCfgTbl.uc_ar_trg_setPl_rank_cfg[(numOT*AMOUNT_BYTE_FOR_OEPRF)+
    378                                                 numCmd/8]&(1<<(numCmd%8))) rez=1;
    379            return rez;
    380          }//puskSetOTotZPLUS(int num)
    381          
    382          int puskSetOTotZMINUS(int numCmd, int numOT)
    383          {
    384          //Пуск от Защит -
    385            int rez=0;
    386              if(brCfgTbl.uc_ar_trg_setMn_rank_cfg[(numOT*AMOUNT_BYTE_FOR_OEPRF)+
    387                                                 numCmd/8]&(1<<(numCmd%8))) rez=1;
    388            return rez;
    389          }//puskSetOTotZMINUS(int num)
    390          
    391          int puskRstOTotZPLUS(int numCmd, int numOT)//AMOUNT_BYTE_FOR_OEPRF
    392          {
    393          //Пуск от Защит +
    394            int rez=0;
    395              if(brCfgTbl.uc_ar_trg_rstPl_rank_cfg[(numOT*AMOUNT_BYTE_FOR_OEPRF)+
    396                                                 numCmd/8]&(1<<(numCmd%8))) rez=1;
    397            return rez;
    398          }//puskSetOTotZPLUS(int num)
    399          
    400          int puskRstOTotZMINUS(int numCmd, int numOT)
    401          {
    402          //Пуск от Защит -
    403            int rez=0;
    404              if(brCfgTbl.uc_ar_trg_rstMn_rank_cfg[(numOT*AMOUNT_BYTE_FOR_OEPRF)+
    405                                                 numCmd/8]&(1<<(numCmd%8))) rez=1;
    406            return rez;
    407          }//puskSetOTotZMINUS(int num)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   SettingIci_OF
        24   -> SetUstToClon
        24   -> __aeabi_memset
        24   -> puskOFModern
        24   -> puskOTModern
      16   puskOFModern
        16   -> SettingIci_OFDZ
        16   -> SettingIci_OFMTZ
        16   -> SettingIci_OFTZNP
        16   -> SettingIci_OFUMM
      24   puskOFotZBLK
        24 __aeabi_idiv
        24 __aeabi_idivmod
      24   puskOFotZMINUS
        24 __aeabi_idiv
        24 __aeabi_idivmod
      24   puskOFotZPLUS
        24 __aeabi_idiv
        24 __aeabi_idivmod
      16   puskOTModern
        16   -> SettingIci_OFDZ
        16   -> SettingIci_OFMTZ
        16   -> SettingIci_OFTZNP
        16   -> SettingIci_OFUMM
      24   puskRstOTotZMINUS
        24 __aeabi_idiv
        24 __aeabi_idivmod
      24   puskRstOTotZPLUS
        24 __aeabi_idiv
        24 __aeabi_idivmod
      24   puskSetOTotZMINUS
        24 __aeabi_idiv
        24 __aeabi_idivmod
      24   puskSetOTotZPLUS
        24 __aeabi_idiv
        24 __aeabi_idivmod


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_16
       4  ??DataTable7_17
       4  ??DataTable7_18
       4  ??DataTable7_19
       4  ??DataTable7_2
       4  ??DataTable7_20
       4  ??DataTable7_21
       4  ??DataTable7_22
       4  ??DataTable7_23
       4  ??DataTable7_24
       4  ??DataTable7_25
       4  ??DataTable7_26
       4  ??DataTable7_27
       4  ??DataTable7_28
       4  ??DataTable7_29
       4  ??DataTable7_3
       4  ??DataTable7_30
       4  ??DataTable7_31
       4  ??DataTable7_32
       4  ??DataTable7_33
       4  ??DataTable7_34
       4  ??DataTable7_35
       4  ??DataTable7_36
       4  ??DataTable7_37
       4  ??DataTable7_38
       4  ??DataTable7_39
       4  ??DataTable7_4
       4  ??DataTable7_40
       4  ??DataTable7_41
       4  ??DataTable7_42
       4  ??DataTable7_43
       4  ??DataTable7_44
       4  ??DataTable7_45
       4  ??DataTable7_46
       4  ??DataTable7_47
       4  ??DataTable7_48
       4  ??DataTable7_49
       4  ??DataTable7_5
       4  ??DataTable7_50
       4  ??DataTable7_51
       4  ??DataTable7_52
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
    2348  SettingIci_OF
       4  pntPuskOF
      80  puskOFModern
      92  puskOFotZBLK
      92  puskOFotZMINUS
      92  puskOFotZPLUS
      80  puskOTModern
      92  puskRstOTotZMINUS
      92  puskRstOTotZPLUS
      92  puskSetOTotZMINUS
      92  puskSetOTotZPLUS

 
     4 bytes in section .bss
 3 364 bytes in section .text
 
 3 364 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none
