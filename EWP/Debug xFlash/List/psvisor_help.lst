###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        12/Oct/2015  11:05:04
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\psuperVisor\psvisor_help.c
#    Command line =  
#        "D:\IAR projects\HR1_0100_00_I720_new2\psuperVisor\psvisor_help.c" -D
#        _STATIC_MEMORY_BOOT -lcN "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\List\" -o "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\Debug xFlash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e
#        --fpu=VFP9-S --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.40\arm\INC\c\DLib_Config_Normal.h" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\NXP\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\LIB\include\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\inc\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\Igor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\mal\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\component\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\psupervisor\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\virtualMenu\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\callbackElement\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\logictimers\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\zonaVRT\" -I "D:\IAR
#        projects\HR1_0100_00_I720_new2\EWP\..\" --cpu_mode arm -On
#        --use_c++_inline
#    List file    =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\List\psvisor_help.lst
#    Object file  =  
#        D:\IAR projects\HR1_0100_00_I720_new2\EWP\Debug
#        xFlash\Obj\psvisor_help.o
#
###############################################################################

D:\IAR projects\HR1_0100_00_I720_new2\psuperVisor\psvisor_help.c
      1          /*
      2          #include <vcl.h>
      3          #include <strstrea.h>
      4          #include <math.h>
      5          #include <mem.h>
      6          #include <fstream.h>
      7          #include <strstrea.h>
      8          #include <iomanip.h>
      9          #pragma hdrstop
     10          
     11          #include "vmenuDis.h"
     12          */
     13          
     14          #include <stdio.h>
     15          #include <string.h>
     16          
     17          #include "psuperVisor\supermanager.h"
     18          
     19          #include "bazisdef.h"
     20          #include "component\componentdef.h"
     21          
     22          #include "logictimersfnc.h"
     23          #include "psuperVisor\psvisor_helpfnc.h"
     24          #include "virtualMenu\ustmanagerfnc.h"
     25          
     26          #include "psupervisor\psupervisor.h"
     27          
     28          #include "toSpeedOptim.h"
     29          
     30          extern int  IndexIO;//индекс IO
     31          
     32          extern int  IndexTLog;//индекс локальной логики
     33          extern int  IndexENA;//индекс ENA
     34          extern int  IndexTIMERS;
     35          extern int    WideCmdBuffer[];//широкий ком массив
     36          extern COMPONENT_OBJ  cnfCOMPONENT[];
     37          extern int   ENAcmd[];
     38          extern int   ENAcmd_WL[];
     39          //широкий ком массив RT плюс расширенная логика RT
     40          extern int   WideCmdRTBuffer[];
     41          
     42          int   WideENABuffer[32+3];//широкий ENA массив
     43          
     44          int workerUniversal1;//данные для работника
     45          int workerUniversal2;//данные для работника
     46          
     47          /**********************************************
     48          СТАНДАРТНЫЙ ИНИЦИАЛИЗАТОР IO КОМАНД
     49          cntIO - количество
     50          **********************************************/
     51          short commonInitIOCmd(short cntIO)
     52          {
     53            //инициал IO команд
     54            IndexIO += cntIO;//индекс IO
     55            return cntIO;
     56          }//commonInitIOCmd(short cntIO)
     57          
     58          /**********************************************
     59          СТАНДАРТНЫЙ ИНИЦИАЛИЗАТОР TL КОМАНД
     60          cntTL - количество
     61          **********************************************/
     62          short commonInitTLCmd(short cntTL)
     63          {
     64            //инициал TL команд
     65            IndexTLog += cntTL;//индекс TL
     66            return cntTL;
     67          }//commonInitTLCmd(short cntTL)
     68          
     69          /**********************************************
     70          СТАНДАРТНЫЙ ИНИЦИАЛИЗАТОР ТАЙМЕРОВ
     71          cntT - количество таймеров
     72          **********************************************/
     73          void commonInitTimers(short cntT)
     74          {
     75            //запрос и инициал таймеров
     76            for (short i=0; i<cntT; i++)
     77            {
     78              initLogTimer(IndexTIMERS +i);
     79              if ((IndexTIMERS +i)==0) continue;//первый не разрешать
     80              //bazisTimerMem[IndexTIMERS +i].ENABLE = 1;//разр лог таймера
     81              setTimerENABLE(IndexTIMERS +i, 1);
     82            }//for
     83            IndexTIMERS += cntT;//таймерный индекс
     84          }//commonInitTimers(short cntT)
     85          
     86          /**********************************************
     87          СТАНДАРТНЫЙ ИНИЦИАЛИЗАТОР ТАЙМЕРОВ
     88          cntT - количество таймеров
     89          **********************************************/
     90          void commonInitTimers_WL(short cntT)
     91          {
     92            //запрос и инициал таймеров
     93            for (short i=0; i<cntT; i++)
     94            {
     95              initLogTimer_WL(IndexTIMERS +i);
     96              if ((IndexTIMERS +i)==0) continue;//первый не разрешать
     97              //bazisTimerMem[IndexTIMERS +i].ENABLE = 1;//разр лог таймера
     98              setTimerENABLE_WL(IndexTIMERS +i, 1);
     99            }//for
    100            IndexTIMERS += cntT;//таймерный индекс
    101          }//commonInitTimers_WL(short cntT)
    102          
    103          /**********************************************
    104          СТАНДАРТНЫЙ ИНИЦИАЛИЗАТОР ENA КОМАНД
    105          cntTL - количество
    106          **********************************************/
    107          short commonInitENACmd(short cntENA)
    108          {
    109            //инициал ENA команд
    110            IndexENA += cntENA;//индекс ENA
    111            return cntENA;
    112          }//commonInitENACmd(short cntENA)
    113          
    114          void TranslateWordToWideENA(UNS_32 word)
    115          {
    116          //Превратить Word в широкий ENA массив
    117            //обнулить широкий ENA буфер
    118            memset(WideENABuffer, 0, sizeof(WideENABuffer));
    119            MultiBitWorkerHostWord(&word, &pfWorker4);
    120          }//TranslateWordToWideENA(UNS_32 *pWord)
    121          
    122          void TranslateQuadroToWideCmd(UNS_32 *pQuadro)
    123          {
    124          //Превратить Quadro в широкий ком массив
    125            //обнулить широкий ком буфер
    126            memset(WideCmdBuffer, 0, 4*SIZE_RANGIRCMD);
    127            MultiBitWorkerHostQuadro(pQuadro, &pfWorker3);
    128          }//TranslateQuadroToWideCmd(UNS_32 *pQuadro)
    129          
    130          void NumBitSettingWord(short nBit, UNS_32 *word)
    131          {
    132          //установка бита по его индексу
    133            int tmpOst = nBit%32;//остаток индекс бита в слове
    134            (*word) |= 1<<tmpOst;
    135          }//
    136          
    137          void NumBitClearingWord(short nBit, UNS_32 *word)
    138          {
    139          //сброс бита по его индексу
    140            int tmpOst = nBit%32;//остаток индекс бита в слове
    141            (*word) &= ~(1<<tmpOst);
    142          }//NumBitClearing(short nBit, UNS_32 *pQuadro)
    143          
    144          char NumBitCheckWord(short nBit, UNS_32 *word)
    145          {
    146          //проверка бита по его индексу
    147            UNS_32 tmp=0;
    148            NumBitSettingWord(nBit, &tmp);
    149            if((tmp&(*word))==0) return 0;
    150            return 1;
    151          }//NumBitCheck(short nBit, UNS_32 *pQuadro)
    152          
    153          void NumBitSettingQuadro(short nBit, UNS_32 *pQuadro)
    154          {
    155          //установка бита по его индексу
    156            int tmpOst = nBit%32;//остаток индекс бита в слове
    157            pQuadro[(nBit - tmpOst)/32] |= 1<<tmpOst;
    158          }//
    159          
    160          void NumBitClearingQuadro(short nBit, UNS_32 *pQuadro)
    161          {
    162          //сброс бита по его индексу
    163            int tmpOst = nBit%32;//остаток индекс бита в слове
    164            pQuadro[(nBit - tmpOst)/32] &= ~(1<<tmpOst);
    165          }//NumBitClearing(short nBit, UNS_32 *pQuadro)
    166          
    167          char NumBitCheckQuadro(short nBit, UNS_32 *pQuadro)
    168          {
    169          //проверка бита по его индексу
    170            UNS_32 tmpQuadro[DQUADRO];
    171            memset(tmpQuadro, 0, 4* DQUADRO);
    172            NumBitSettingQuadro(nBit, tmpQuadro);
    173            return CheckedQuadro(tmpQuadro, pQuadro);//сравнить по И два Quadro
    174          }//NumBitCheck(short nBit, UNS_32 *pQuadro)
    175          
    176          char CheckedQuadro(UNS_32 *pQuadro1, UNS_32 *pQuadro2)
    177          {
    178          //сравнить по И два Quadro
    179            for (short i=0; i<DQUADRO; i++)
    180            {
    181              if (pQuadro1[i]&pQuadro2[i]) return 1;
    182            }//for
    183            return 0;
    184          }//
    185          
    186          char NumBitCheckWL(short nBit, UNS_32 *pQuadro)
    187          {
    188          //проверка бита по его индексу
    189            UNS_32 tmpQuadro[2*DQUADRO];
    190            memset(tmpQuadro, 0, 4* 2*DQUADRO);
    191            NumBitSettingQuadro(nBit, tmpQuadro);
    192            return CheckedWL(tmpQuadro, pQuadro);//сравнить по И два Quadro
    193          }//NumBitCheckWL(short nBit, UNS_32 *pQuadro)
    194          
    195          char CheckedWL(UNS_32 *pQuadro1, UNS_32 *pQuadro2)
    196          {
    197          //сравнить по И два Quadro
    198            for (short i=0; i<2*DQUADRO; i++)
    199            {
    200              if (pQuadro1[i]&pQuadro2[i]) return 1;
    201            }//for
    202            return 0;
    203          }//
    204          
    205          /**********************************************
    206          БИТОВЫЙ БРИГАДИР
    207          pWord - указатель на  UNS_32
    208          pfW - указатель на функцию-работника
    209          функция-работник работает только с глобальной памятью
    210          если функция-работник возвратит 1 то MultiBitWorker завершается
    211          **********************************************/
    212          short MultiBitWorkerHostWord(UNS_32 *pWord, int (*pfW)(short idx))
    213          {
    214            int cntBit=0;//счетчик бит
    215          
    216            
    217            if (*pWord==0)
    218            {
    219              //cntBit+=32;
    220              //continue;
    221              return 0;
    222            }
    223            else
    224            {
    225              for (int b=0; b<32; b++)
    226              {
    227                if ((*pWord)&(1<<b))
    228                {
    229          
    230                  if ((*pfW)(cntBit)) return 1;
    231                }
    232                cntBit++;
    233              }//for
    234            }
    235           return 0;
    236          }//MultiBitWorkerHostWord(UNS_32 *pWord, char (*pfW)(short idx))
    237          
    238          /**********************************************
    239          ФУНКЦИЯ-РАБОТНИК ДЛЯ БРИГАДИРА
    240          Посчет к-ва активных битов
    241          idx - индекс активного бита
    242          Выход - 0-не покидать бригадира
    243          **********************************************/
    244          int pfWorker1(short idx)
    245          {
    246            workerUniversal1++;
    247            return 0;
    248          }//pfWorker1(short idx)
    249          
    250          /**********************************************
    251          ФУНКЦИЯ-РАБОТНИК ДЛЯ БРИГАДИРА
    252          Индекс i-й активной команды
    253          idx - индекс активного бита
    254          Выход - 0-не покидать бригадира
    255          **********************************************/
    256          int pfWorker2(short idx)
    257          {
    258            if(workerUniversal2==workerUniversal1)
    259            {
    260              workerUniversal2=idx;
    261              return 1;
    262            }
    263            workerUniversal1++;//счетчик активн битов
    264            return 0;
    265          }//pfWorker1(short idx)
    266          
    267          /**********************************************
    268          ФУНКЦИЯ-РАБОТНИК ДЛЯ БРИГАДИРА
    269          Превратить Quadro в широкий ком массив
    270          idx - индекс активного бита
    271          Выход - 0-не покидать бригадира
    272          **********************************************/
    273          int pfWorker3(short idx)
    274          {
    275            WideCmdBuffer[idx] = 1;//широкий ком массив
    276            return 0;
    277          }//pfWorker3(short idx)
    278          
    279          /**********************************************
    280          ФУНКЦИЯ-РАБОТНИК ДЛЯ БРИГАДИРА
    281          Превратить Word в широкий ENA массив
    282          idx - индекс активного бита
    283          Выход - 0-не покидать бригадира
    284          **********************************************/
    285          int pfWorker4(short idx)
    286          {
    287            WideENABuffer[idx] = 1;//широкий ENA массив
    288            return 0;
    289          }//pfWorker4(short idx)
    290          
    291          short PrepareENACmd(short idxC, short offsetUpr)
    292          {
    293            //подготовка ENA команд для клона
    294          //прочитать уставку по индексу клона и смещению
    295            TranslateWordToWideENA( getNativUstMngUSTAVKI(idxC, offsetUpr) );//Превратить Word в широкий ENA массив
    296            //прочитать смещение ENA команд по индексу клона
    297            return  getOffsetENACmdCnf(idxC);
    298          }//PrepareENACmd(short idxC, short offsetUpr)
    299          
    300          void CopyWideENAToENAcmd(short offset, short cnt)
    301          {
    302            //копировать ENA из WideENA в ENAcmd
    303            for(short i=0; i<cnt; i++)
    304            {
    305              //ENA команды
    306              ENAcmd[offset + i] = WideENABuffer[i];
    307            }//for
    308          }//CopyWideENAToENAcmd(short offset, short cnt);
    309          
    310          void CopyWideENAToENAcmd_WL(short offset, short cnt)
    311          {
    312            //копировать ENA из WideENA в ENAcmd РЛ
    313            for(short i=0; i<cnt; i++)
    314            {
    315              //ENA команды
    316              ENAcmd_WL[offset + i] = WideENABuffer[i];
    317            }//for
    318          }//CopyWideENAToENAcmd_WL(short offset, short cnt);
    319          
    320          int setCRCMassiv(int *ustmass, int cnt)
    321          {
    322          //CRC для массива
    323            int crc=0;
    324            for(int i=0; i<cnt; i++)
    325               crc += ustmass[i];
    326            crc++;
    327            crc++;
    328            return crc;
    329          }//setCRCMassiv(int *ustmass, int cnt)
    330          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CheckedQuadro
       0   CheckedWL
       8   CopyWideENAToENAcmd
       8   CopyWideENAToENAcmd_WL
      24   MultiBitWorkerHostWord
        24   -- Indirect call
      64   NumBitCheckQuadro
        64   -> CheckedQuadro
        64   -> NumBitSettingQuadro
        64   -> __aeabi_memset
     104   NumBitCheckWL
       104   -> CheckedWL
       104   -> NumBitSettingQuadro
       104   -> __aeabi_memset
      16   NumBitCheckWord
        16   -> NumBitSettingWord
      20   NumBitClearingQuadro
        20 __aeabi_idiv
        20 __aeabi_idivmod
      12   NumBitClearingWord
        12 __aeabi_idivmod
      20   NumBitSettingQuadro
        20 __aeabi_idiv
        20 __aeabi_idivmod
      12   NumBitSettingWord
        12 __aeabi_idivmod
      16   PrepareENACmd
        16   -> TranslateWordToWideENA
        16   -> getNativUstMngUSTAVKI
        16   -> getOffsetENACmdCnf
      24   TranslateQuadroToWideCmd
        24   -> MultiBitWorkerHostQuadro
        24   -> __aeabi_memset
      24   TranslateWordToWideENA
        24   -> MultiBitWorkerHostWord
        24   -> __aeabi_memset
       0   commonInitENACmd
       0   commonInitIOCmd
       0   commonInitTLCmd
      16   commonInitTimers
        16   -> initLogTimer
        16   -> setTimerENABLE
      16   commonInitTimers_WL
        16   -> initLogTimer_WL
        16   -> setTimerENABLE_WL
       0   pfWorker1
       0   pfWorker2
       0   pfWorker3
       0   pfWorker4
       0   setCRCMassiv


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
     100  CheckedQuadro
     100  CheckedWL
     108  CopyWideENAToENAcmd
     108  CopyWideENAToENAcmd_WL
     116  MultiBitWorkerHostWord
      84  NumBitCheckQuadro
      84  NumBitCheckWL
      72  NumBitCheckWord
     116  NumBitClearingQuadro
      56  NumBitClearingWord
     112  NumBitSettingQuadro
      52  NumBitSettingWord
      72  PrepareENACmd
      52  TranslateQuadroToWideCmd
      52  TranslateWordToWideENA
     140  WideENABuffer
      44  commonInitENACmd
      44  commonInitIOCmd
      44  commonInitTLCmd
     172  commonInitTimers
     172  commonInitTimers_WL
      32  pfWorker1
      84  pfWorker2
      40  pfWorker3
      40  pfWorker4
      52  setCRCMassiv
       4  workerUniversal1
       4  workerUniversal2

 
   148 bytes in section .bss
 2 056 bytes in section .text
 
 2 056 bytes of CODE memory
   148 bytes of DATA memory

Errors: none
Warnings: none
